/* Stork Imakefile */
#include "stork_imake.rules"

/* START USER CONFIGURATION ***************************************************/

/* Specify Stork build configuration here. */
#define WANT_STORK_API			YES
#define WANT_STORK_GLOBUS		YES

#if HAVE_EXT_SRB
#  define WANT_STORK_SRB		NO
#endif

#define WANT_STORK_UNITREE		YES
#define WANT_STORK_SRM_CASTOR	YES
#define WANT_STORK_SRM_DCACHE	YES

/* Note the IBP data transfer protocol still has several issues.  First,
 * a this protocol relies upon a private copy of the IBP API.  Instead a new
 * Condor IBP external should be created.  Second, this protocol builds, but
 * has not been tested in some time.
 */
#define WANT_STORK_IBP			NO

/* Do you want to enable hackery used for the SC 2005 Demo?
 */
#define WANT_SC2005_DEMO		NO


/* END USER CONFIGURATION ****************************************************/

/* Core Stork functionality */

/* Default build target - must be first target */
all_target()

soapobjs(stork)

/* Common build flags. */
NEW_CLASSADS_LINK =  -L$(NEW_CLASSADS_LIB) -lclassad_ns
#if !IS_GLIBC20 && !IS_GLIBC21
/* FIXME: this define will be better when fixed to: #if IS_LINUX_RH9 */
/* Stork must support large file (> 2GB) transfers. */
LARGEFILE_DEFS	= \
	-D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE64_SOURCE
#endif /* IS_GLIBC23 */

/* SC2005 Demo */
#if WANT_SC2005_DEMO
SC2005_DEFS		= -DSC2005_DEMO
#endif

STORK_DEFS			= $(LARGEFILE_DEFS) $(SC2005_DEFS)
STORK_INCLUDES		= -I$(NEW_CLASSADS_INC) $(CLASSAD_CONV_INC)
STORK_FLAGS			= $(STORK_DEFS) $(STORK_INCLUDES)
C_PLUS_FLAGS		= $(STD_C_PLUS_FLAGS) $(STORK_FLAGS)
CFLAGS				= $(STD_C_FLAGS) $(STORK_FLAGS)
INST_C_PLUS_FLAGS	= $(STD_C_FLAGS) $(STORK_FLAGS)

CLASSAD_ANALYSIS	= ../classad_analysis
CLASSAD_CONV		= $(CLASSAD_CONV)
CLASSAD_CONV_INC	= -I$(CLASSAD_ANALYSIS)
CLASSAD_CONV_LIBDEFS= -L$(CLASSAD_ANALYSIS) -lconversion

/* internal Stork utilities library */
UTIL_LIB_OBJS = \
	../condor_c++_util/condor_open.o \
	dap_utility.o \
	dap_client_interface.o
STORK_UTIL = libstorkutil.a
library_target($(STORK_UTIL),$(UTIL_LIB_OBJS))

/* server daemon */
SERVER_OBJS  = \
	$(SOAP_OBJS) \
	dap_server.o \
	dap_daemon.o \
	dap_scheduler.o \
	dap_logger.o \
	dap_classad_reader.o \
	stork-lm.o \
	$(STORK_UTIL)
SERVER_LIBS = \
	$(DAEMONCORE_LIB) \
	$(STD_LIBS) \
	$(NEW_CLASSADS_LINK)

public_c_plus_nowrap_target(stork_server,sbin,$(SERVER_OBJS),$(SERVER_LIBS))

/* user tools */
TOOL_LIBS = \
	$(STD_LIBS) \
	$(NEW_CLASSADS_LINK)
public_c_plus_nowrap_target(stork_submit,bin,dap_submit.o $(STORK_UTIL),$(TOOL_LIBS))
public_c_plus_nowrap_target(stork_rm,bin,dap_rm.o $(STORK_UTIL),$(TOOL_LIBS))
public_c_plus_nowrap_target(stork_status,bin,dap_status.o $(STORK_UTIL),$(TOOL_LIBS))
public_c_plus_nowrap_target(stork_q,bin,dap_q.o $(STORK_UTIL),$(TOOL_LIBS))

/* tools, for internal use only */
c_plus_nowrap_target(stork_compute_md5,dap_compute_md5.o $(STORK_UTIL),$(TOOL_LIBS))
c_plus_nowrap_target(stork_performance_monitor,dap_performance_monitor.o $(STORK_UTIL),$(TOOL_LIBS))

/* Module programs */
STORK_MODULE_DIR = libexec
MODULE = stork.
stork_module_target($(MODULE)transfer.file-file,dap_transfer_file-file.o $(STORK_UTIL),)

/* Contrib  targets */

CONTRIB_DIR = contrib_dir
contrib-release:: contrib
STORK_CONTRIB_RELEASE_DIR = $(CONTRIB_DIR)/release_dir
STORK_CONTRIB_RELEASE_MODULE_DIR = $(STORK_CONTRIB_RELEASE_DIR)/$(STORK_MODULE_DIR)
STORK_CONTRIB_STRIP_DIR = $(CONTRIB_DIR)/strip_dir
STORK_CONTRIB_MODULE_STRIP_DIR = $(STORK_CONTRIB_STRIP_DIR)/$(STORK_MODULE_DIR)
contrib-public:: contrib-release contrib-stripped
contrib-release:: contrib
contrib-release:: $(STORK_CONTRIB_RELEASE_MODULE_DIR)
contrib-stripped:: contrib
contrib-stripped:: $(STORK_CONTRIB_MODULE_STRIP_DIR)
$(STORK_CONTRIB_RELEASE_MODULE_DIR):
	mkdir -p $@
$(STORK_CONTRIB_MODULE_STRIP_DIR):
	mkdir -p $@
clean::
	$(RM) -r $(CONTRIB_DIR)

#if WANT_STORK_GLOBUS
XCOMM FIXME: Ugh! This lib list may not be the most efficient for globus.
XCOMM If you can get $(GLOBUS_DIR)/bin/globus-makefile-header working,
XCOMM Use globus-makefile-header --flavor=gcc32dbg globus_ftp_client
GLOBUS_LIB = $(GLOBUS_DIR)/lib
GLOBUS_LIBS = \
	$(STD_LIBS) \
	$(NEW_CLASSADS_LINK) \
	$(GLOBUS_LIB)/libglobus_ftp_client_$(GlobusFlavor).a \
	$(GLOBUS_LIB)/libglobus_ftp_control_$(GlobusFlavor).a \
	$(GLOBUS_LIB)/libglobus_io_$(GlobusFlavor).a \
	$(GLOBUS_LIB)/libglobus_xio_$(GlobusFlavor).a \
	$(GLOBUS_LIB)/libglobus_gss_assist_$(GlobusFlavor).a \
	$(GLOBUS_LIB)/libgssapi_error_$(GlobusFlavor).a \
	$(GLOBUS_LIB)/libglobus_gssapi_gsi_$(GlobusFlavor).a \
	$(GLOBUS_LIB)/libglobus_openssl_$(GlobusFlavor).a \
	$(GLOBUS_LIB)/libglobus_common_$(GlobusFlavor).a \
	$(GLOBUS_LIB)/libglobus_gsi_sysconfig_$(GlobusFlavor).a \
	$(GSI_LIB) \
	$(OPENSSL_LIB)
GLOBUS_COPY = $(MODULE)transfer.globus-url-copy
stork_contrib_module_target($(GLOBUS_COPY),dap_transfer_globus-url-copy.o $(STORK_UTIL),$(GLOBUS_LIBS))
stork_contrib_module_link_target($(GLOBUS_COPY),$(MODULE)transfer.file-gsiftp)
stork_contrib_module_link_target($(GLOBUS_COPY),$(MODULE)transfer.file-ftp)
stork_contrib_module_link_target($(GLOBUS_COPY),$(MODULE)transfer.file-http)
stork_contrib_module_link_target($(GLOBUS_COPY),$(MODULE)transfer.gsiftp-gsiftp)
stork_contrib_module_link_target($(GLOBUS_COPY),$(MODULE)transfer.gsiftp-file)
stork_contrib_module_link_target($(GLOBUS_COPY),$(MODULE)transfer.ftp-file)
stork_contrib_module_link_target($(GLOBUS_COPY),$(MODULE)transfer.http-file)
#endif /* WANT_STORK_GLOBUS */

#if WANT_STORK_SRM_CASTOR
CASTOR_COPY = $(MODULE)transfer.castor_srm
CASTOR_LIBS = \
	$(NEW_CLASSADS_LINK)
stork_contrib_module_target($(CASTOR_COPY),dap_transfer_castor_srm.o $(STORK_UTIL),$(CASTOR_LIBS))
stork_contrib_module_link_target($(CASTOR_COPY),$(MODULE)transfer.file-csrm)
stork_contrib_module_link_target($(CASTOR_COPY),$(MODULE)transfer.csrm-csrm)
stork_contrib_module_link_target($(CASTOR_COPY),$(MODULE)transfer.csrm-file)
#endif /* WANT_STORK_SRM_CASTOR */

#if WANT_STORK_SRM_DCACHE
DCACHE_COPY = $(MODULE)transfer.dcache_srm
DCACHE_LIBS = \
	$(STD_LIBS) \
	$(NEW_CLASSADS_LINK)
stork_contrib_module_target($(DCACHE_COPY),dap_transfer_dcache_srm.o,$(DCACHE_LIBS))
stork_contrib_module_link_target($(DCACHE_COPY),$(MODULE)transfer.file-srm)
stork_contrib_module_link_target($(DCACHE_COPY),$(MODULE)transfer.srm-srm)
stork_contrib_module_link_target($(DCACHE_COPY),$(MODULE)transfer.srm-file)
#endif /* WANT_STORK_SRM_DCACHE */

#if WANT_STORK_UNITREE
UNITREE_COPY = $(MODULE)transfer.unitree
UNITREE_LIBS = \
	$(NEW_CLASSADS_LINK)
stork_contrib_module_target($(UNITREE_COPY),dap_transfer_unitree.o $(STORK_UTIL),$(UNITREE_LIBS))
stork_contrib_module_link_target($(UNITREE_COPY),$(MODULE)transfer.file-unitree)
stork_contrib_module_link_target($(UNITREE_COPY),$(MODULE)transfer.unitree-file)
#endif /* WANT_STORK_UNITREE */

#if WANT_STORK_SRB && HAVE_EXT_GLOBUS
SRB_COPY = $(MODULE)transfer.srb
SRB_ROOT   = $(EXT_INSTALL)/$(EXT_SRB_VERSION)
SRB_LIB    = $(SRB_ROOT)/obj
SRB_INC    = -I$(SRB_ROOT)/src/include -I$(SRB_ROOT)/src/catalog/include
SRB_DEFS = -DMDAS_AUTH -DSTORK_SRB
SRB_CFLAGS = $(SRB_DEFS) $(SRB_INC)
SRB_OBJS = \
	dap_url.o \
	dap_srb_util.o \
	dap_transfer_srb.o
SRB_LIBS = \
	$(SRB_LIB)/libSrbClient.a \
	-lpthread \
	$(STD_LIBS) \
	$(GLOBUS_LIB)/libglobus_gsi_cert_utils_$(GlobusFlavor).a \
	$(GLOBUS_LIB)/libglobus_proxy_ssl_$(GlobusFlavor).a
XCOMM SRB objects need additional C_FLAGS
/* FIXME: dap_url.o should be moved into libstorkutil.a, without SRB dependency
 */
dap_url.o: dap_url.cpp
	$(CPlusPlus) $(C_PLUS_FLAGS) $(SRB_CFLAGS) -c $<
dap_srb_util.o: dap_srb_util.c
	$(CC) $(CFLAGS) $(SRB_CFLAGS) $(CPPFLAGS) -c $<
/* Ugh, we use the Make default rule to build *.c files, so add restate this
 * rule with $(SRB_CFLAGS)
 */
dap_transfer_srb.o: dap_transfer_srb.cpp
	$(CPlusPlus) $(C_PLUS_FLAGS) $(SRB_CFLAGS) -c $<
/* The SRB external is only needed for this Stork contrib module */
ext_target(EXT_SRB_VERSION,$(EXT_TRIGGER)/$(EXT_GLOBUS_VERSION))
contrib:: $(EXT_TRIGGER)/$(EXT_SRB_VERSION)
stork_contrib_module_target($(SRB_COPY),$(SRB_OBJS),$(SRB_LIBS))
stork_contrib_module_link_target($(SRB_COPY),$(MODULE)transfer.file-srb)
stork_contrib_module_link_target($(SRB_COPY),$(MODULE)transfer.srb-file)
#endif /* WANT_STORK_SRB */

#if WANT_STORK_IBP
IBP_COPY = $(MODULE)transfer.ibp
IBP_COPY_OBJS = \
	dap_transfer_ibp.o \
	dap_c_utility.o \
	-lpthread
IBP_RESERVE = reserve.ibp
IBP_RESERVE_OBJS = \
	dap_reserve_ibp.o
XCOMM FIXME: Create a local IBP external, from
XCOMM See http://loci.cs.utk.edu/ibp
IBP_ROOT = /p/condor/workspaces/kosart/ibp-1.3.0
IBP_LIB = $(IBP_ROOT)/lib
IBP_DEFS =
IBP_INC = -I$(IBP_ROOT)/include
IBP_CFLAGS = $(IBP_DEFS) $(IBP_INC)
IBP_LIBS = \
	$(IBP_LIB)/libibp.a
dap_reserve_ibp.o: dap_reserve_ibp.c
	$(CC) $(CFLAGS) $(IBP_CFLAGS) $(CPPFLAGS) -c $<
dap_transfer_ibp.o: dap_transfer_ibp.c
	$(CC) $(CFLAGS) $(IBP_CFLAGS) $(CPPFLAGS) -c $<
stork_contrib_module_target($(IBP_RESERVE),$(IBP_RESERVE_OBJS),$(IBP_LIBS))
stork_contrib_module_target($(IBP_COPY),$(IBP_COPY_OBJS),$(IBP_LIBS))
#endif /* WANT_STORK_IBP */

#if WANT_STORK_API
CLIENT_LIB_OBJS = \
	dc_stork.o \
	dap_client_interface.o
CLIENT_LIB = libstork_client.a
library_target($(CLIENT_LIB),$(CLIENT_LIB_OBJS))
release_library($(CLIENT_LIB),lib)
strip_library($(CLIENT_LIB),lib)
static_library($(CLIENT_LIB),lib)
#endif /* WANT_STORK_API */

gen_soapfiles(stork,condorStork)

#if 1 /* Nick added this */
TEST_LIB = $(STD_LIBS) $(NEW_CLASSADS_LINK) $(CLASSAD_CONVERSION_LIBDEFS)
tests: stork-lm-test stork-lm-test2
c_plus_target( stork-lm-test,stork-lm-test.o stork-lm-nodc.o,$(TEST_LIB) )
stork-lm-nodc.o: stork-lm.cpp
	$(CPlusPlus) $(INST_C_PLUS_FLAGS) -DTEST_VERSION -c stork-lm.cpp -o stork-lm-nodc.o

c_plus_target( stork-lm-test2, stork-lm-test2.o,
	 stork-lm.o $(DAEMONCORE_LIB) $(TEST_LIB) )
#endif /* Nick */

XCOMM Uncomment to build contrib modules as part of default build
all:: contrib

testbin:: all

-include Makelocal.i

### Local Variables: ***
### mode:Makefile ***
### tab-width:4 ***
### comment-column:0 ***
### comment-start: "# "  ***
### End: ***
