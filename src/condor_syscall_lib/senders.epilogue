	case CONDOR_send_file:
	  {
		char	*local;
		char	*remote;
		MODE_T		mode;
		int		loc_fd;
		int		read_status = 0, write_status;
		char	buf[ CONDOR_IO_BUF_SIZE ];
		int		len;
		int		bytes_to_go;
		int		file_size;

		CurrentSysCall = CONDOR_send_file;

		local = va_arg( ap, char *);
		remote = va_arg( ap, char *);
		mode = va_arg( ap, MODE_T );

			/* Do the local open */
		if( (loc_fd = open(local,O_RDONLY)) < 0 ) {
			rval = -1;
			break;
		}

			/* Send over the file name, and mode */
		syscall_sock->encode();
		assert( syscall_sock->code(CurrentSysCall) );
		assert( syscall_sock->code(mode) );
		assert( syscall_sock->code(remote) );
		assert( syscall_sock->end_of_message() );

			/* Grab the result of the remote open */
		syscall_sock->decode();
		assert( syscall_sock->code(rval) );
		if( rval < 0 ) {
			assert( syscall_sock->code(terrno) );
			assert( syscall_sock->end_of_message() );
			errno = terrno;
			rval = -1;
			break;
		}
		assert( syscall_sock->end_of_message() );

			/* Send file length */
		file_size = lseek( loc_fd, 0, 2 );
		lseek( loc_fd, 0, 0 );
		syscall_sock->encode();
		assert( syscall_sock->code(file_size) );

			/* Transfer the data */
		for( bytes_to_go = file_size; bytes_to_go; bytes_to_go -= len ) {
			len = bytes_to_go < sizeof(buf) ? bytes_to_go : sizeof(buf);
			read_status = read( loc_fd, buf, len );
			assert( syscall_sock->code_bytes_bool(buf,len) );
		}
		(void)close( loc_fd );

			/* As a check, re-send the length */
		assert( syscall_sock->code(file_size) );
		assert( syscall_sock->end_of_message() );


			/* Get cumulative status from remote writes */
		syscall_sock->decode();
		assert( syscall_sock->code(write_status) );
		if( write_status < 0 ) {
			assert( syscall_sock->code(terrno) );
			assert( syscall_sock->end_of_message() );
			errno = terrno;
			rval = write_status;
			break;
		}
		assert( syscall_sock->end_of_message() );

			/* If we had a local error on the reads, we had to ignore
			   it until now to avoid getting out of sync with the
			   shadow - now we can deal with it.
			*/
		if( read_status < 0 ) {
			rval = read_status;
			break;
		}

			/* Everything worked - status is cumulative status from
			   remote writes.
			*/
		rval = write_status;
		break;
	}

	case CONDOR_get_file:
	  {
		char	*remote;
		char	*local;
		int		mode;
		int		loc_fd;
		int		open_status, write_status = 0, read_status;
		char	buf[ CONDOR_IO_BUF_SIZE ];
		int		checksum;
		int		len;
		int		file_size;
		int		bytes_to_go;
		int		scm;
		int		close_status;

		CurrentSysCall = CONDOR_get_file;

			/* Marshall the arguments */
		remote = va_arg( ap, char *);
		local = va_arg( ap, char *);
		mode = va_arg( ap, int );

			/* Open local file for writing */
		loc_fd = open( local, O_WRONLY|O_CREAT|O_TRUNC, mode );
		if( loc_fd < 0 ) {
			rval = -1;
			break;
		}

			/* Send over the file name */
		syscall_sock->encode();
		assert( syscall_sock->code(CurrentSysCall) );
		assert( syscall_sock->code(remote) );
		assert( syscall_sock->end_of_message() );

			/* Grab the result of the remote open */
		syscall_sock->decode();
		assert( syscall_sock->code(rval) );
		if( rval < 0 ) {
			assert( syscall_sock->code(terrno) );
			assert( syscall_sock->end_of_message() );
			errno = terrno;
			rval = -1;
			break;
		}

			/* Get the size of the file */
		assert( syscall_sock->code(file_size) );

			/* Transfer the data */
		for( bytes_to_go = file_size; bytes_to_go; bytes_to_go -= len ) {
			len = bytes_to_go < sizeof(buf) ? bytes_to_go : sizeof(buf);
			assert( syscall_sock->code_bytes_bool(buf,len) );
			write_status = write( loc_fd, buf, len );
		}
		close_status = close( loc_fd );
		if( close_status < 0 ) {
			dprintf( D_ALWAYS,
				"Close of \"%s\" failed - errno = %d\n", local, errno
			);
		}

			/* Should get file size again as a check */
		assert( syscall_sock->code(checksum) );
		assert( checksum == file_size );

			/* Get status from remote reads */
		assert( syscall_sock->code(read_status) );
		if( read_status < 0 ) {
			assert( syscall_sock->code(terrno) );
			assert( syscall_sock->end_of_message() );
			errno = terrno;
			rval = -1;
			break;
		}
		assert( syscall_sock->end_of_message() );

			/* Wrapup */
		if( write_status >= 0 && read_status >= 0 && close_status >= 0 ) {
			dprintf( D_ALWAYS,
				"CONDOR_get_file: transferred %d bytes\n", file_size );
			rval = 0;
		} else {
			rval = -1;
		}

		break;
	}

	  default:
		SetSyscalls( scm );
		fprintf(
			stderr,
			"Don't know how to do system call %d <%s> remotely - yet\n",
			syscall_num, _condor_syscall_name( syscall_num )
		);
		rval =  -1;
	}

	/* defined in local_startup.c and remote_startup.c */
	restore_condor_sigmask(omask);

	SetSyscalls( scm );
	return rval;
}
