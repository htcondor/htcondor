XCOMM
XCOMM Define the features used from syscall.tmpl.
XCOMM Unlike libckpt, the syscall library uses
XCOMM all of the features.
XCOMM

#ifdef DOES_REMOTE_SYSCALLS
	REMOTE_SYSCALLS = -DREMOTE_SYSCALLS
#else
	CLIP = -DCLIP
	REMOTE_SYSCALLS = -DREMOTE_SYSCALLS
#endif

#if NEEDS_64BIT_SYSCALLS
HAS_64BIT_SYSCALLS = -DHAS_64BIT_SYSCALLS
#endif

#if NEEDS_64BIT_STRUCTS
HAS_64BIT_STRUCTS = -DHAS_64BIT_STRUCTS
#endif

#if DOES_SAVE_SIGSTATE
	SAVE_SIGSTATE = -DSAVE_SIGSTATE
		SIG_CKPT_OBJS = signals_support.o signals_control.o
#endif

FILE_TABLE = -DFILE_TABLE -I$(ZLIB_INC)
FILE_TABLE_OBJ = file_state.o condor_file.o condor_file_basic.o condor_file_local.o condor_file_remote.o condor_file_special.o condor_file_agent.o condor_file_buffer.o condor_file_fd.o condor_file_compress.o condor_file_append.o file_table_interf.o

OS = OperatingSystem
ARCH = Architecture

CFLAGS = $(STD_C_FLAGS) $(DL_EXTRACT) $(FILE_TABLE) $(REMOTE_SYSCALLS)

C_PLUS_FLAGS = $(STD_C_PLUS_FLAGS) $(STUB_CLUMPS_FLAG) $(DL_EXTRACT) \
	$(FILE_TABLE) $(REMOTE_SYSCALLS) $(SAVE_SIGSTATE) -I../condor_ckpt \
	-fno-exceptions -DHEADER_DES_LOCL_H

#ifdef DOES_CHECKPOINTING  /* ========= DOES CHECKPOINTING ============ */

#if IS_LINUX
#if IS_GLIBC22 || IS_GLIBC23 || IS_GLIBC24 || IS_GLIBC25 || IS_GLIBC27
FORK_OBJ = FORK.o
#endif /* libc */
#endif /* LINUX */

#	if IS_HPUX
EXTRACT = FORK.o GETEUID.o GETPPID.o GETEGID.o SYSCALL.o __SYSCALL.o \
		  MMAP.o PIPE.o GETCWD.o GETLOGIN.o
#	elif IS_LINUX && (IS_GLIBC22 || IS_GLIBC23 || IS_GLIBC24 || IS_GLIBC25 || IS_GLIBC27)
EXTRACT = GETCWD.o MMAP.o SYSCALL.o GETEUID.o GETEGID.o GETPPID.o \
		$(FORK_OBJ) PIPE.o GETLOGIN.o SYSDEP.o SIGSUSPEND.o \
		TRUNCATE.o SIGACTION.o GETDIRENTRIES.o 
#	elif IS_SUN4X_SOLARIS26
EXTRACT = FORK.o SIGACTION.o GETEUID.o GETPPID.o GETEGID.o \
		  MMAP.o SYSCALL.o PIPE.o _SIGACTION.o TRUNCATE.o \
		  GETCWD.o GETRUSAGE.o \
		  SYSCONF.o GETLOGIN.o LSEEK64.o \
		  GETPAGESIZE.o
#	elif IS_SUN4X_SOLARIS27
EXTRACT = FORK.o SIGACTION.o GETEUID.o GETPPID.o GETEGID.o \
		  MMAP.o SYSCALL.o PIPE.o _SIGACTION.o TRUNCATE.o \
		  GETCWD.o GETRUSAGE.o \
		  SYSCONF.o GETLOGIN.o LSEEK64.o \
		  GETPAGESIZE.o WAITPID.o
#	elif IS_SUN4X_SOLARIS28
EXTRACT = FORK.o SIGACTION.o GETEUID.o GETPPID.o GETEGID.o \
		  MMAP.o SYSCALL.o PIPE.o _SIGACTION.o TRUNCATE.o \
		  GETCWD.o GETRUSAGE.o \
		  SYSCONF.o GETLOGIN.o LSEEK64.o GETMNTENT.o TSDALLOC.o \
		  GETPAGESIZE.o WAITPID.o
#	elif IS_SUN4X_SOLARIS29
EXTRACT = FORK.o SIGACTION.o GETEUID.o GETPPID.o GETEGID.o \
		  MMAP.o SYSCALL.o PIPE.o _SIGACTION.o TRUNCATE.o \
		  GETCWD.o GETRUSAGE.o \
		  SYSCONF.o GETLOGIN.o LSEEK64.o OPENDIR.o \
		  GETPAGESIZE.o WAITPID.o 
#	else
EXTRACT = FORK.o SIGACTION.o GETEUID.o GETPPID.o GETEGID.o GETWD.o \
		  MMAP.o PIPE.o GETLOGIN.o SYSCALL.o
#	endif

#else	/* =============  DOES NOT DO CHECKPOINTING ============*/

#	if IS_HPUX || IS_SOLARIS
EXTRACT = GETEUID.o GETEGID.o
#	else 
EXTRACT = GETEUID.o GETEGID.o GETWD.o
#	endif

#endif	/* ===============  CHECKPOINTING CONDITIONAL ============*/

#if IS_HPUX
PLATFORM_UTIL_OBJ = seteuid.o setegid.o
#endif

DEP_OS = OperatingSystem

#if !HAS_FLOCK
FLOCK_OBJ = flock.o
#endif

STUBS = switches.o switches.special.o getcwd.o

UTIL = \
	extern_path.o \
	remote_syscall.o \
	syscall_connect.o \
	senders.o \
	remote_startup.o \
	file_stream.o

NAME_TAB = syscall_numbers.o

SRC = \
	extern_path.c \
	receivers.epilogue \
	receivers.prologue \
	remote_startup.c \
	remote_syscall.cpp \
	senders.epilogue \
	senders.prologue \
	switches.prologue \
	switches.epilogue \
	switches.special.cpp \
	syscall.tmpl \
	syscall_connect.cpp \
	syscall_numbers.c \
	xfer_file.c \
	file_stream.c \
        ios_stub.cpp \
        ios_msg.cpp

URL_OBJ = url_condor.o include_urls.o cbstp_url.o file_url.o http_url.o \
	cfilter_url.o filter_url.o mailto_url.o ftp_url.o

#ifdef DOES_CHECKPOINTING
CKPT_OBJ = $(FILE_TABLE_OBJ)\
	image.o tmp_stack.o machdep.$(DEP_OS).o malloc-user.o \
	syscall_mode.o fake_hooks.o $(LONGJMP) $(HP_CKPT) \
	$(SIG_CKPT_OBJS) eprintf.o shared_utils.o condor_error.o \
	gtodc.o
#else
CKPT_OBJ = $(FILE_TABLE_OBJ) syscall_mode.o eprintf.o shared_utils.o condor_error.o
#endif

#ifdef DOES_COMPRESS_CKPT
#if IS_SUN4X_SOLARIS
#if IS_SOLARIS29
/* _rem.o, _div.o, umultiply.o were consolidated into hwmuldiv.o in sol 2.9 */
COMPRESS_OBJ = malloc-condor.o zimage.o hwmuldiv.o
#else
COMPRESS_OBJ = malloc-condor.o zimage.o _rem.o _div.o umultiply.o
#endif
#else
COMPRESS_OBJ = malloc-condor.o zimage.o
#endif
COMPRESS_LIB = libcondorzsyscall.a
#endif

SYSCALL_SUPPORT_OBJ=senders.o receivers.o syscall_mode.o syscall_connect.o remote_syscall.o syscall_numbers.o xfer_file.o

UTIL_OBJ =  $(FLOCK_OBJ) dprintf_common.o except.o update_rusage.o \
	internet.o $(PLATFORM_UTIL_OBJ) mkargv.o filename_tools.o \
	strupr.o string_funcs.o \
	mark_thread.o

CPP_UTIL_OBJ = \
	condor_version.o condor_ver_info.o \
	stat_wrapper.o stat_wrapper_internal.o \
	condor_open.o selector.o \
	MyString.o subsystem_info.o \
	HashTable.o

CONDOR_TYPE_OBJ = sig_num.o open_flags.o fcntl_cmd.o errno_num.o

IO_OBJ = stream.o sock.o safe_sock.o reli_sock.o buffers.o $(CONDOR_TYPE_OBJ) condor_rw.o SafeMsg.o

#if HAVE_EXT_OPENSSL
   CONDOR_DES_OBJ = condor_crypt_3des.o
   CONDOR_BLOWFISH_OBJ = condor_crypt_blowfish.o
#endif

OPENSSL_OBJ = md5_dgst.o md5_one.o rand_lib.o md_rand.o sha1dgst.o cryptlib.o \
	buffer.o stack.o err.o lhash.o mem.o rand_win.o mem_dbg.o b_print.o \
	bio_lib.o bss_file.o ex_data.o mem_clr.o eng_init.o tb_rand.o \
	digest.o m_sha1.o rand_unix.o eng_lib.o eng_table.o eng_list.o \
	tb_digest.o rsa_sign.o rand_egd.o obj_dat.o x_sig.o rsa_lib.o \
	a_object.o obj_lib.o asn1_lib.o tasn_dec.o x_algor.o tasn_typ.o \
	rsa_eay.o tb_rsa.o bn_lib.o bn_blind.o bn_ctx.o tasn_enc.o \
	tasn_new.o tasn_fre.o bn_rand.o bn_gcd.o tasn_utl.o a_type.o \
	a_bitstr.o a_int.o bn_mod.o bn_mont.o bn_div.o bn_word.o bn_shift.o \
	bn_add.o bn_asm.o bn_sqr.o bn_exp.o rsa_none.o rsa_pk1.o rsa_oaep.o \
	rsa_ssl.o a_dup.o bn_recp.o bn_mul.o rsa_x931.o sha512.o sha256.o \
	eng_ctrl.o bn_print.o evp_lib.o evp_asn1.o a_bytes.o

#if HAVE_EXT_OPENSSL
CONDOR_CRYPT_OBJ = CryptKey.o condor_crypt.o condor_md.o ../condor_util_lib/get_random_num.o \
	$(CONDOR_DES_OBJ) $(CONDOR_BLOWFISH_OBJ) $(OPENSSL_OBJ)
#else 
CONDOR_CRYPT_OBJ = CryptKey.o condor_crypt.o condor_md.o ../condor_util_lib/get_random_num.o \
	$(CONDOR_DES_OBJ) $(CONDOR_BLOWFISH_OBJ) 
#endif

SPECIAL_IO_OBJ = authentication.o $(CONDOR_CRYPT_OBJ)

SPECIAL_OBJ = special_stubs.o cedar_no_ckpt_stubs.o

LIB_OBJ = $(EXTRACT) $(STUBS) $(UTIL) $(NAME_TAB) $(XDR_OBJ) $(UTIL_OBJ) \
	$(CKPT_OBJ) $(UTIL_EXTRACT) $(IOS_STUBS) $(IO_OBJ) $(SPECIAL_IO_OBJ) \
	$(CPP_UTIL_OBJ) $(SPECIAL_OBJ)

SIMPLE_OBJ = condor_rt0.o extern_path.o xfer_file.o libcondorc++support.a
SYSCALL_LIB = libcondorsyscall.a

#ifdef DOES_REMOTE_SYSCALLS
all_target(tmp_dir $(SYSCALL_LIB) $(COMPRESS_LIB) receivers.o $(SIMPLE_OBJ) syscall-list)
#else 
all_target(tmp_dir $(SYSCALL_SUPPORT_OBJ) extern_path.o file_stream.o)
#endif

TMP_DIR = tmp_dir
tmp_dir:
	mkdir tmp_dir; chmod 755 tmp_dir
clean::
	rm -rf tmp_dir

stubs: switches.cpp senders.cpp receivers.cpp

testbin:: all

ToUpper:
	ln -s ../condor_ckpt/ToUpper ToUpper

clean::
	rm -f ToUpper

uppercase_target($(SIMPLE_LIBC),geteuid.o,GETEUID.o,geteuid,GETEUID)
uppercase_target($(SIMPLE_LIBC),getppid.o,GETPPID.o,getppid,GETPPID)
uppercase_target($(SIMPLE_LIBC),getegid.o,GETEGID.o,getegid,GETEGID)
uppercase_target($(SIMPLE_LIBC),getlogin.o,GETLOGIN.o,getlogin,GETLOGIN)
uppercase_target($(SIMPLE_LIBC),fsync.o,FSYNC.o,fsync,FSYNC)

uppercase_target($(SIMPLE_LIBC),sigaction.o,SIGACTION.o,sigaction,SIGACTION)
uppercase_target($(SIMPLE_LIBC),_sigaction.o,_SIGACTION.o,sigaction,SIGACTION)

#if IS_SOLARIS
TRUNCATE.o : ToUpper $(SIMPLE_LIBC)
	ar x $(SIMPLE_LIBC) truncate.o
	./ToUpper truncate.o truncate.tmp.o ftruncate FTRUNCATE
	./ToUpper truncate.tmp.o TRUNCATE.o truncate TRUNCATE
	rm -f truncate.tmp.o truncate.o

clean::
	rm -f TRUNCATE.o
#else
uppercase_target($(SIMPLE_LIBC),truncate.o,TRUNCATE.o,truncate,TRUNCATE)
#endif

uppercase_target($(SIMPLE_LIBC),sigsuspend.o,SIGSUSPEND.o,sigsuspend,SIGSUSPEND)
uppercase_target($(SIMPLE_LIBC),mmap.o,MMAP.o,mmap,MMAP)
uppercase_target($(SIMPLE_LIBC),pipe.o,PIPE.o,pipe,PIPE)
uppercase_target($(SIMPLE_LIBC),getdirentries.o,GETDIRENTRIES.o,getdirentries,GETDIRENTRIES)


uppercase_target($(SIMPLE_LIBC),__geteuid.o,__GETEUID.o,__geteuid,__GETEUID)
uppercase_target($(SIMPLE_LIBC),__getegid.o,__GETEGID.o,__getegid,__GETEGID)
uppercase_target($(SIMPLE_LIBC),__getppid.o,__GETPPID.o,__getppid,__GETPPID)
uppercase_target($(SIMPLE_LIBC),__sigact.o,__SIGACT.o,__sigaction,__SIGACTION)
uppercase_target($(SIMPLE_LIBC),__pipe.o,__PIPE.o,__pipe,__PIPE)

#if IS_SOLARIS28
/* I'm sorry about this mess. GETCWD.o now calls a bunch of things inside
	of getmntent.o which normally wouldn't be a problem... except for some
	reason libc.so declares getmntent functions as private, whereas libc.a
	declares them as global. So This means we may not link with them from the
	extracted GETCWD. So, *sigh* I must extract and rename the local functions
	from getmntent.o and fix up the sol 2.8 version of getcwd to reflect that
	I want to call my version of GETMNTENT. -pete 04-25-2000 */
GETCWD.o: ToUpper $(SIMPLE_LIBC)
	ar x $(SIMPLE_LIBC) getcwd.o
	./ToUpper getcwd.o getcwd2.o _getextmntent _GETEXTMNTENT
	./ToUpper getcwd2.o getcwd3.o _hasmntopt _HASMNTOPT
	./ToUpper getcwd3.o getcwd4.o _resetmnttab _RESETMNTTAB
	./ToUpper getcwd4.o GETCWD.o getcwd GETCWD
	rm -f getcwd.o getcwd2.o getcwd3.o getcwd4.o

GETMNTENT.o : ToUpper $(SIMPLE_LIBC)
	ar x $(SIMPLE_LIBC) getmntent.o
	./ToUpper getmntent.o getmntent2.o getextmntent GETEXTMNTENT
	./ToUpper getmntent2.o getmntent3.o getmntany GETMNTANY
	./ToUpper getmntent3.o getmntent4.o getmntent GETMNTENT
	./ToUpper getmntent4.o getmntent5.o hasmntopt HASMNTOPT
	./ToUpper getmntent5.o getmntent6.o resetmnttab RESETMNTTAB
	./ToUpper getmntent6.o getmntent7.o getline GETLINE
	./ToUpper getmntent7.o getmntent8.o _tsdbufalloc _TSDBUFALLOC
	./ToUpper getmntent8.o GETMNTENT.o mntopt MNTOPT
	rm -f getmntent.o getmntent2.o getmntent3.o getmntent4.o getmntent5.o getmntent6.o getmntent7.o

/* Grrr.... does it ever end? */
TSDALLOC.o: ToUpper $(SIMPLE_LIBC)
	ar x $(SIMPLE_LIBC) tsdalloc.o
	./ToUpper tsdalloc.o tsdalloc2.o _free_tsdbuf _FREE_TSDBUF
	./ToUpper tsdalloc2.o TSDALLOC.o _tsdbufalloc _TSDBUFALLOC
	rm -f tsdalloc.o tsdalloc2.o

#elif IS_SOLARIS29
/* I'm sorry about this mess. GETCWD.o now calls something inside
	of opendir.o which normally wouldn't be a problem... except for some
	reason libc.so declares opendir.o functions as private, whereas libc.a
	declares them as global. So This means we may not dynamically link with 
	them from the extracted GETCWD. So, *sigh* I must extract and rename the 
	local functions from opendir.o and fix up the sol 2.9 version of 
	getcwd to reflect that I want to call my version of OPENDIR_STAT. 
	-pete 11-04-2002 */
GETCWD.o: ToUpper $(SIMPLE_LIBC)
	ar x $(SIMPLE_LIBC) getcwd.o
	./ToUpper getcwd.o getcwd2.o opendir_stat OPENDIR_STAT
	./ToUpper getcwd2.o GETCWD.o getcwd GETCWD
	rm -f getcwd.o getcwd2.o

OPENDIR.o : ToUpper $(SIMPLE_LIBC)
	ar x $(SIMPLE_LIBC) opendir.o
	./ToUpper opendir.o opendir2.o _dirent_lock _DIRENT_LOCK
	./ToUpper opendir2.o opendir3.o opendir OPENDIR
	./ToUpper opendir3.o OPENDIR.o OPENDIR_stat OPENDIR_STAT
	rm -f opendir.o opendir2.o opendir3.o 

#else

uppercase_target($(SIMPLE_LIBC),getcwd.o,GETCWD.o,getcwd,GETCWD)
#endif

uppercase_target($(SIMPLE_LIBC),getrusage.o,GETRUSAGE.o,getrusage,GETRUSAGE)

#if IS_GLIBC25 || IS_GLIBC27
uppercase_target($(SIMPLE_LIBC),fork.o,FORK_TMP.o,fork,FORK)

FORK.o: FORK_TMP.o
	./ToUpper FORK_TMP.o FORK.o __FORK_lock __fork_lock

#else
uppercase_target($(SIMPLE_LIBC),fork.o,FORK.o,fork,FORK)
#endif

#if ! IS_LINUX
uppercase_target($(SIMPLE_LIBC),__fork.o,__FORK.o,__fork,__FORK)
#endif
uppercase_target($(SIMPLE_LIBC),vfork.o,VFORK.o,fork,VFORK)

#if IS_SOLARIS
uppercase_target($(SIMPLE_LIBC),lseek64.o,LSEEK64.o,lseek64,LSEEK64)
#endif


#if IS_I386_LINUX
____SIG.o : ToUpper $(SIMPLE_LIBC)
	ar x $(SIMPLE_LIBC) ____sig.o
	./ToUpper ____sig.o ____SIG_TMP.o ___sig_restore ___SIG_RESTORE
	./ToUpper ____SIG_TMP.o ____SIG.o ___masksig_restore ___MASKSIG_RESTORE
	rm -f ____sig.o ____SIG_TMP.o

uppercase_target($(SIMPLE_LIBC),__prev_stat.o,__PREV_STAT.o,stat,STAT)
uppercase_target($(SIMPLE_LIBC),__prev_lstat.o,__PREV_LSTAT.o,lstat,LSTAT)
uppercase_target($(SIMPLE_LIBC),__prev_fstat.o,__PREV_FSTAT.o,fstat,FSTAT)

#endif


#if IS_LINUX && IS_GLIBC
uppercase_target($(SIMPLE_LIBC),syscall.o,SYSCALL_TMP.o,syscall,SYSCALL)
uppercase_target($(SIMPLE_LIBC),sysdep.o,SYSDEP_TMP.o,__syscall_error,__SYSCALL_ERROR)

SYSCALL.o: SYSCALL_TMP.o ToUpper
	./ToUpper SYSCALL_TMP.o SYSCALL.o __SYSCALL_error __syscall_error


#if IS_GLIBC25 || IS_GLIBC27
SYSDEP.o: SYSDEP_TMP.o
	cp SYSDEP_TMP.o SYSDEP.o
#else
SYSDEP_TMP2.o: SYSDEP_TMP.o ToUpper
	./ToUpper SYSDEP_TMP.o SYSDEP_TMP2.o errno ERRNO

SYSDEP.o: SYSDEP_TMP2.o ToUpper
	./ToUpper SYSDEP_TMP2.o SYSDEP.o __ERRNO_location __errno_location
#endif

clean::
	rm -f SYSCALL_TMP.o
#else
uppercase_target($(SIMPLE_LIBC),syscall.o,SYSCALL.o,syscall,SYSCALL)
uppercase_target($(SIMPLE_LIBC),__syscall.o,__SYSCALL.o,__syscall,__SYSCALL)
#endif

#if IS_SOLARIS
SYSCONF.o :  $(SIMPLE_LIBC)  ToUpper
	ar x    $(SIMPLE_LIBC)      sysconf.o 	  ; mv  sysconf.o  $(TMP_DIR)
	./ToUpper $(TMP_DIR)/sysconf.o   $(TMP_DIR)/SYSCONF.o   sysconf   SYSCONF
	./ToUpper $(TMP_DIR)/SYSCONF.o   SYSCONF.o SYSCONFig sysconfig
	rm -f $(TMP_DIR)/sysconf.o $(TMP_DIR)/SYSCONF.o
uppercase_target($(SIMPLE_LIBC),getpagesize.o,GETPAGESIZE.o,getpagesize,GETPAGESIZE)
#endif

#if IS_SOLARIS27 || IS_SOLARIS28 || IS_SOLARIS29
uppercase_target($(SIMPLE_LIBC),waitpid.o,WAITPID.o,waitpid,WAITPID)
#endif

#if defined(DOES_CHECKPOINTING) || defined(DOES_REMOTE_SYSCALLS)
public_copy_target(condor_rt0.o,lib,condor_rt0.o,OBJECT_MODE)
#endif

#if IS_LINUX
	library_target(libtmp.a,$(LIB_OBJ))

clean::
	rm -f libcondorsyscall.a

libcondorsyscall.a: libtmp.a ToUpper
	./ToUpper libtmp.a libcondorsyscall.a __syscall_error __SYSCALL_ERROR
#else /* Not Linux */
	library_target(libcondorsyscall.a,$(LIB_OBJ))
#endif

#if defined(DOES_CHECKPOINTING) || defined(DOES_REMOTE_SYSCALLS)
public_library(libcondorsyscall.a,lib)
#ifdef DOES_CHECKPOINTING
XCOMM Always needed for the file table compressed files feature set.
XCOMM Sometimes needed for checkpoint page compression.
XCOMM It is copied to <release>/lib and given a new name to stop library name
XCOMM pollution when people put -L<release>/lib into their path when trying
XCOMM to link against libcondorapi.a, which lives in the same place.
public_library(libcondor_z.a,lib)
#endif
#endif

#ifdef DOES_COMPRESS_CKPT
public_library($(COMPRESS_LIB),lib)
#endif

XCOMM If no remote syscalls & no checkpointing support, then no need
XCOMM to release anything into RELEASEDIR/lib, since we only do VANILLA jobs
#if !defined(DOES_CHECKPOINTING) && !defined(DOES_REMOTE_SYSCALLS)
release:: all
stripped:: all
static:: all
#endif

CPP = PreProcessCmd

#if IS_I386_LINUX
STUB_GEN_PLATFORM = GlibCFlag
#elif IS_X86_64_LINUX
STUB_GEN_PLATFORM = GlibCFlag
#elif IS_SOLARIS26
STUB_GEN_PLATFORM = -DSolaris26
#elif IS_SOLARIS27
STUB_GEN_PLATFORM = -DSolaris27
#elif IS_SOLARIS28
STUB_GEN_PLATFORM = -DSolaris28
#elif IS_SOLARIS29
STUB_GEN_PLATFORM = -DSolaris29
#endif

STUB_GEN_FLAGS = $(STUB_GEN_PLATFORM) $(DL_EXTRACT) -D$(OS) -D$(ARCH) \
	-D$(DIST_FLAG) $(SAVE_SIGSTATE) $(FILE_TABLE) $(REMOTE_SYSCALLS) $(CLIP) \
	$(HAS_64BIT_SYSCALLS) $(HAS_64BIT_STRUCTS)

switches.cpp: syscall.tmpl switches.prologue stub_gen switches.epilogue
	$(CPP) -DSWITCH $(STUB_GEN_FLAGS) -I../condor_includes syscall.tmpl | \
	./stub_gen -mode switches  -p switches.prologue -e switches.epilogue \
	> switches.cpp

senders.cpp: syscall.tmpl stub_gen senders.prologue senders.epilogue
	$(CPP) -DSENDER $(STUB_GEN_FLAGS) -I../condor_includes syscall.tmpl | \
	./stub_gen -mode senders -p senders.prologue -e senders.epilogue \
	$(STUB_CLUMP_SIZE) > senders.cpp

receivers.cpp: syscall.tmpl stub_gen receivers.prologue receivers.epilogue pseudo_ops.h
	$(CPP) -DRECEIVER $(STUB_GEN_FLAGS) -I../condor_includes syscall.tmpl | \
	./stub_gen -mode receivers -p receivers.prologue \
	-e receivers.epilogue -n syscheck $(STUB_CLUMP_SIZE) > receivers.cpp

syscall-list: syscall.tmpl stub_gen libcondorsyscall.a
	$(CPP) -DSWITCH $(STUB_GEN_FLAGS) -I../condor_includes syscall.tmpl | \
	./stub_gen -mode listcalls > syscall-list

clean::
	rm -f syscall-list

clean::
	rm -f lex.yy.c y.tab.c y.tab.h switches.cpp senders.cpp receivers.cpp *.o

/*depend_target($(SRC)) */

IMPORT_LINKS = ../../config/import_links
import_objs(../condor_io,$(IO_OBJ))
import_objs(../condor_util_lib,$(UTIL_OBJ))
import_objs(../condor_c++_util,$(CPP_UTIL_OBJ))
import_objs(../condor_ckpt,condor_rt0.o)
import_objs(../condor_ckpt,$(CKPT_OBJ))
import_objs(../condor_ckpt,$(COMPRESS_OBJ))
import_objs(../h,syscall_numbers.c)
import_objs(../condor_util_lib,stub_gen)
import_objs(../condor_shadow.std,pseudo_ops.h)
import_objs(../condor_ckpt,libcondorc++support.a)
#ifdef DOES_CHECKPOINTING
XCOMM Always needed for the file table compressed files feature.
XCOMM If checkpoints may be compressed, it is needed for that too.
XCOMM It is copied to <release>/lib and given a new name to stop library name
XCOMM pollution when people put -L<release>/lib into their path when trying
XCOMM to link against libcondorapi.a, which lives in the same place.
all_symlink_target($(ZLIB_LIB)/libz.a,libcondor_z.a)
#endif

authentication.o: ../condor_io/authentication.cpp
	$(CPlusPlus) $(C_PLUS_FLAGS) -I../condor_io \
		-DSKIP_AUTHENTICATION -c ../condor_io/authentication.cpp

condor_md.o: ../condor_c++_util/condor_md.cpp
	$(CPlusPlus) $(C_PLUS_FLAGS) -I../condor_c++_util \
	        -DSKIP_AUTHENTICATION -c ../condor_c++_util/condor_md.cpp

condor_crypt_3des.o: ../condor_io/condor_crypt_3des.cpp
	$(CPlusPlus) $(C_PLUS_FLAGS) -I../condor_io \
		-DSKIP_AUTHENTICATION -c ../condor_io/condor_crypt_3des.cpp

condor_crypt_blowfish.o: ../condor_io/condor_crypt_blowfish.cpp
	$(CPlusPlus) $(C_PLUS_FLAGS) -I../condor_io \
		-DSKIP_AUTHENTICATION -c ../condor_io/condor_crypt_blowfish.cpp

CryptKey.o: ../condor_io/CryptKey.cpp
	$(CPlusPlus) $(C_PLUS_FLAGS) -I../condor_io \
		-DSKIP_AUTHENTICATION -c ../condor_io/CryptKey.cpp

condor_crypt.o: ../condor_io/condor_crypt.cpp
	$(CPlusPlus) $(C_PLUS_FLAGS) -I../condor_io \
		-DSKIP_AUTHENTICATION -c ../condor_io/condor_crypt.cpp

#ifdef DOES_COMPRESS_CKPT
$(COMPRESS_LIB) : $(SYSCALL_LIB) $(COMPRESS_OBJ)
	cp $(SYSCALL_LIB) $(COMPRESS_LIB)
	ar -d $(COMPRESS_LIB) image.o
	ar -r $(COMPRESS_LIB) $(COMPRESS_OBJ)
clean::
	rm -f $(COMPRESS_LIB) $(COMPRESS_OBJ)
#endif

html:

DEPEND_SRC = C_getenv.c extern_path.c file_stream.c getcwd.c remote_startup.c \
remote_syscall.cpp switches.special.cpp syscall_connect.cpp xfer_file.c

depend_source_target($(DEPEND_SRC))

#if HAVE_EXT_OPENSSL
obj_extract($(OPENSSL_MD_LIB),$(OPENSSL_OBJ))
#endif


#if ! IS_CLIPPED && IS_GLIBC
/*
   glibc 2.1.3 added/renamed some libc calls that broke how we trap
   stuff.  So in order to not have a release tar ball for EACH redhat
   release (we once hoped *grin*), we just ship glibc with it in the
   condor/lib directory (it will automatically get used before the
   real libc courtesy of -L on the link line).  This will be the case
   until we hit a set of header files that can't be used with whatever
   glibc version we're shipping for a given release.

   Futhermore, we do all this in condor_syscall_lib/Imakefile (not
   condor_scripts, where it used to live), because we want to be able
   to link the test suite against these libraries "in place".  We
   don't want to have to do any copying or packaging step like "make
   release" or "make public" before we can build the test suite.
*/
all_symlink_target($(GLIBC_DIR)/libc.a,libcondor_c.a)
all_symlink_target($(GLIBC_DIR)/libnss_files.a,libcondor_nss_files.a)
all_symlink_target($(GLIBC_DIR)/libnss_dns.a,libcondor_nss_dns.a)
all_symlink_target($(GLIBC_DIR)/libresolv.a,libcondor_resolv.a)

public_copy_target($(GLIBC_DIR)/libc.a,lib,libcondor_c.a,OBJECT_MODE)
public_copy_target($(GLIBC_DIR)/libnss_files.a,lib,libcondor_nss_files.a,OBJECT_MODE)
public_copy_target($(GLIBC_DIR)/libnss_dns.a,lib,libcondor_nss_dns.a,OBJECT_MODE)
public_copy_target($(GLIBC_DIR)/libresolv.a,lib,libcondor_resolv.a,OBJECT_MODE)

#endif /* ! IS_CLIPPED && IS_GLIBC */

#if ! IS_CLIPPED && (IS_C_COMP_MAJOR_GCC_3 || IS_C_COMP_MAJOR_GCC_4)

/*
   Starting with gcc3, we are going to ship three internal libraries
   that come with the compiler that we are going to use to replace
   what libcondorc++support.a used to do. This is because C++ support
   for gcc has gone through a serious upgrade, and these three
   libraries and the functions we need in them to support the syscall
   libraries are now basically inseperable from each other. No more
   can we make our simple libcondorc++support.a do what it did
   before. Now we just must include everything. :(

   Once again, we must do this in the condor_syscall_lib/Imakefile so
   that we can build the test suite and link against these libraries
   in place, without anything other than "make all".
*/
all_symlink_target($(GCC_LIBC),libcomp_libgcc.a)
all_symlink_target($(LIB_GCC_EH),libcomp_libgcc_eh.a)
all_symlink_target($(LIB_STDCPP),libcomp_libstdc++.a)

public_copy_target(libcomp_libgcc.a,lib,libcomp_libgcc.a,OBJECT_MODE)
public_copy_target(libcomp_libstdc++.a,lib,libcomp_libstdc++.a,OBJECT_MODE)
public_copy_target(libcomp_libgcc_eh.a,lib,libcomp_libgcc_eh.a,OBJECT_MODE)

#endif /* ! IS_CLIPPED && IS_C_COMP_MAJOR_GCC_3 */



