CMNT
CMNT Define the features used from syscall.tmpl.
CMNT Unlike libckpt, the syscall library uses
CMNT all of the features.
CMNT

#if DOES_REMOTE_SYSCALLS
	REMOTE_SYSCALLS = -DREMOTE_SYSCALLS
#else
	CLIP = -DCLIP
	REMOTE_SYSCALLS = -DREMOTE_SYSCALLS
#endif

#if NEEDS_64BIT_SYSCALLS
HAS_64BIT_SYSCALLS = -DHAS_64BIT_SYSCALLS
#endif

#if NEEDS_64BIT_STRUCTS
HAS_64BIT_STRUCTS = -DHAS_64BIT_STRUCTS
#endif

#if DOES_SAVE_SIGSTATE
	SAVE_SIGSTATE = -DSAVE_SIGSTATE
	#if IS_DUX
		SIG_CKPT_OBJS = signals_support.o signals_control.o SIGPROCMASK.o SIGSUSPEND.o SIGACTION.o SIGNAL.o _SIGSUSPEND.o
	#else
		SIG_CKPT_OBJS = signals_support.o signals_control.o
	#endif
#endif

#ifdef ENABLE_NEST
NEST_CC_FLAGS = -DENABLE_NEST -I NestIncludePath
NEST_OBJ = nest_client_pool.o nest_consistency_manager.o nest_speak.o nest_common.o nest_filetransfer.o nest_statistics.o
#endif

FILE_TABLE = -DFILE_TABLE -I ZIncludePath ${NEST_CC_FLAGS}
FILE_TABLE_OBJ = file_state.o condor_file.o condor_file_basic.o condor_file_local.o condor_file_remote.o condor_file_special.o condor_file_agent.o condor_file_buffer.o condor_file_fd.o condor_file_compress.o condor_file_append.o condor_file_nest.o file_table_interf.o

#if IS_IRIX
/* This silliness is because gcc 2.7.2 on IRIX cannot
 * handle really large switches and/or functions, like 
 * stub_gen wants to make for senders.C and receivers.C.
 * So these options will cluster the stubs so there are
 * only STUB_CLUMP_SIZE stubs per function/switch statement.
**/
STUB_CLUMPS_FLAG = -DUSE_STUB_CLUMPS
STUB_CLUMP_SIZE = -s 33
#endif

/* We need to use dlopen() and dlsym() to extract on IRIX */
#if IS_IRIX
DL_EXTRACT = -DDL_EXTRACT
#endif

OS = OperatingSystem

CFLAGS = $(STD_C_FLAGS) $(DL_EXTRACT) $(FILE_TABLE) $(REMOTE_SYSCALLS)

C_PLUS_FLAGS = $(STD_C_PLUS_FLAGS) $(STUB_CLUMPS_FLAG) $(DL_EXTRACT) \
	$(FILE_TABLE) $(REMOTE_SYSCALLS) $(SAVE_SIGSTATE) -I../condor_ckpt \
	-fno-exceptions -DHEADER_DES_LOCL_H

#if DOES_CHECKPOINTING  /* ========= DOES CHECKPOINTING ============ */

#if IS_LINUX
#if IS_GLIBC21 || IS_GLIBC22
FORK_OBJ = FORK.o
#elif IS_GLIBC20
FORK_OBJ = FORK.o VFORK.o
#else
FORK_OBJ = __FORK.o
#endif /* libc */
#endif /* LINUX */

#	if IS_HPUX
EXTRACT = FORK.o GETEUID.o GETPPID.o GETEGID.o SYSCALL.o __SYSCALL.o \
		  MMAP.o PIPE.o GETCWD.o GETLOGIN.o
#	elif IS_GLIBC_LINUX
EXTRACT = GETCWD.o MMAP.o SYSCALL.o GETEUID.o GETEGID.o GETPPID.o \
		$(FORK_OBJ) PIPE.o SIGACTION.o GETLOGIN.o SYSDEP.o SIGSUSPEND.o \
		TRUNCATE.o SIGACTION.o GETDIRENTRIES.o 
#	elif IS_I386_LINUX
EXTRACT = GETCWD.o MMAP.o SYSCALL.o __GETEUID.o __GETEGID.o __GETPPID.o \
		$(FORK_OBJ) __PIPE.o __SIGACT.o ____SIG.o GETLOGIN.o \
		__PREV_FSTAT.o __PREV_LSTAT.o __PREV_STAT.o SIGSUSPEND.o \
		TRUNCATE.o
#	elif IS_DUX
EXTRACT = FORK.o GETEUID.o GETPPID.o GETEGID.o GETCWD.o \
		  MMAP.o PIPE.o SYSCALL.o
#	elif IS_X86_SOLARIS251
EXTRACT = FORK.o SIGACTION.o GETEUID.o GETPPID.o GETEGID.o \
		  MMAP.o SYSCALL.o PIPE.o _SIGACTION.o TRUNCATE.o GETCWD.o \
		  i386_data.o SYSCONF.o GETLOGIN.o GETRUSAGE.o FSYNC.o \
		  GETPAGESIZE.o
#	elif IS_X86_SOLARIS26
EXTRACT = FORK.o SIGACTION.o GETEUID.o GETPPID.o GETEGID.o \
		  MMAP.o SYSCALL.o PIPE.o _SIGACTION.o TRUNCATE.o \
		  GETCWD.o GETRUSAGE.o\
		  i386_data.o SYSCONF.o GETLOGIN.o LSEEK64.o FSYNC.o \
		  GETPAGESIZE.o
#	elif IS_SUN4X_SOLARIS251
EXTRACT = FORK.o SIGACTION.o GETEUID.o GETPPID.o GETEGID.o \
		  MMAP.o SYSCALL.o PIPE.o _SIGACTION.o TRUNCATE.o GETCWD.o \
		  SYSCONF.o GETLOGIN.o GETRUSAGE.o FSYNC.o \
		  GETPAGESIZE.o
#	elif IS_SUN4X_SOLARIS26
EXTRACT = FORK.o SIGACTION.o GETEUID.o GETPPID.o GETEGID.o \
		  MMAP.o SYSCALL.o PIPE.o _SIGACTION.o TRUNCATE.o \
		  GETCWD.o GETRUSAGE.o \
		  SYSCONF.o GETLOGIN.o LSEEK64.o \
		  GETPAGESIZE.o
#	elif IS_SUN4X_SOLARIS27
EXTRACT = FORK.o SIGACTION.o GETEUID.o GETPPID.o GETEGID.o \
		  MMAP.o SYSCALL.o PIPE.o _SIGACTION.o TRUNCATE.o \
		  GETCWD.o GETRUSAGE.o \
		  SYSCONF.o GETLOGIN.o LSEEK64.o \
		  GETPAGESIZE.o
#	elif IS_X86_SOLARIS27
EXTRACT = FORK.o SIGACTION.o GETEUID.o GETPPID.o GETEGID.o \
		  MMAP.o SYSCALL.o PIPE.o _SIGACTION.o TRUNCATE.o \
		  GETCWD.o GETRUSAGE.o\
		  i386_data.o SYSCONF.o GETLOGIN.o LSEEK64.o FSYNC.o \
		  GETPAGESIZE.o
#	elif IS_SUN4X_SOLARIS28
EXTRACT = FORK.o SIGACTION.o GETEUID.o GETPPID.o GETEGID.o \
		  MMAP.o SYSCALL.o PIPE.o _SIGACTION.o TRUNCATE.o \
		  GETCWD.o GETRUSAGE.o \
		  SYSCONF.o GETLOGIN.o LSEEK64.o GETMNTENT.o TSDALLOC.o \
		  GETPAGESIZE.o
#	elif IS_IRIX
EXTRACT = /* don't extract anything */
#	else
EXTRACT = FORK.o SIGACTION.o GETEUID.o GETPPID.o GETEGID.o GETWD.o \
		  MMAP.o PIPE.o GETLOGIN.o SYSCALL.o
#	endif

#else	/* =============  DOES NOT DO CHECKPOINTING ============*/

#	if IS_HPUX || IS_SOLARIS
EXTRACT = GETEUID.o GETEGID.o
#	else 
EXTRACT = GETEUID.o GETEGID.o GETWD.o
#	endif

#endif	/* ===============  CHECKPOINTING CONDITIONAL ============*/

#if IS_HPUX
PLATFORM_UTIL_OBJ = seteuid.o setegid.o
#endif

#if IS_IRIX65
DEP_OS = IRIX65
#elif IS_IRIX62
DEP_OS = IRIX62
#elif IS_HPUX10
DEP_OS = HPUX10
#else
DEP_OS = OperatingSystem
#endif

#if IS_IRIX
SGI_CKPT = MMAP.MIPS.$(DEP_OS).o SYSCALL.MIPS.$(DEP_OS).o
#endif

#if !HAS_FLOCK
FLOCK_OBJ = flock.o
#endif

STUBS = switches.o switches.special.o getcwd.o

UTIL = \
	extern_path.o \
	remote_syscall.o \
	syscall_connect.o \
	senders.o \
	remote_startup.o \
	file_stream.o

NAME_TAB = syscall_numbers.o

SRC = \
	extern_path.c \
	receivers.epilogue \
	receivers.prologue \
	remote_startup.c \
	remote_syscall.C \
	senders.epilogue \
	senders.prologue \
	switches.prologue \
	switches.epilogue \
	switches.special.C \
	syscall.tmpl \
	syscall_connect.C \
	syscall_numbers.c \
	xfer_file.c \
	file_stream.c \
        ios_stub.C \
        ios_msg.C
	 
URL_OBJ = url_condor.o include_urls.o cbstp_url.o file_url.o http_url.o \
	cfilter_url.o filter_url.o mailto_url.o ftp_url.o

#if DOES_CHECKPOINTING
CKPT_OBJ = $(FILE_TABLE_OBJ)\
	image.o tmp_stack.o machdep.$(DEP_OS).o malloc-user.o \
	syscall_mode.o fake_hooks.o $(LONGJMP) $(HP_CKPT) \
	$(SGI_CKPT) $(SIG_CKPT_OBJS) eprintf.o shared_utils.o condor_error.o
#else
CKPT_OBJ = $(FILE_TABLE_OBJ) syscall_mode.o eprintf.o shared_utils.o condor_error.o
#endif

#if DOES_COMPRESS_CKPT
#if IS_SUN4X_SOLARIS
COMPRESS_OBJ = malloc-condor.o zimage.o _rem.o _div.o umultiply.o
#else
COMPRESS_OBJ = malloc-condor.o zimage.o
#endif
COMPRESS_LIB = libcondorzsyscall.a
#endif

SYSCALL_SUPPORT_OBJ=senders.o receivers.o syscall_mode.o syscall_connect.o remote_syscall.o syscall_numbers.o xfer_file.o

UTIL_OBJ =  $(FLOCK_OBJ) dprintf_common.o except.o update_rusage.o \
	internet.o $(PLATFORM_UTIL_OBJ) mkargv.o filename_tools.o

CPP_UTIL_OBJ = condor_version.o 

CONDOR_TYPE_OBJ = sig_num.o proc.o open_flags.o fcntl_cmd.o errno_num.o

IO_OBJ = stream.o sock.o safe_sock.o reli_sock.o buffers.o $(CONDOR_TYPE_OBJ) condor_rw.o SafeMsg.o

#if CONDOR_ENCRYPTION

#if CONDOR_3DES_ENCRYPTION
   CONDOR_DES_OBJ = condor_crypt_3des.o
#endif

#if CONDOR_BLOWFISH_ENCRYPTION
   CONDOR_BLOWFISH_OBJ = condor_crypt_blowfish.o
#endif /* CONDOR_BLOWFISH_ENCRYPTION */

#endif /* CONDOR_ENCRYPTION */

OPENSSL_OBJ = md5_dgst.o md5_one.o rand_lib.o md_rand.o sha1dgst.o cryptlib.o \
	buffer.o stack.o err.o lhash.o mem.o rand_win.o mem_dbg.o b_print.o \
	bio_lib.o bss_file.o ex_data.o

#if defined(CONDOR_ENCRYPTION) || defined(CONDOR_MD)
CONDOR_CRYPT_OBJ = CryptKey.o condor_crypt.o condor_md.o ../condor_util_lib/get_random_num.o \
	$(CONDOR_DES_OBJ) $(CONDOR_BLOWFISH_OBJ) $(OPENSSL_OBJ)
#else 
CONDOR_CRYPT_OBJ = CryptKey.o condor_crypt.o condor_md.o ../condor_util_lib/get_random_num.o \
	$(CONDOR_DES_OBJ) $(CONDOR_BLOWFISH_OBJ) 
#endif

SPECIAL_IO_OBJ = authentication.o $(CONDOR_CRYPT_OBJ)

SPECIAL_OBJ = special_stubs.o

LIB_OBJ = $(EXTRACT) $(STUBS) $(UTIL) $(NAME_TAB) $(XDR_OBJ) $(UTIL_OBJ) \
	$(CKPT_OBJ) $(UTIL_EXTRACT) $(IOS_STUBS) $(IO_OBJ) $(SPECIAL_IO_OBJ) \
	$(SPECIAL_OBJ) $(CPP_UTIL_OBJ) ${NEST_OBJ}

SIMPLE_OBJ = condor_rt0.o extern_path.o xfer_file.o libcondorc++support.a
SYSCALL_LIB = libcondorsyscall.a

#if DOES_REMOTE_SYSCALLS
all_target($(SYSCALL_LIB) $(COMPRESS_LIB) receivers.o $(SIMPLE_OBJ) $(AIX_OBJ) syscall-list libz.a )
#else 
all_target($(SYSCALL_SUPPORT_OBJ) extern_path.o file_stream.o)
#endif

stubs: switches.C senders.C receivers.C

ToUpper:
	ln -s ../condor_ckpt/ToUpper ToUpper

clean::
	rm -f ToUpper

uppercase_target($(SIMPLE_LIBC),geteuid.o,GETEUID.o,geteuid,GETEUID)
uppercase_target($(SIMPLE_LIBC),getppid.o,GETPPID.o,getppid,GETPPID)
uppercase_target($(SIMPLE_LIBC),getegid.o,GETEGID.o,getegid,GETEGID)
uppercase_target($(SIMPLE_LIBC),getlogin.o,GETLOGIN.o,getlogin,GETLOGIN)
uppercase_target($(SIMPLE_LIBC),fsync.o,FSYNC.o,fsync,FSYNC)

#if IS_X86_SOLARIS
SIGACTION.o : ToUpper $(SIMPLE_LIBC)
	ar x $(SIMPLE_LIBC) sigaction.o
	./ToUpper sigaction.o sigaction.tmp.o sigaction SIGACTION
	./ToUpper sigaction.tmp.o SIGACTION.o _siguhandler _SIGUHANDLER
	rm -f sigaction.tmp.o sigaction.o

clean::
	rm -f SIGACTION.o

#elif !IS_ALPHA_OSF1
uppercase_target($(SIMPLE_LIBC),sigaction.o,SIGACTION.o,sigaction,SIGACTION)
#endif

uppercase_target($(SIMPLE_LIBC),_sigaction.o,_SIGACTION.o,sigaction,SIGACTION)

#if IS_SOLARIS
TRUNCATE.o : ToUpper $(SIMPLE_LIBC)
	ar x $(SIMPLE_LIBC) truncate.o
	./ToUpper truncate.o truncate.tmp.o ftruncate FTRUNCATE
	./ToUpper truncate.tmp.o TRUNCATE.o truncate TRUNCATE
	rm -f truncate.tmp.o truncate.o

clean::
	rm -f TRUNCATE.o
#else
uppercase_target($(SIMPLE_LIBC),truncate.o,TRUNCATE.o,truncate,TRUNCATE)
#endif

#if  IS_DUX
/* do nothing */
#elif IS_GLIBC_LINUX && IS_GLIBC20
uppercase_target($(SIMPLE_LIBC),sigsuspend.o,SIGSUSPEND_TMP.o,sigsuspend,SIGSUSPEND)

SIGSUSPEND.o: SIGSUSPEND_TMP.o ToUpper
	./ToUpper SIGSUSPEND_TMP.o SIGSUSPEND.o __syscall_SIGSUSPEND __syscall_sigsuspend

clean::
	rm -f SIGSUSPEND_TMP.o
#else
uppercase_target($(SIMPLE_LIBC),sigsuspend.o,SIGSUSPEND.o,sigsuspend,SIGSUSPEND)
#endif
uppercase_target($(SIMPLE_LIBC),mmap.o,MMAP.o,mmap,MMAP)
uppercase_target($(SIMPLE_LIBC),pipe.o,PIPE.o,pipe,PIPE)
uppercase_target($(SIMPLE_LIBC),getdirentries.o,GETDIRENTRIES.o,getdirentries,GETDIRENTRIES)


uppercase_target($(SIMPLE_LIBC),__geteuid.o,__GETEUID.o,__geteuid,__GETEUID)
uppercase_target($(SIMPLE_LIBC),__getegid.o,__GETEGID.o,__getegid,__GETEGID)
uppercase_target($(SIMPLE_LIBC),__getppid.o,__GETPPID.o,__getppid,__GETPPID)
uppercase_target($(SIMPLE_LIBC),__sigact.o,__SIGACT.o,__sigaction,__SIGACTION)
uppercase_target($(SIMPLE_LIBC),__pipe.o,__PIPE.o,__pipe,__PIPE)

#if IS_SOLARIS28
/* I'm sorry about this mess. GETCWD.o now calls a bunch of things inside
	of getmntent.o which normally wouldn't be a problem... except for some
	reason libc.so declares getmntent functions as private, whereas libc.a
	declares them as global. So This means we may not link with them from the
	extracted GETCWD. So, *sigh* I must extract and rename the local functions
	from getmntent.o and fix up the sol 2.8 version of getcwd to reflect that
	I want to call my version of GETMNTENT. -pete 04-25-2000 */
GETCWD.o: ToUpper $(SIMPLE_LIBC)
	ar x $(SIMPLE_LIBC) getcwd.o
	./ToUpper getcwd.o getcwd2.o _getextmntent _GETEXTMNTENT
	./ToUpper getcwd2.o getcwd3.o _hasmntopt _HASMNTOPT
	./ToUpper getcwd3.o getcwd4.o _resetmnttab _RESETMNTTAB
	./ToUpper getcwd4.o GETCWD.o getcwd GETCWD
	rm -f getcwd.o getcwd2.o getcwd3.o getcwd4.o

GETMNTENT.o : ToUpper $(SIMPLE_LIBC)
	ar x $(SIMPLE_LIBC) getmntent.o
	./ToUpper getmntent.o getmntent2.o getextmntent GETEXTMNTENT
	./ToUpper getmntent2.o getmntent3.o getmntany GETMNTANY
	./ToUpper getmntent3.o getmntent4.o getmntent GETMNTENT
	./ToUpper getmntent4.o getmntent5.o hasmntopt HASMNTOPT
	./ToUpper getmntent5.o getmntent6.o resetmnttab RESETMNTTAB
	./ToUpper getmntent6.o getmntent7.o getline GETLINE
	./ToUpper getmntent7.o getmntent8.o _tsdbufalloc _TSDBUFALLOC
	./ToUpper getmntent8.o GETMNTENT.o mntopt MNTOPT
	rm -f getmntent.o getmntent2.o getmntent3.o getmntent4.o getmntent5.o getmntent6.o getmntent7.o

/* Grrr.... does it ever end? */
TSDALLOC.o: ToUpper $(SIMPLE_LIBC)
	ar x $(SIMPLE_LIBC) tsdalloc.o
	./ToUpper tsdalloc.o tsdalloc2.o _free_tsdbuf _FREE_TSDBUF
	./ToUpper tsdalloc2.o TSDALLOC.o _tsdbufalloc _TSDBUFALLOC
	rm -f tsdalloc.o tsdalloc2.o
#else
uppercase_target($(SIMPLE_LIBC),getcwd.o,GETCWD.o,getcwd,GETCWD)
#endif

uppercase_target($(SIMPLE_LIBC),getrusage.o,GETRUSAGE.o,getrusage,GETRUSAGE)

uppercase_target($(SIMPLE_LIBC),fork.o,FORK.o,fork,FORK)

#if IS_LINUX && ! IS_GLIBC
__FORK.o : ToUpper $(SIMPLE_LIBC)
	ar x $(SIMPLE_LIBC) __fork.o
	./ToUpper __fork.o __FORK_TMP.o vfork VFORK
	./ToUpper __FORK_TMP.o __FORK.o fork FORK
	rm -f __fork.o __FORK_TMP.o
#else
#	if IS_LINUX && IS_GLIBC22
		/* do nothing. there is no __fork object in glibc 22 */
#	else
		uppercase_target($(SIMPLE_LIBC),__fork.o,__FORK.o,__fork,__FORK)
#	endif
#endif

#if IS_LINUX && IS_GLIBC20
VFORK.o : ToUpper $(SIMPLE_LIBC)
	ar x $(SIMPLE_LIBC) vfork.o
	./ToUpper vfork.o VFORK_TMP.o vfork VFORK
	./ToUpper VFORK_TMP.o VFORK.o fork FORK
	rm -f vfork.o VFORK_TMP.o
#else
uppercase_target($(SIMPLE_LIBC),vfork.o,VFORK.o,fork,VFORK)
#endif

#if IS_SOLARIS26 || IS_SOLARIS27 || IS_SOLARIS28
uppercase_target($(SIMPLE_LIBC),lseek64.o,LSEEK64.o,lseek64,LSEEK64)
#endif


#if IS_I386_LINUX
____SIG.o : ToUpper $(SIMPLE_LIBC)
	ar x $(SIMPLE_LIBC) ____sig.o
	./ToUpper ____sig.o ____SIG_TMP.o ___sig_restore ___SIG_RESTORE
	./ToUpper ____SIG_TMP.o ____SIG.o ___masksig_restore ___MASKSIG_RESTORE
	rm -f ____sig.o ____SIG_TMP.o

uppercase_target($(SIMPLE_LIBC),__prev_stat.o,__PREV_STAT.o,stat,STAT)
uppercase_target($(SIMPLE_LIBC),__prev_lstat.o,__PREV_LSTAT.o,lstat,LSTAT)
uppercase_target($(SIMPLE_LIBC),__prev_fstat.o,__PREV_FSTAT.o,fstat,FSTAT)

#endif


#if IS_GLIBC_LINUX
uppercase_target($(SIMPLE_LIBC),syscall.o,SYSCALL_TMP.o,syscall,SYSCALL)
uppercase_target($(SIMPLE_LIBC),sysdep.o,SYSDEP_TMP.o,__syscall_error,__SYSCALL_ERROR)

SYSCALL.o: SYSCALL_TMP.o ToUpper
	./ToUpper SYSCALL_TMP.o SYSCALL.o __SYSCALL_error __syscall_error

SYSDEP_TMP2.o: SYSDEP_TMP.o ToUpper
	./ToUpper SYSDEP_TMP.o SYSDEP_TMP2.o errno ERRNO

SYSDEP.o: SYSDEP_TMP2.o ToUpper
	./ToUpper SYSDEP_TMP2.o SYSDEP.o __ERRNO_location __errno_location

clean::
	rm -f SYSCALL_TMP.o
#else
uppercase_target($(SIMPLE_LIBC),syscall.o,SYSCALL.o,syscall,SYSCALL)
uppercase_target($(SIMPLE_LIBC),__syscall.o,__SYSCALL.o,__syscall,__SYSCALL)
#endif

#if IS_X86_SOLARIS
i386_data.o : $(SIMPLE_LIBC)
	ar x $(SIMPLE_LIBC) i386_data.o
#endif

#if IS_SOLARIS
SYSCONF.o :  $(SIMPLE_LIBC)  ToUpper
	ar x    $(SIMPLE_LIBC)      sysconf.o 	  ; mv  sysconf.o  $(TMP_DIR)
	./ToUpper $(TMP_DIR)/sysconf.o   $(TMP_DIR)/SYSCONF.o   sysconf   SYSCONF
	./ToUpper $(TMP_DIR)/SYSCONF.o   SYSCONF.o SYSCONFig sysconfig
	rm -f $(TMP_DIR)/sysconf.o $(TMP_DIR)/SYSCONF.o
uppercase_target($(SIMPLE_LIBC),getpagesize.o,GETPAGESIZE.o,getpagesize,GETPAGESIZE)
#endif

#if DOES_CHECKPOINTING || DOES_REMOTE_SYSCALLS
release_copy_target(condor_rt0.o,$(RELEASE_DIR)/lib,condor_rt0.o,OBJECT_MODE)
strip_copy_target(condor_rt0.o,$(STRIP_DIR)/lib,condor_rt0.o,OBJECT_MODE)
static_copy_target(condor_rt0.o,$(STATIC_DIR)/lib,condor_rt0.o,OBJECT_MODE)
#endif

#if IS_X86_SOLARIS || IS_GLIBC_LINUX
	library_target(libtmp.a,$(LIB_OBJ))

clean::
	rm -f libcondorsyscall.a

libcondorsyscall.a: libtmp.a ToUpper
#   if (IS_X86_SOLARIS)
	./ToUpper libtmp.a libcondorsyscall.a __cerror __CERROR
#   else /* GLIBC Linux */
	./ToUpper libtmp.a libcondorsyscall.a __syscall_error __SYSCALL_ERROR
#   endif /* Solaris */
#else /* Not GLIBC Linux or Intel Solaris */
	library_target(libcondorsyscall.a,$(LIB_OBJ))
#endif

#if DOES_CHECKPOINTING || DOES_REMOTE_SYSCALLS
release_library(libcondorsyscall.a,$(RELEASE_DIR)/lib)
strip_library(libcondorsyscall.a,$(STRIP_DIR)/lib)
static_library(libcondorsyscall.a,$(STATIC_DIR)/lib)
#endif

#if DOES_CHECKPOINTING || DOES_REMOTE_SYSCALLS
release_library(libz.a, $(RELEASE_DIR)/lib)
strip_library(libz.a, $(STRIP_DIR)/lib)
static_library(libz.a, $(STATIC_DIR)/lib)
#endif

#if DOES_COMPRESS_CKPT
release_library($(COMPRESS_LIB),$(RELEASE_DIR)/lib)
strip_library($(COMPRESS_LIB),$(STRIP_DIR)/lib)
static_library($(COMPRESS_LIB),$(STATIC_DIR)/lib)
#endif

CMNT If no remote syscalls & no checkpointing support, then no need
CMNT to release anything into RELEASEDIR/lib, since we only do VANILLA jobs
#if (!DOES_CHECKPOINTING) && (!DOES_REMOTE_SYSCALLS)
release:: all
stripped:: all
static:: all
#endif

CPP = PreProcessCmd

#if IS_I386_LINUX
STUB_GEN_PLATFORM = GlibCFlag
#elif IS_SOLARIS251
STUB_GEN_PLATFORM = -DSolaris251
#elif IS_SOLARIS26
STUB_GEN_PLATFORM = -DSolaris26
#elif IS_SOLARIS27
STUB_GEN_PLATFORM = -DSolaris27
#elif IS_SOLARIS28
STUB_GEN_PLATFORM = -DSolaris28
#elif IS_HPUX10
STUB_GEN_PLATFORM = -DHPUX10
#elif IS_IRIX62
STUB_GEN_PLATFORM = -DIRIX62
#elif IS_IRIX65
STUB_GEN_PLATFORM = -DIRIX65
#endif

STUB_GEN_FLAGS = $(STUB_GEN_PLATFORM) $(DL_EXTRACT) -D$(OS) \
	$(SAVE_SIGSTATE) $(FILE_TABLE) $(REMOTE_SYSCALLS) $(CLIP) \
	$(HAS_64BIT_SYSCALLS) $(HAS_64BIT_STRUCTS) -Wall

switches.C: syscall.tmpl switches.prologue stub_gen switches.epilogue
	$(CPP) -DSWITCH $(STUB_GEN_FLAGS) -I../condor_includes syscall.tmpl | \
	./stub_gen -mode switches  -p switches.prologue -e switches.epilogue \
	> switches.C

senders.C: syscall.tmpl stub_gen senders.prologue senders.epilogue
	$(CPP) -DSENDER $(STUB_GEN_FLAGS) -I../condor_includes syscall.tmpl | \
	./stub_gen -mode senders -p senders.prologue -e senders.epilogue \
	$(STUB_CLUMP_SIZE) > senders.C

receivers.C: syscall.tmpl stub_gen receivers.prologue receivers.epilogue pseudo_ops.h
	$(CPP) -DRECEIVER $(STUB_GEN_FLAGS) -I../condor_includes syscall.tmpl | \
	./stub_gen -mode receivers -p receivers.prologue \
	-e receivers.epilogue -n syscheck $(STUB_CLUMP_SIZE) > receivers.C

syscall-list: syscall.tmpl stub_gen 
	$(CPP) -DSWITCH $(STUB_GEN_FLAGS) -I../condor_includes syscall.tmpl | \
	./stub_gen -mode listcalls > syscall-list

clean::
	rm -f syscall-list

clean::
	rm -f lex.yy.c y.tab.c y.tab.h switches.C senders.C receivers.C *.o

/*depend_target($(SRC)) */

IMPORT_LINKS = ../../config/import_links
import(../condor_io,$(IO_OBJ))
import(../condor_util_lib,$(UTIL_OBJ))
import(../condor_c++_util,$(CPP_UTIL_OBJ))
import(../condor_ckpt,condor_rt0.o)
import(../condor_ckpt,$(CKPT_OBJ))
import(../condor_ckpt,$(COMPRESS_OBJ))
import(../h,syscall_numbers.c)
import(../condor_util_lib, stub_gen)
import(../condor_shadow.V6, pseudo_ops.h)
import(../condor_ckpt,libcondorc++support.a)
import( ZLibPath , libz.a )

authentication.o: ../condor_io/authentication.C
	$(CPlusPlus) $(C_PLUS_FLAGS) -I../condor_io \
		-DSKIP_AUTHENTICATION -c ../condor_io/authentication.C

condor_md.o: ../condor_c++_util/condor_md.C
	$(CPlusPlus) $(C_PLUS_FLAGS) -I../condor_c++_util \
	        -DSKIP_AUTHENTICATION -c ../condor_c++_util/condor_md.C

condor_crypt_3des.o: ../condor_io/condor_crypt_3des.C
	$(CPlusPlus) $(C_PLUS_FLAGS) -I../condor_io \
		-DSKIP_AUTHENTICATION -c ../condor_io/condor_crypt_3des.C

condor_crypt_blowfish.o: ../condor_io/condor_crypt_blowfish.C
	$(CPlusPlus) $(C_PLUS_FLAGS) -I../condor_io \
		-DSKIP_AUTHENTICATION -c ../condor_io/condor_crypt_blowfish.C

CryptKey.o: ../condor_io/CryptKey.C
	$(CPlusPlus) $(C_PLUS_FLAGS) -I../condor_io \
		-DSKIP_AUTHENTICATION -c ../condor_io/CryptKey.C

condor_crypt.o: ../condor_io/condor_crypt.C
	$(CPlusPlus) $(C_PLUS_FLAGS) -I../condor_io \
		-DSKIP_AUTHENTICATION -c ../condor_io/condor_crypt.C

#if DOES_COMPRESS_CKPT
$(COMPRESS_LIB) : $(SYSCALL_LIB) $(COMPRESS_OBJ)
	cp $(SYSCALL_LIB) $(COMPRESS_LIB)
	ar -d $(COMPRESS_LIB) image.o
	ar -r $(COMPRESS_LIB) $(COMPRESS_OBJ)
clean::
	rm -f $(COMPRESS_LIB) $(COMPRESS_OBJ)
#endif

#ifdef ENABLE_NEST
${NEST_OBJ}::
	ar xv concat(NestLibPath,/libnest-client.a) $@
clean::
	rm -rf ${NEST_OBJ}
#endif

html:

DEPEND_SRC = C_getenv.c extern_path.c file_stream.c getcwd.c remote_startup.c \
remote_syscall.C switches.special.C syscall_connect.C xfer_file.c

depend_source_target($(DEPEND_SRC))

#if CONDOR_ENCRYPTION
obj_extract( $(OPENSSL_MD_LIB), $(OPENSSL_OBJ) )
#endif
