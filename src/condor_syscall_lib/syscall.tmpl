/*
  How to read this file:

  This file is used to generate 3 C++ language files -  "switches.C",
  "senders.C", and "receivers.C".  Not all of the information contained
  here is needed in every case.

  Switches are functions which are linked in with the user's code, and
  have the same names as the system call they are intended to invoke.
  The switch will determine whether the call should be done locally or
  remotely, and will invoke an appropriate mechanism to accomplish
  that.  In the case of local execution, that will most often be the
  syscall() routine.  In the case of remote calls, that will always be
  the REMOTE_syscall() routine.  The syscall() routine is generally
  provided in the C library, and REMOTE_syscall() is provided by
  Condor.  More on this in the next paragraph...

  Senders are the part of the code which packages up the arguments of a
  system call, sends them to the shadow for remote execution, and then
  package up the results so it looks to the calling routine as though
  the normal system call were done.  The REMOTE_syscall() routine is
  organized as a giant switch() statement, with one "case" for each
  system call.  Each case is called a "sender".

  Receivers are the part of the code which runs on the submitting
  machine that matches with the sender.  The receiver reads all the
  arguments to the system call, performs the call, then sends back the
  results.  We plan to eventually generate the recievers from this
  template file, but the current code doesn't do it.

  The general format of this file is a function prototype for every
  system call.  Those give the system call return type, the name, and
  the names and types of each of the system call arguments.  The system
  call prototypes have been augmented with other information needed to
  generate correct switches, senders, and receivers.  Each type of
  augmenting information is described here:

  : extract
	  Some system calls cannot be successfully executed by the syscall()
	  routine.  This is generally becuase syscall() expects that every
	  system call will pass its return value through register 0.  A few
	  system calls like getuid() will actually return 2 values, the
	  real uid in register 0, and the effective uid in register 1.  In
	  that case, there is no system call geteuid() - that information is
	  gotten as a side effect of the getuid() system call.  For this
	  reason geteuid() doesn't work with syscall().  In such a case
	  another means must be found to execute the offending system call.
	  We extract from the C library a copy of whatever the normal system
	  call stub is, and change the name by making it all upper case.
	  For example geteuid() becomes GETEUID().  The switch generator must
	  know that geteuid() has to be handled specially in the local case,
	  which is the meaning of "extract".

  : dl_extract
	  This is similar to extract above except it uses dlopen() and
	  dlsym() to find the appropriate versions of the calls in
	  /usr/lib/libc.so.

  : no_sys_chk
	  By default, a test for defined(SYS_name) is wrapped around
	  all non-pseudo calls in senders and receivers.  If a call is
	  marked with no_sys_chk, this test is omitted.  This is useful
	  for calls which are not system calls on a specific platform
	  but must still be supported by remote system calls for
	  cross platform interoperability.

  in code_bytes_bool( buf, len );
	  A statement like this appears with the prototype for the
	  write() system call.  Note that the parameter "buf" is a
	  pointer to void, and it is not immediately obvious whether
	  data should be sent to the remote system call receiver,
	  whether data should be sent back, or both.  Also, "buf" tells
	  us where the data starts, but it is not obvious (from the
	  syntax), how much data should be sent.  This statement tells
	  us that data should be sent to the remote system call
	  receiver by the keyword "in".  If you think of the system
	  call as simply a function, then "buf" is an "in" parameter to
	  the write() function.  "code_bytes( buf, len )" is the
	  routine and arguments which should be used to transfer
	  the data.  A similar statement appears with the prototype for
	  read(), but in this case the keyword "out" indicates that
	  (from the point of view of the read() system call), "buf" is
	  an out parameter, i.e. data must be sent from the system call
	  receiver to the sender.  In cases where data needs to travel
	  in both directions, both an "in" and an "out" statement would
	  appear.

	  NOTE: we need to use code_bytes_bool() here to get the
	  assert-safe functionality we want: 0 on failure, 1 on
	  success.  code_bytes() itself just returns the number of
	  bytes read or written, and -1 on failure. 

	map()

	Some system calls simply must be handled specially.  Examples
	are those system calls which directly affect the open files
	table used for checkpoint/restart.  Unfortunately, this
	"specialness" dosen't necessarily span all three pieces of code
	we want to generate.  For example, the switch for open() must
	be special because it affects the open files table, but the
	sender and receiver for open() don't need any special
	treatment.  We would therefore like to include a prototype for
	open(), but we must somehow tell the switch generator that it
	should not generate anything for open().  We solve the problem
	by running this file through the C preprocessor (cpp) before
	processing it.  The switch generator will ensure that the macro
	SWITCH is defined, the sender generator will instead define the
	macro SENDER, and similarly the reveiver generator will define
	the macro RECEIVER.  We then use cpp conditional statements to
	ensure that each generator sees only the prototypes for which it
	should generate code.
*/

	/* Use 32 bits for file mode (mode_t) everywhere - hope nobody wants more */
#if !defined(MODE_T)
#	if defined(AIX32)
#		define MODE_T ulong_t
#	elif defined(Solaris)
#		define MODE_T unsigned long
#	else
#		define MODE_T unsigned int
#	endif
#endif

/*	OSF/1 has some what different prototypes for many system calls.
	These try to set things up so we don't have to have so many
	if defined()'s below.  I'm afraid other new platforms may require
	similar changes.
*/

#if defined(OSF1)
#define SYSCALL_PTR	void
#define INV_SYSCALL_PTR	char
#define ALPHA_CONST	const
#else
#define SYSCALL_PTR	char
#define INV_SYSCALL_PTR	void
#define ALPHA_CONST
#endif

#define SEND_PATH(name) in code(name)
#define GET_PATH(name) out code(name)

/* on IRIX, we always want to dl_extract */
#if defined(IRIX53)
#define EXTRACT dl_extract
#else
#define EXTRACT extract
#endif

#define ALLOC_PATH(name) alloc(name,_POSIX_PATH_MAX)

#if !defined (SWITCH) && !defined(CLIP)
		/*
		These calls must interact closely with the open files table,
		therefore their switches are implemented in "condor_ckpt/file_state.C",
		but we still need to generate senders and receivers for them here.
		*/
	int open( const char *path, open_flags_t flags, int mode ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}
	int close( int fd );
	int dup( int old_fd );
	int dup2( int old_fd, int new_fd );
	int socket( int addr_family, int type, int protocol );
	int fchdir( map(int fd) );
	int chdir( const char *path ) : pseudo {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}

#if !defined(AIX32)
	/*
	This is not a syscall in AIX.  The library routine will exercise the
	kfcntl() routine which we handle.
	*/
	int fcntl( int fd, int req, int arg );
#endif

#if defined( BufferCondorIO )
	off_t lseek( map(int fd), off_t offset, int whence ); 
	ssize_t read( map(int fd), void *buf, size_t len ) {
		out code_bytes_bool( &buf, &rval, len );
		alloc( buf, len );
	}
	
        ssize_t write( map(int fd), const void *buf, size_t len ) {
		in code_bytes_bool( &buf, &len, len );
		alloc( buf, len );
	}

	int lseekread( map(int fd), off_t offset, int whence, void *buf, size_t len ) : pseudo {
		out code_bytes_bool( &buf, &rval, len );
		alloc( buf, len );
	}

        int lseekwrite( map(int fd), off_t offset, int whence, const void *buf, size_t len ) : pseudo {
		in code_bytes_bool( &buf, &len, len );
		alloc( buf, len );
        }
#endif

#ifdef CARMI_OPS

#define RequestId int
#define ResponseTag int
#define HostId int
#define ProcessId int
#define ResourceClass char* /* for the time being */

	int carmi_cancel_request(RequestId id, ResponseTag resp_tag) : pseudo; 

	int carmi_config( ResponseTag resp_tag)	: pseudo; 

	int carmi_get_class_ad(HostId id, ResponseTag resp_tag) : pseudo; 

	int carmi_addhosts(char *class_name, int count, ResponseTag resp_tag) 
		: pseudo {
		SEND_PATH( class_name );
		ALLOC_PATH( class_name );
	}

	int carmi_delhosts(int count, HostId* hosts, ResponseTag resp_tag) 
		:pseudo {
		in code_bytes_bool( hosts, count*sizeof(HostId) );
		alloc( hosts, count*sizeof(HostId) );
	}	

	int carmi_add_notify(char *class_name, ResponseTag resp_tag) :pseudo{
		SEND_PATH( class_name );
		ALLOC_PATH( class_name );
	}

	int carmi_delete_notify(int count, HostId *host_ids, 
                                ResponseTag resp_tag): pseudo {
		in code_bytes_bool( host_ids, count*sizeof(HostId) );
		alloc( host_ids, count*sizeof(HostId) );
	}

	int carmi_suspend_notify(int count, HostId *host_ids,
                                 ResponseTag resp_tag) : pseudo {
		in code_bytes_bool( host_ids, count*sizeof(HostId) );
		alloc( host_ids, count*sizeof(HostId) );
	}

	int carmi_resume_notify(int count, HostId *host_ids,
			ResponseTag resp_tag)  : pseudo{
		in code_bytes_bool( host_ids, count*sizeof(HostId) );
		alloc( host_ids, count*sizeof(HostId) );
	}

	int carmi_class_spawn(char *executable, char* argv[], char *class_name,
		  ResponseTag resp_tag) : pseudo {
		SEND_PATH( executable );
		ALLOC_PATH( executable );
		SEND_PATH( class_name );
		ALLOC_PATH( class_name );
	}

	int carmi_process_info( ResponseTag resp_tag) : pseudo; 

	int carmi_class_definitions( ResponseTag resp_tag) : pseudo; 

	int carmi_define_class( rcclass resc_class, 
				ResponseTag resp_tag) : pseudo {
	}

	int carmi_remove_class( char *class_name, 
                                ResponseTag resp_tag) : pseudo{
		SEND_PATH( class_name );
		ALLOC_PATH( class_name );
	}

	int carmi_ckpt(int ckpt_cnt, ProcessId *ckpt_list, 
	   int consistent_cnt, ProcessId *consistent_list, int flush_cnt, 
	   ProcessId *flush_list, HostId id) : pseudo{

		in code_bytes_bool( ckpt_list, ckpt_cnt*sizeof(ProcessId) );
		alloc( ckpt_list, ckpt_cnt*sizeof(ProcessId) );

		in code_bytes_bool( consistent_list, consistent_cnt*sizeof(ProcessId) );
		alloc( consistent_list, consistent_cnt*sizeof(ProcessId) );

		in code_bytes_bool( flush_list, flush_cnt*sizeof(ProcessId) );
		alloc( flush_list, flush_cnt*sizeof(ProcessId) );

	}

	int carmi_restart(int restart_cnt, ProcessId *restart_list, 
	  int consistent_cnt, ProcessId *consistent_list): pseudo {

		in code_bytes_bool( restart_list, restart_cnt*sizeof(ProcessId) );
		alloc( restart_list, restart_cnt*sizeof(ProcessId) );

		in code_bytes_bool( consistent_list, consistent_cnt*sizeof(ProcessId) );
		alloc( consistent_list, consistent_cnt*sizeof(ProcessId) );

	}

	int carmi_migrate(ProcessId target, HostId host, int
	  consistent_cnt, ProcessId *consistent_list): pseudo {

		in code_bytes_bool( consistent_list, consistent_cnt*sizeof(ProcessId) );
		alloc( consistent_list, consistent_cnt*sizeof(ProcessId) );

	}
#endif /* CARMI_OPS */

#endif	/* not SWITCH and not CLIP */

#if !defined(SWITCH)
/* No switches for pseudo_syscalls */
	int register_afs_cell( const char *cell ) : pseudo {
		SEND_PATH( cell );
		ALLOC_PATH( cell );
	}
	int register_fs_domain( const char *domain ) : pseudo {
		SEND_PATH( domain );
		ALLOC_PATH( domain );
	}
	int register_uid_domain( const char *domain ) : pseudo {
		SEND_PATH( domain );
		ALLOC_PATH( domain );
	}
#endif

#if !defined( CLIP )
	int link( const char *p1, const char *p2 ) {
		SEND_PATH( p1 );
		SEND_PATH( p2 );
		ALLOC_PATH( p1 );
		ALLOC_PATH( p2 );
	}

#	if defined(AIX32) && defined(SWITCH)
		/*
			not syscalls in aix, so don't build the switches
		*/
#	else
		/*
			build senders and recievers for everybody, and switches for
			everybody but AIX
		*/
#if !defined( BufferCondorIO )
		ssize_t write( map(int fd), const void *buf, size_t len ) {
			in code_bytes_bool( buf, len );
			alloc( buf, len );
		}

		ssize_t read( map(int fd), void *buf, size_t len ) {
			out code_bytes_bool( buf, rval );
			alloc( buf, len );
		} 
#endif
#	endif

#if !defined( BufferCondorIO )
	off_t lseek( map(int fd), off_t offset, int whence );
#endif
	int access( const char *path, int access_mode ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}
#if defined(LINUX) 
	int sync();
#else
	void sync();
#endif

		/*
		These get special treatment by the shadow, but should work normally
		in local mode.
		*/
#	if defined(AIX32)
		pid_t getppid() : pseudo;
#	else
#	if defined(IRIX53)
		pid_t getppid() : dl_extract, pseudo;
#	else
		pid_t getppid() : extract, pseudo;
#	endif
		uid_t getuid()  : pseudo;
		gid_t getgid()  : pseudo;
#	endif
	pid_t getpid()  : pseudo;
	
	/*
	getlogin() returns a pointer to a static buffer - our generator is not
	quite yet sophisticated enough to generate correct stubs for this.
	So we have a special switch for it in switches.special.c that
	allocates the static space for it.
	Furthermore, we make it pseudo cuz we want the shadow to return the
	job's Owner as the value.  -Todd , 4/97
	*/
#if !defined(SWITCH)
	int getlogin( char *loginbuf ) : pseudo {
		out code( loginbuf );
		alloc ( loginbuf, _POSIX_PATH_MAX );
	}  
#endif  /* not SWITCH for getlogin() */

#endif /* not CLIP */

	/*
	  These are used by the condor_starter, and thus get generated even in
	  the "clipped" version.
	*/

#if !defined(AIX32) && !defined(Solaris)
#	if defined(IRIX53)
	uid_t geteuid() : dl_extract, pseudo;
	gid_t getegid() : dl_extract, pseudo;
	char * getwd( char *path_name ) : pseudo, dl_extract {
		GET_PATH( path_name );
		ALLOC_PATH( path_name );
	}
#	else
	uid_t geteuid() : extract, pseudo;
	gid_t getegid() : extract, pseudo;
	char * getwd( char *path_name ) : pseudo, extract {
		GET_PATH( path_name );
		ALLOC_PATH( path_name );
	}
#	endif
#endif
int unlink( const char *path ) {
	SEND_PATH( path );
	ALLOC_PATH( path );
}
int rename( const char *from, const char *to ) : pseudo {
	SEND_PATH( from );
	SEND_PATH( to );
	ALLOC_PATH( from );
	ALLOC_PATH( to );
}

#if !defined( SWITCH )
		/*
		These are speical operations performed by the shadow, but have
		no meaning in local mode.  Since they are special Condor operations,
		they are generally used by Condor daemons, not user programs.  Thus,
		they should be built in the special "clipped" version.
		*/
	int get_universe( int *univ_id ) : pseudo {
	    out code( univ_id );
	    alloc( univ_id, INT_SIZE );
	}

	int get_username( char *uname ) : pseudo {
	    GET_PATH( uname );
	    ALLOC_PATH( uname );
	}
	
	int get_IOServerAddr( int *reqtype, const char *filename, char *host, int *port ) : pseudo {
	    in code( reqtype );
	    SEND_PATH( filename );
	    in code( host );
	    in code( port );

	    GET_PATH( host );
	    out code( port );

	    ALLOC_PATH( host );
	    ALLOC_PATH( filename );
	    alloc( port, INT_SIZE );
	    alloc( reqtype, INT_SIZE );
	}

	int extern_name( const char *path, char *buf, int bufsize ) : pseudo {
		SEND_PATH( path );
		ALLOC_PATH( path );
		out code_bytes_bool( buf, bufsize );
		alloc( buf, bufsize );
	}
	int free_fs_blocks( const char *pathname ) : pseudo {
		SEND_PATH( pathname );
		ALLOC_PATH( pathname );
	}
	int reallyexit( int *status, struct rusage *use_p ) : pseudo {
		in code( status );
		alloc( status, INT_SIZE );
		in code( use_p );
		alloc( use_p, RUSAGE_SIZE );
		return( NEG_ONE );
	}
	int subproc_status(int id,int *status,struct rusage *use_p) : pseudo {
		in code( status );
		alloc( status, INT_SIZE );
		in code( use_p );
		alloc( use_p, RUSAGE_SIZE );
		return( NEG_ONE );
	}
	int image_size( int kbytes ) : pseudo;
	int send_rusage( struct rusage *use_p ) : pseudo {
		in code( use_p );
		alloc( use_p, RUSAGE_SIZE );
	}
	int perm_error( const char *msg ) : pseudo {
		in code( msg );
		alloc( msg, MAX_STRING );
	}
	int work_request( PROC *p, char *a_out, char *targ, char *orig, int *kill_sig ): pseudo {
		out code( p );
		alloc( p, PROC_SIZE );
		GET_PATH( a_out );
		ALLOC_PATH( a_out );
		GET_PATH( targ );
		ALLOC_PATH( targ );
		GET_PATH( orig );
		ALLOC_PATH( orig );
		out signal( kill_sig );
		alloc( kill_sig, INT_SIZE );
	}
	int startup_info_request( STARTUP_INFO *s ): pseudo {
		out code( s );
		alloc( s, STARTUP_INFO_SIZE );
	}
	int std_file_info( int which, char *name, int *pipe_fd ) : pseudo {
		GET_PATH( name );
		ALLOC_PATH( name );
		out code( pipe_fd );
		alloc( pipe_fd, INT_SIZE );
	}
	int file_info( const char *name, int *pipe_fd, char *extern_path ): pseudo {
		SEND_PATH( name );
		ALLOC_PATH( name );
		GET_PATH( extern_path );
		ALLOC_PATH( extern_path );
		out code( pipe_fd );
		alloc( pipe_fd, INT_SIZE );
	}
	int get_iwd( char *path ) : pseudo {
		GET_PATH( path );
		ALLOC_PATH( path );
	}

	int get_ckpt_name( char *path ) : pseudo {
		GET_PATH( path );
		ALLOC_PATH( path );
	}

	int get_a_out_name( char *path ) : pseudo {
		GET_PATH( path );
		ALLOC_PATH( path );
	}


#if !defined (SWITCH)
	int pvm_info( const char *response, int mytid ) : pseudo {
		SEND_PATH( response );
		ALLOC_PATH( response );
	}

    int pvm_task_info( int v_pid, int pvm_tid) : pseudo;

    int suspended( int susp ) : pseudo;
#endif
		/*
		This function is intended for setting up the transfer
		of a whole file via a TCP stream.  This allows more
		flexibility than the similar get_file() protocol, and may
		be more efficient as well, since we bypass XDR.  The name
		of the file is the single parameter sent to the shadow, and
		the result is the length of the file, a hostname, and a port
		number from which the actual bytes can be read.
		*/
	int get_file_stream( const char *file, size_t *len, unsigned int *ip_addr,
		u_short *port_num ): pseudo {

		SEND_PATH( file );
		ALLOC_PATH( file );

		out code( len );
		alloc( len, SIZE_T_SIZE );

		out code( ip_addr );
		alloc( ip_addr, U_INT_SIZE );

		out code( port_num );
		alloc( port_num, U_SHORT_SIZE );
	}

		/*
		This function is intended for setting up the transfer
		of a whole file via a TCP stream.  This allows more
		flexibility than the similar put_file() protocol, and may
		be more efficient as well, since we bypass XDR.  The name
		of the file is the single parameter sent to the shadow, and
		the result is a hostname and a port number to which the
		actual bytes can be written.
		*/
	int put_file_stream( const char *file, size_t len,
						unsigned int *ip_addr, u_short *port_num ): pseudo {

		SEND_PATH( file );
		ALLOC_PATH( file );

		out code( ip_addr );
		alloc( ip_addr, U_INT_SIZE );

		out code( port_num );
		alloc( port_num, U_SHORT_SIZE );
	}

#	if !defined( SENDER )
		/*
		These two functions implement protocols for sending and fetching
		whole files at a time.  Since there is a more complex protocol
		involved, it's easier to just code the senders by hand.
		They are implemented in "senders.epilogue".
		*/
	int send_file( const char *name, MODE_T mode ) : pseudo {
		SEND_PATH( name );
		ALLOC_PATH( name );
	}
	int get_file( const char *name ) : pseudo {
		SEND_PATH( name );
		ALLOC_PATH( name );
	}
#	endif	/* not SENDER */
#endif	/* not SWITCH */


#if !defined( CLIP )

#	if !defined(AIX32)

#if defined(LINUX)
	int fstat( map(int fd), struct stat *buf ) : extract, no_sys_chk ;
#else
#  if defined(IRIX53)
	int fstat( map(int fd), struct stat *buf ) : no_sys_chk {
#  else
	int fstat( map(int fd), struct stat *buf ) {
#  endif
			out code( buf );
			alloc( buf, STAT_SIZE );
		}
#endif /* defined(LINUX) */


#if defined(LINUX)
    int stat( const char *path, struct stat *buf ) : extract, no_sys_chk ;
#else
    int stat( const char *path, struct stat *buf ) {
			SEND_PATH( path );
			ALLOC_PATH( path );
			out code( buf );
			alloc( buf, STAT_SIZE );
		}
#endif /* defined(LINUX) */

#if defined(LINUX)
    int lstat( const char *path, struct stat *buf ) : extract, no_sys_chk ;
#else
    int lstat( const char *path, struct stat *buf ) {
			SEND_PATH( path );
			ALLOC_PATH( path );
			out code( buf );
			alloc( buf, STAT_SIZE );
		}
#endif /* defined(LINUX) */

#endif  /* !defined(AIX32) */


#if defined(LINUX)
	int mknod( const char *path, mode_t mode, dev_t device ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}
#else
	int mknod( const char *path, int mode, dev_t device ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}
#endif /* defined(LINUX) */
	int chmod( const char *path, MODE_T mode ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}
#	if !defined(SUNOS41) && !defined(ULTRIX43)
		int getfsstat( struct statfs buf[], long bufsize, int flags ) {
			out code_bytes_bool( buf, STATFS_ARRAY_SIZE );
			alloc( buf, bufsize );
		}
#	endif
	int flock( map(int fd), int op );
#if defined(Solaris)
not_supported{
	int fstatfs( map(int fd), struct statfs *buf ) {
		out code( buf );
		alloc( buf, STATFS_SIZE );
	}
	}
#else 
#if defined(IRIX53)
	int fstatfs( map(int fd), struct statfs *buf, int len, int fstyp ) {
#else
	int fstatfs( map(int fd), struct statfs *buf ) {
#endif
	out code( buf );
	alloc( buf, STATFS_SIZE );
	}
#endif

	int fsync( map(int fd) );

	int symlink( const char *path1, const char *path2 ) {
		SEND_PATH( path1 );
		SEND_PATH( path2 );
		ALLOC_PATH( path1 );
		ALLOC_PATH( path2 );
	}

#if defined(LINUX)
	int readlink( const char *path, char *buf, size_t buf_size ) {
#elif defined(OSF1) || defined(AIX32)
	int readlink( const char *path, char *buf, int buf_size ) {
#else
	int readlink( const char *path, void *buf, int buf_size ) {
#endif
	SEND_PATH( path );
    ALLOC_PATH( path );
    out code_bytes_bool( buf, buf_size );
    alloc( buf, buf_size );
    }

	pid_t getpgrp();
	MODE_T umask( MODE_T cmask );
	int getpagesize();

	int getgroups( int gidsetsize, gid_t grouplist[] ) {
		out code_bytes_bool( grouplist, gidsetsize * GID_T_SIZE );
		alloc( grouplist, gidsetsize * GID_T_SIZE );
	}
#if	defined(HPUX9)
	int	setpgrp();
#elif	defined(OSF1)
	pid_t setpgrp();
#else
	int setpgrp( int pid, int pgrp );
#endif
#	if defined(SUNOS41)
		int getdents( map(int fd), char *buf, int nbytes ) {
			out code_bytes_bool( buf, nbytes );
			alloc( buf, nbytes );
		}
#	else
		int getdirentries( map(int fd), char *buf, int nbytes, long *basep ) {
			out code_bytes_bool( buf, rval );
			in code_bytes_bool( basep, EIGHT );
			out code_bytes_bool( basep, EIGHT );
			alloc( buf, nbytes );
			alloc( basep, LONG_SIZE );
		}
#	endif
	int table( int id, int index, char *addr, int nel, unsigned int lel ) {
		out code_bytes_bool( addr, nel * lel );
		alloc( addr, nel * lel );
	}

	int gethostname( char *address, int address_len ) {
		out code_bytes_bool( address, address_len );
		alloc( address, address_len );
	}
	int getdtablesize();

	not_supported {
#if defined(LINUX) || defined(OSF1) || defined(IRIX62)
		int select(int numfds, fd_set *readfds, fd_set *writefds,
			fd_set *exceptfds, struct timeval *timeout);
#else
		int select();
#endif
		int poll();
	}

#if !defined(SWITCH) /* moved into separate .c file to avoid a name conflict */
	int setpriority( int which, int who, int priority );
#endif
	int getpriority( int which, int who );
#if defined(OSF1) || (defined(HPUX9) && !defined(HPUX10)) || defined(LINUX)
	int gettimeofday( struct timeval *tp, struct timezone *tzp ) {
		out code( tp );
		out code( tzp );
#else
	int gettimeofday( struct timeval *tp, void *tzp ) {
		out code( tp );
		out code_bytes_bool( tzp, TIMEZONE_SIZE );
#endif
		alloc( tp, TIMEVAL_SIZE );
		alloc( tzp, TIMEZONE_SIZE );
	}
	int fchown( map(int fd), uid_t owner, gid_t group );
#	if !defined(AIX32)
		int lchown( const char *path, uid_t owner, gid_t group ) {
			SEND_PATH( path );
			ALLOC_PATH( path );
		}
#	endif
	int chown( const char *path, uid_t owner, gid_t group ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}

#if defined(LINUX)
	int fchmod( map(int fd), mode_t mode );
	int setreuid( uid_t ruid, uid_t euid );
	int setregid( uid_t rgid, uid_t egid );
	int truncate( const char *path, size_t length ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}
	int ftruncate( map(int fd), size_t length );
#elif defined(OSF1)
	int fchmod( map(int fd), MODE_T mode );
	int setreuid( uid_t ruid, uid_t euid );
	int setregid( gid_t rgid, gid_t egid );
	int truncate( const char *path, off_t length ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}
#if (!defined (SWITCH) && !defined(CLIP))
	int ftruncate( map(int fd), off_t length );
#endif
#else
	int fchmod( map(int fd), MODE_T mode );
	int setreuid( int ruid, int euid );
	int setregid( int rgid, int egid );
	int truncate( const char *path, off_t length ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}
#if defined(Solaris)
	#if (!defined (SWITCH) && !defined(CLIP))
		int ftruncate( map(int fd), off_t length ) : extract, no_sys_chk ;
	#endif
#else
	int ftruncate( map(int fd), off_t length );
#endif
#endif
	not_supported int setgid( gid_t gid );
	int mkdir( const char *path, MODE_T mode ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}
	int rmdir( const char *path ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}
	int utimes( const char *path, struct timeval times[] ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
		in code_bytes_bool( times, TIMEVAL_ARRAY_SIZE );
		alloc( times, TIMEVAL_ARRAY_SIZE );
	}
#if defined(HPUX10)
	long gethostid();
#else
	int gethostid();
#endif
#if defined(HPUX9) || defined(LINUX) || defined(Solaris) || defined(IRIX53)
	int setrlimit( int resource, const  struct rlimit *rlp ) {
#else
	int setrlimit( int resource, /* const */ struct rlimit *rlp ) {
#endif
		in code( rlp );
		alloc( rlp, RLIMIT_SIZE );
	}
	int getrlimit( int resource, struct rlimit *rlp ) {
		in code( rlp );
		alloc( rlp, RLIMIT_SIZE );
	}
	pid_t setsid();
#if defined(HPUX9)
	int statfs( char *path, struct statfs *buf ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
		out code( buf );
		alloc( buf, STATFS_SIZE );
	}
#elif defined(LINUX)
	int statfs( const char *path, struct statfs *buf ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
		out code( buf );
		alloc( buf, STATFS_SIZE );
	}
#elif defined(Solaris)
	not_supported
{	int statfs( char *path, struct statfs *buf, int len );
	}
#elif defined(IRIX53)
	int statfs( const char *path, struct statfs *buf, int len, int fstyp ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
		out code( buf );
		alloc( buf, STATFS_SIZE );
	}
#else
	int statfs( char *path, struct statfs *buf, int len ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
		out code( buf );
		alloc( buf, STATFS_SIZE );
	}
#endif
	int getdomainname( char *name, int namelen ) {
		out code( name, namelen );
		alloc( name, namelen );
	}
	int lockf( map(int fd), int request, off_t size );


		/*
		  Not implemented because our xdr_ustname() function isn't
		  working.  This is because the sizes of the strings are
		  defined differently on various platforms...
		*/
	not_supported int uname( struct utsname *name ) {
		/*
		out utsname( name );
		alloc( name, UTSNAME_SIZE );
		*/
	}


#	if !defined(AIX32)
		int mvalid( char * addr, size_t len, int prot ) {
			out code_bytes_bool( addr, len );
			alloc( addr, len );
		}

		int getaddressconf( struct addressconf *buf, size_t length ) {
			out code_bytes_bool( buf, length );
			alloc( buf, length );
		}
		pid_t getpgid( pid_t pid );
		int uswitch( int cmd, int value );
#	endif



		/*
		Things having to do with signals - we may support these
		one day soon.  ...and now we do on some platforms -Todd 1/95 
		*/
	not_supported {

#if 	!defined(SAVE_SIGSTATE)


#if 	defined(LINUX)
		int sigprocmask( int how, sigset_t *set, sigset_t *o_set );
#else
		int sigprocmask( int how, const sigset_t *set, sigset_t *o_set );
#endif

		int sigpending( sigset_t *set );

#if		!defined(LINUX)
		int sigreturn( struct sigcontext *scp );
#endif

#if		defined(LINUX)
		int sigsuspend( sigset_t *set );
#else
		int sigsuspend( const sigset_t *mask );
#endif


		int sigstack( struct sigstack *instack, struct sigstack *outstack );
#	if defined( AIX32)
		int kill( pid_t pid, int sig );
#	else
#	if defined(IRIX53)
        int kill( pid_t pid, int sig ) : dl_extract;
#	else
        int kill( pid_t pid, int sig ) : extract;
#	endif
#	endif
#endif  /* of !defined(SAVE_SIGSTATE) */


#if		defined(LINUX) || defined(Solaris251) || defined(HPUX9)
		int setitimer( int which, const struct itimerval *value,
				struct itimerval *oval );
#else
		int setitimer( int which, struct itimerval *value,
											struct itimerval *oval );
#endif
		int getitimer( int which, struct itimerval *value );
	}

		/*
		We don't support these everywhere, but we ignore attempts to do them remotely
		for the benefit of Fortran compilers...
		*/
	ignored {
#	if defined( AIX32) && !defined(SAVE_SIGSTATE)
		int sigaction( int sig, const struct sigaction *act,
						struct sigaction *o_act );
#	elif !defined (SAVE_SIGSTATE)
#if		defined(LINUX)
		int sigaction( int sig, struct sigaction *act,
				struct sigaction *o_act ) : extract;
#elif		defined(IRIX53)
		int sigaction( int sig, const struct sigaction *act,
						struct sigaction *o_act ) : dl_extract;
#else
		int sigaction( int sig, const struct sigaction *act,
						struct sigaction *o_act ) : extract;
#endif
#	endif
		int setsysinfo( unsigned long op, char *buffer, unsigned long nbytes,
						char * arg, unsigned long flag );
	}
#endif /* not CLIP */

	/*
	Things having to do with memory mapped files - we may support these
	one day soon.
	*/
not_supported {
#	if defined(IRIX53) || defined(OSF1)
#	if defined(IRIX53)
	void * mmap( void * a, size_t l, int p, int f, map(int fd),
														off_t o ) : dl_extract;
#	elif defined(OSF1)
	void * mmap( void * a, size_t l, int p, int f, map(int fd),
														off_t o ) : extract;
#	endif  /* of OSF1 */
	int munmap( void * addr, size_t len );
	int mprotect( ALPHA_CONST void * addr, size_t len, int prot );
	int madvise( INV_SYSCALL_PTR * addr, size_t len, int behav );
	int msync( void * addr, size_t len, int flags );
#	else 
	char * mmap( char * a, size_t l, int p, int f, map(int fd),
														off_t o ) : extract;
	int munmap( char * addr, size_t len );
	int mprotect( char * addr, size_t len, int prot );
	int madvise( char * addr, size_t len, int behav );
	int msync( char * addr, size_t len, int flags );
#	endif
}

#if !defined( CLIP )
	/* Calls intended only for the super user or system managers */
not_supported {
	int setuid( uid_t uid );
	int setlogin( char *name );
	int revoke( char *path );
	int chroot( const char *path );
#if defined(Solaris)
	int setgroups( int gidsetsize, const gid_t grouplist[] );
#else
	int setgroups( int gidsetsize, gid_t grouplist[] );
#endif
	int plock( int op );
#if defined(HPUX10)
	int adjtime( const struct timeval *delta, struct timeval *old_delta );
#else
	int adjtime( struct timeval *delta, struct timeval *old_delta );
#endif
	int sethostid( int host_id );
	int async_daemon();
#	if !defined(SUNOS41) && !defined(IRIX53)
		int getfh( map(int fd), fhandle_t *fhp, int exp_fd );
#	endif
#	if !defined(SUNOS41)
		int exportfs( int access, int *record, struct exportfsdata *exdata );
#	endif
#if defined(LINUX)
	int mount( const char *spec, const char *dir, const char *fstyp,
		unsigned long rwflag, const void *data );
	int acct( const char *path );
	int reboot( int magic, int magic_too, int flag );
	int sethostname( const char *address, size_t address_len );
	int settimeofday( const struct timeval *tp, const struct timezone *tzp );
	int setdomainname( const char *name, size_t namelen );
	int swapon( const char *path, int swapflags );
#else
#if defined(Solaris)
		int mount( const char *spec, const char *dir, int mflag, int fstyp, char *pt, int len );
		int acct( const char *path );
#elif defined(OSF1)
		int mount( int type, char *mnt_path, int mnt_flag, char *data );
		int acct( char *path );
#else
		int mount( char *spec, char *dir, int mflag, int fstyp, char *pt, int len );
		int acct( char *path );
#endif

	void reboot( int howto );
	int sethostname( char *address, int address_len );
	int settimeofday( struct timeval *tp, struct timezone *tzp );
	int setdomainname( char *name, int namelen );
	int swapon( char *path, int flags, int lo_water, int hi_water );
#endif  /* of not LINUX */

} /* of not_supported { (Must be after the #endif Linux - Derek) */


	/* Calls having to do with multiple process jobs */
not_supported {
#if defined(AIX32)
	pid_t fork();
	int pipe( int fd[] );
#elif defined(IRIX53)
	pid_t fork() : dl_extract;
	int pipe( int fd[] ) : dl_extract;
#else
	pid_t fork() : extract;
	int pipe( int fd[] ) : extract;
#endif
	pid_t vfork();
	int execve( const char *path, char * const argv[], char * const envp [] );
	int execv( const char *path, char * const argv[] );
	int exec_with_loader( int flags, const char *loader, const char *file,
					  char * const argv[], char * const envp[] );
	pid_t wait4( pid_t pid, int *status, int options, struct rusage *ru );
#if defined(Solaris)
	int ptrace( int req, long process, int address, int data);
#else
	int ptrace( long req, long int process, unsigned long *address,
						unsigned long data );
#endif
	int setpgid( pid_t process_id, pid_t gid );
}

	/* Calls relating to sockets - implies multiple communicating processes */
not_supported {
	int recvmsg( int socket, struct msghdr *message, int flags );
	int sendmsg( int socket, struct msghdr *message, int flags );
	int recvfrom( int socket, SYSCALL_PTR *buffer, int length, int flags,
				  struct sockaddr *address, int *addr_len );
	int accept( int socket, struct sockaddr *address, int *addr_len );
	int getpeername( int socket, struct sockaddr *address, int *addr_len );
	int getsockname( int socket, struct sockaddr *address, int *addr_len );
	int connect( int sock, ALPHA_CONST struct sockaddr *address, int 
				addr_len );
#if !defined(SWITCH) /* moved into separate .c file to avoid a name conflict */
	int send( int socket, char *msg, int length, int flags );
#endif
	int recv( int socket, char *msg, int length, int flags );
	int bind( int socket, ALPHA_CONST struct sockaddr *address, int addr_len );
	int listen( int socket, int backlog );
	int sendto( int sock, ALPHA_CONST SYSCALL_PTR *msg, int msg_len, int flags,
				ALPHA_CONST struct sockaddr *dest, int dest_len );
	int shutdown( int socket, int how );
	int socketpair( int domain, int type, int protocol, int sock_vector[] );
	int getsockopt( int sock, int level, int opt_name, SYSCALL_PTR *opt_val,
					int *opt_len );
	int setsockopt( int sock, int level, int opt_name, 
				   ALPHA_CONST SYSCALL_PTR *opt_val, int opt_len );
	int nfssvc( int sock, int mask, int match );
}


	/*
	Things we perhaps ought to support, but aren't in the
	current implementation
	*/
not_supported {
#if defined(LINUX)
	int profil( char *buf, int buf_size, int offset,
				 int scale );
#elif defined(Solaris)
	void profil( short *buf, unsigned int buf_size, int offset, unsigned int scale);
#else
	void profil( short *buf, unsigned int buf_size, unsigned int offset,
				 unsigned int scale );
#endif
	int quotactl( char *path, int cmd, int id, char *addr );
	int getsysinfo( unsigned long op, char * buf, unsigned long nbytes,
					int *start, char *arg );
}


	/*
	Stuff having to do with message queues.  Probably won't support
	these unless they become a standard across all the platforms.
	*/
not_supported {
	int msgctl( int msgid, int cmd, struct msqid_ds *buf );
	int msgget( key_t key, int msgflg );
	int msgrcv(int qid, void *msgp, size_t msgsz, long msgtyp, int msgflg );
	int msgsnd( int msqid, ALPHA_CONST void *msgp, size_t msgsz, int msgflg );
}

	/*
	Stuff having to do with semaphores.  Probably won't support
	these unless they become a standard across all the platforms.
	*/
not_supported {
	int semctl( int semid, int semnum, int cmd, void *arg );
	int semget( key_t key, int nsems, int semflag );
	int semop( int semid, struct sembuf *sops, unsigned int nsops );
}

	/* Stuff having to do with shared memory. */
not_supported {
	int shmctl( int shmid, int cmd, struct shmid_ds *buf );
	int shmdt( ALPHA_CONST SYSCALL_PTR * addr );
#if defined(AIX32)
	int shmget( key_t key, unsigned int size, unsigned int flags );
#else
	int shmget( key_t key, size_t size, int flags );
#endif
	SYSCALL_PTR * shmat( int shmid, ALPHA_CONST SYSCALL_PTR * shmaddr, int shmflg );
}

#endif /* not CLIP */

	/* System calls unique to AIX - needed even in CLIPPED version */ 
	/* Also needed by Solaris - Jim B. */
#if defined(AIX32) || defined(Solaris)
	uid_t getuidx( int which );
	gid_t getgidx( int which );
#	if !defined(SWITCH)
		char * getwd( char *path_name ) : pseudo {
			GET_PATH( path_name );
			ALLOC_PATH( path_name );
		}
#	endif
#endif


	/* System calls unique to AIX - not needed in CLIPPED version */ 
#if !defined(CLIP) && defined(AIX32)
	int statx( char *path, struct stat *buffer, int length, int command ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
		out code( buffer );
		alloc( buffer, STAT_SIZE );
	}
	int fstatx( map(int fd), struct stat *buffer, int length, int command ) {
		out code( buffer );
		alloc( buffer, STAT_SIZE );
	}
	int accessx( char *path, int mode, int who ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}
	int faccessx( map(int fd), int mode, int who );
	int chacl( char *path, struct acl *list, int size ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
		out code_bytes_bool( list, size );
		alloc( list, size );
	}
	int fchacl( map(int fd), struct acl *list, int size ) {
		out code_bytes_bool( list, size );
		alloc( list, size );
	}
	int fstatacl( map(int fd), int cmd, struct acl *list, int size ) {
		out code_bytes_bool( list, size );
		alloc( list, size );
	}
	int statacl( char *path, int cmd, struct acl *list, int size ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
		out code_bytes_bool( list, size );
		alloc( list, size );
	}
	int chownx( char *path, int owner, int group, int ext ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}
	int fchownx( map(int fd), int owner, int group, int ext );
	long fclear( map(int fd), unsigned long nbytes );
	int frevoke( map(int fd) );
	int kgetpgrp( int pid );
	int getpri( int pid );
	int kfcntl( map(int fd), int cmd, int arg );
#if !defined (SWITCH)
		/*
		This call must interact closely with the open files table,
		therefore its switch is implemented in "condor_ckpt/file_state.C",
		but we still need to generate senders and receivers for it here.
		*/
	int openx( const char *path, int flags, int mode, int ext ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}
#endif
	int psdanger( int sig );
	int ulimit( int cmd, int lim );
	int usrinfo( int cmd, char *buf, int count ) {
		in code_bytes_bool( buf, count );
		alloc( buf, count );
	}


	not_supported {
		int audit();
		int auditbin();
		int auditevents();
		int auditlog();
		int auditobj();
		int auditproc();
		int chpriv();
		int fchpriv();
		int disclaim();
		int fscntl();
		int fstatpriv();
		int getargs();
		int getdirent();
		int getevars();
		int getpriv();
		int getproc();
		int getuser();
		int kioctl();
		int knlist();
		int kwaitpid();
		int load();
		int loadbind();
		int loadquery();
		int mntctl();
		int pause();
		int privcheck();
		int absinterval();
		int getinterval();
		int gettimer();
		int gettimerid();
		int incinterval();
		int reltimerid();
		int resabs();
		int resinc();
		int restimer();
		int settimer();
		int nsleep();
		int seteuid();
		int setgidx();
		int setpri();
		int setpriv();
		int setuidx();
		int msgxrcv();
		int sigcleanup();
		int statpriv();
		int swapoff();
		int swapqry();
		int sysconfig();
		int unameu();
		int unamex();
		int unload();
		int ustat();
		int uvmount();
		int vmount();
		int Trconflag();
		int trchook();
		int trchk();
		int trchkt();
		int trchkl();
		int trchklt();
		int trchkg();
		int trchkgt();
		int trcgen();
		int trcgent();

	}
		
#if defined(Solaris)
#undef static
#endif

#endif /* not CLIP */
