/***************************************************************
 *
 * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
 * University of Wisconsin-Madison, WI.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you
 * may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 * 
 *    http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ***************************************************************/

/*
  How to read this file:

  This file is used to generate 3 C++ language files -  "switches.C",
  "senders.C", and "receivers.C".  Not all of the information contained
  here is needed in every case.

  Switches are functions which are linked in with the user's code, and
  have the same names as the system call they are intended to invoke.
  The switch will determine whether the call should be done locally or
  remotely, and will invoke an appropriate mechanism to accomplish
  that.  In the case of local execution, that will most often be the
  syscall() routine.  In the case of remote calls, that will always be
  the REMOTE_syscall() routine.  The syscall() routine is generally
  provided in the C library, and REMOTE_syscall() is provided by
  Condor.  More on this in the next paragraph...

  Senders are the part of the code which packages up the arguments of a
  system call, sends them to the shadow for remote execution, and then
  package up the results so it looks to the calling routine as though
  the normal system call were done.  The REMOTE_syscall() routine is
  organized as a giant switch() statement, with one "case" for each
  system call.  Each case is called a "sender".

  Receivers are the part of the code which runs on the submitting
  machine that matches with the sender.  The receiver reads all the
  arguments to the system call, performs the call, then sends back the
  results.  We plan to eventually generate the recievers from this
  template file, but the current code doesn't do it.

  The general format of this file is a function prototype for every
  system call.  Those give the system call return type, the name, and
  the names and types of each of the system call arguments.  The system
  call prototypes have been augmented with other information needed to
  generate correct switches, senders, and receivers.  Each type of
  augmenting information is described here:

  : hidden_ptr
	  Sometimes the return value of a system call is actually a pointer,
	  but hidden in a system type. caddr_t is an example. So, for 
	  syscalls which return pointers types that aren't identified via
	  <type> * constructs, we must label the call with a 'hidden_ptr'
	  option so the stub generator knows how to check the return value of
	  the syscall for validity.

  : extract
	  Some system calls cannot be successfully executed by the syscall()
	  routine.  This is generally becuase syscall() expects that every
	  system call will pass its return value through register 0.  A few
	  system calls like getuid() will actually return 2 values, the
	  real uid in register 0, and the effective uid in register 1.  In
	  that case, there is no system call geteuid() - that information is
	  gotten as a side effect of the getuid() system call.  For this
	  reason geteuid() doesn't work with syscall().  In such a case
	  another means must be found to execute the offending system call.
	  We extract from the C library a copy of whatever the normal system
	  call stub is, and change the name by making it all upper case.
	  For example geteuid() becomes GETEUID().  The switch generator must
	  know that geteuid() has to be handled specially in the local case,
	  which is the meaning of "extract".

  : dl_extract
	  This is similar to extract above except it uses dlopen() and
	  dlsym() to find the appropriate versions of the calls in
	  /usr/lib/libc.so.

  : no_sys_chk
	  By default, a test for defined(SYS_name) is wrapped around
	  all non-pseudo calls in senders and receivers.  If a call is
	  marked with no_sys_chk, this test is omitted.  This is useful
	  for calls which are not system calls on a specific platform
	  but must still be supported by remote system calls for
	  cross platform interoperability.

  in code_bytes_bool( buf, len );
	  A statement like this appears with the prototype for the
	  write() system call.  Note that the parameter "buf" is a
	  pointer to void, and it is not immediately obvious whether
	  data should be sent to the remote system call receiver,
	  whether data should be sent back, or both.  Also, "buf" tells
	  us where the data starts, but it is not obvious (from the
	  syntax), how much data should be sent.  This statement tells
	  us that data should be sent to the remote system call
	  receiver by the keyword "in".  If you think of the system
	  call as simply a function, then "buf" is an "in" parameter to
	  the write() function.  "code_bytes( buf, len )" is the
	  routine and arguments which should be used to transfer
	  the data.  A similar statement appears with the prototype for
	  read(), but in this case the keyword "out" indicates that
	  (from the point of view of the read() system call), "buf" is
	  an out parameter, i.e. data must be sent from the system call
	  receiver to the sender.  In cases where data needs to travel
	  in both directions, both an "in" and an "out" statement would
	  appear.

	  NOTE: we need to use code_bytes_bool() here to get the
	  assert-safe functionality we want: 0 on failure, 1 on
	  success.  code_bytes() itself just returns the number of
	  bytes read or written, and -1 on failure. 


  : file_table
	A special flag placed after a prototype to indicate that the
	call should be directed through the file table by calling
	OpenFileTable->name(...) when MappingFileDescriptors() is in
	effect.

  map( int fd )

	When MappingFileDescriptors() is in effect, ask the file table
	to convert this fd into a local or remote fd.  Note that this
	use is discouraged, because it does not provide a general form
	of redirection like :file_table does.  Not all file types will
	support map().  In this case, the syscall will fail in EINVAL.

  map_name( pathname )

	When MappingFileDescriptors() is in effect, ask the file table
	to determine where this file is stored, much as we do for open.
	Perform the system call at that location.

  map_name_two( pathname )
	Used for the second filename in system calls that refer to two
	filenames.  It performs exactly the same lookup as map_name(),
	but fails with EXDEV if the second name is not stored at the
	same server as the first.

  rdiscard( parameter )

	This will throw out the given parameter
	when performing a remote system call.

  discard( parameter )

	This will throw out the given parameter
	for both local and remote system calls.

Each system call prototype has several names associated with
it.  By default, each name is the same as the function name,
perhaps with a CONDOR_ or SYS_ appended as appropriate.
However, you can specify a different name to use in special
circumstances:

  : file_table_name( id )

	The file table name specifies the method to call when
	MappingFileDescriptors is in effect, and the file table
	must be used.

  : local_name( id )

	The local name specifies the system call name to use
	when LocalSysCalls is in effect.

  : sender_name( id )

	The sender name indicates that an existing sender
	should be used to generate remote calls by this name.

  : remote_name( id )

	Generate a sender for this system call, but use the
	given name when transmitting the arguments.

	For example, fstat64() uses the sender named 
	CONDOR_fstat64, because the conversion from
	structure to network is slightly different than
	that of fstat().  However, it must use the 
	number CONDOR_fstat, because we want to use
	one receiver to interpret both calls.

  : also_implements( id )

  	The same receiver implementation also handles system calls
	with the given name.  Up to ten also_implements() modifiers,
	each with a different id, can be used on each entry.

	For example, also_implements() can be used to preserve
	backwards compatibility between new shadows and older versions
	of the syscall lib.  The 6.1.8 syscall_lib had a seperate
	receiver for fstat() and for fstat64().  Newer versions of Condor
	have just one receiver for fstat and fstat64; fstat64 calls now
	get "mapped" into an CONDOR_fstat call [by using the remote_name() modifier].
	However, old versions of the syscall lib will still send 
	CONDOR_fstat64 system calls to the shadow.  In order to preserve
	backwards compatibility, we add the modifier also_implements(fstat64)
	to the fstat entry.  This tells the stub generator that the given
	receiver stub should be used for both CONDOR_fstat and for
	CONDOR_fstat64 remote system calls.

   not_supported

	A number of system calls Condor can simply not service.
	In this case, the system call is sent remotely, and it becomes
	the shadow's responsibility to pass the message along to the 
	user.

    ignored

	This is slightly different than not_supported.  Some system calls
	(like msync and getsysinfo) should not actually be executed, but
	should also not give any error indication to the user.  In this
	case, the call simply returns success.

  Some system calls simply must be handled specially.  Examples
  are those system calls which directly affect the open files
  table used for checkpoint/restart.  Unfortunately, this
  "specialness" dosen't necessarily span all three pieces of code
  we want to generate.  For example, the switch for open() must
  be special because it affects the open files table, but the
  sender and receiver for open() don't need any special
  treatment.  We would therefore like to include a prototype for
  open(), but we must somehow tell the switch generator that it
  should not generate anything for open().  We solve the problem
  by running this file through the C preprocessor (cpp) before
  processing it.  The switch generator will ensure that the macro
  SWITCH is defined, the sender generator will instead define the
  macro SENDER, and similarly the reveiver generator will define
  the macro RECEIVER.  We then use cpp conditional statements to
  ensure that each generator sees only the prototypes for which it
  should generate code.

	In addition to senders, receivers, and switches, this file
	may be processed with different features in mind.
		FILE_TABLE - build stubs for the open file table
		REMOTE_SYSCALLS - build stubs for general remote syscalls.
		CLIP - clipped condor - only build the syscalls needed
			to run the starter and vanilla jobs.
		CARMI_OPS - build stubs for CARMI
 */

#define SEND_PATH(name) in code(name)
#define GET_PATH(name) out code(name)
#define ALLOC_PATH(name) null_alloc(name)

/* Does EXTRACT mean static or dynamic? */

#if defined( DL_EXTRACT )
#   define EXTRACT dl_extract
#else
#   define EXTRACT extract
#endif

/* For Linux with an I386 kernel, INDIRECT really means INDIRECT. */

#if defined(LINUX) && defined(I386)
#	define INDIRECT indirect
#else
#	define INDIRECT direct
#endif

/* 
   fcntl's "cmd" argument, and open's "flags" argument both have to be 
   CEDARized so that we can deal with heterogeneous submits.  So, for
   the switch, we want to just use the regular int.  However, for the
   sender and the reciever, we have to use CEDAR's special enum type
   so that we send the thing across the wire in a platform-independent
   way.  -Derek Wright and Todd Tannenbaum 2/8/00
*/
#if defined(SWITCH)
#   define OPEN_FLAGS_T int
#   define FCNTL_CMD_T int
#else
#   define OPEN_FLAGS_T open_flags_t
#   define FCNTL_CMD_T fcntl_cmd_t
#endif

#include "condor_socket_types.h"

/*
This group of calls is needed in the syscall lib, the standalone ckpt
lib, *and* in the clipped version (for the old PVM starter).  All of
these calls manipulate the open file table.
*/ 
#if defined(FILE_TABLE)
	int open( const char *path, OPEN_FLAGS_T flags, ... )
		: file_table
#		if defined(AIX)
			, no_sys_chk
#		endif
	{
		SEND_PATH( path );
		ALLOC_PATH( path );
	}

	int close( int fd ) 
		: file_table
#		if defined(AIX)
			, no_sys_chk
#		endif
		;

	int unlink( map_name(const char *path) ) 
#		if defined(AIX)
			: no_sys_chk
#		endif
	{
		SEND_PATH( path );
		ALLOC_PATH( path );
	}

	int rename( map_name(const char *from), map_name_two(const char *to) ) 
		: pseudo 
	{
		SEND_PATH( from );
		SEND_PATH( to );
		ALLOC_PATH( from );
		ALLOC_PATH( to );
	}
#endif /* FILE_TABLE */


/*
This group of calls is needed in the syscall lib and
the standalone ckpt lib, but not in the clipped version.
All of these calls manipulate the open file table.
*/ 

#if defined(FILE_TABLE) && !defined(CLIP)

	int open64( const char *path, OPEN_FLAGS_T flags, ... )
		: sender_name(open), file_table_name(open), local_name(open);

	ssize_t read( int fd, void *buf, size_t len )
		: file_table
	{
		out code_bytes_bool( buf, ret_val );
		alloc( buf, len );
	}
	
        ssize_t write( int fd, const void *buf, size_t len )
		: file_table
	{
		in code_bytes_bool( buf, len );
		alloc( buf, len );
	}

	off_t lseek( int fd, off_t offset, int whence )
		: file_table, also_implements(lseek64), also_implements(llseek); 

#	if !defined(LINUX)
		offset_t llseek( int fd, offset_t offset, int whence )
			: file_table_name(lseek), remote_name(lseek);
#	elif defined(LINUX)

	   /*
	      When we implement llseek in local mode, we always
      	      want to use SYS_lseek, since SYS_llseek, SYS__llseek,
	      and friends take a different number of arguments, and
	      you always fail with errno == EFAULT.  WARNING: this
	      means we're NOT handling 64 bit offsets correctly, but
	      at least 32 bit offsets work now. :) 
	      Derek Wright <wright@cs.wisc.edu> 2/4/00
	   */
#		if defined(GLIBC22) || defined(GLIBC23) || defined (GLIBC24) || defined(GLIBC25) || defined(GLIBC27) || defined(GLIBC211) || defined(GLIBC212) || defined(GLIBC213) || defined(GLIBC217)
			off64_t llseek( int fd, off64_t offset, int whence )
				: file_table_name(lseek), remote_name(lseek), no_sys_chk, 
				local_name(lseek);
#		endif
#	endif

	/* on Linux, lseek64 just goes to llseek */
#	if !defined(LINUX)
	off64_t lseek64( int fd, off64_t offset, int whence )
		: file_table_name(lseek), remote_name(lseek)
#		if defined(Solaris)
			, local_name(llseek)
#		endif
		;
#	endif

	int dup( int old_fd ) : file_table;
	int dup2( int old_fd, int new_fd ) : file_table;

	int fcntl( int fd, FCNTL_CMD_T cmd, ... ) : file_table;

#	if defined(LINUX) && defined(GLIBC)
		int ioctl( int fd, unsigned long cmd, ... ) : file_table;
#	else
		int ioctl( int fd, int cmd, ... ) : file_table;
#	endif

	int pipe( int fd[] ) : EXTRACT, file_table;

	/*
	fsync must go through the table to flush the buffer cache.
	Systems that don't have SYS_fsync still need the sender,
	so we provide no_sys_chk for the sender only.
	*/

	int fdsync( int fd, rdiscard(int flags) )
		: file_table_name(fsync), sender_name(fsync);
	int fdatasync( int fd )
		: file_table_name(fsync), sender_name(fsync);
	int fsync( int fd )
#		if defined(SENDER)
			: file_table, no_sys_chk;
#		else
			: file_table;
#		endif

#	if !defined(SWITCH)
#		if SYNC_RETURNS_VOID
			void sync() : pseudo, file_table;
#		else 
			int sync() : pseudo, file_table;
#		endif
#	endif

	/* Truncate must go through the table to update the file size. */

	int ftruncate( int fd, off_t length ) :
#		if !defined(SWITCH)
			/* Sender needed, even if not a true syscall */
			no_sys_chk,
#		endif
		file_table, also_implements(ftruncate64);

	int ftruncate64( int fd, off64_t length )
		: file_table_name(ftruncate), remote_name(ftruncate);
	
	int fchdir( int fd ) : file_table;

	int chdir( const char *path ) : pseudo, file_table {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}

	/*
	poll and switch are supported in a limited way for local files
	and sockets, so we need the switch to trap them, but
	no sender or receiver.
	
	Addendum, we actually need a sender so the shadow could support it in 
	the future. -psilord 5/23/2001
	*/

#	if defined(SWITCH) || defined(SENDER)
			int poll( struct pollfd *fds, unsigned long nfds, int timeout ) : file_table;
			int select (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout) : file_table
#			if defined(LINUX)
#				if defined(I386)
				/* Linux has a new system call we should use because SYS_select
					is deprecated and returns EINVAL now */
				, local_name(_newselect)
#				endif
#			endif
			; /* closes the select() */
#	endif

	/*
	socket is supported in general, but is a special
	switch on Solaris.
	*/
#	if defined(Solaris)
#		if !defined(SWITCH)
		int socket( int domain, int type, int protocol )
			: file_table, no_sys_chk, INDIRECT;
#		endif
#	else
		int socket( int domain, int type, int protocol )
			: file_table, INDIRECT;
#	endif


#endif /* FILE_TABLE and not CLIP */

/*
The functions in this section all deal with remote I/O, but they
don't need to manipulate the open file table, except to map a
logical fd to a physical fd.  They are not needed in the clipped
version.
*/

#if defined(REMOTE_SYSCALLS) && !defined(CLIP)

#   if defined(LINUX)
    /*
     * fstatat(), fstatat64(), SYS_newfstatat, __fxstatat, __fxstatat64.
     *
     * Don't ask me why they can't name this just one thing, but Linux
     * hates us all.
     *
     * Looks like the glob() problem on SL 6.0 can be fixed by nothing
     * more than this autogenerated automagic, at least in stand-alone mode.
     */
    int __fxstatat64( discard(int ver), map(int dirfd), const char * pathname, struct stat *buf, int flags ) :
        local_name(newfstatat),
        remote_name(fstatat)
		{
			SEND_PATH( pathname );
			ALLOC_PATH( pathname );
			out code( buf );
			alloc( buf, STAT_SIZE );
		}

#	endif /* for fstatat() and friends. */

	/*
	The stat calls have very unusual cases on Linux.
	Most of the switches are special.
	*/

#	if defined(LINUX) && (defined(GLIBC22) || defined(GLIBC23) || defined(GLIBC24) || defined(GLIBC25) || defined(GLIBC27) || defined(GLIBC211) || defined(GLIBC212) || defined(GLIBC213) || defined(GLIBC217) )
#		define STAT_NEEDS_SPECIAL_SWITCH
#	endif

#	if !defined(SWITCH) || !defined(STAT_NEEDS_SPECIAL_SWITCH)
		int fstat( int fd, struct stat *buf ) :
#			if defined(STAT_NEEDS_EXTRACT)
				extract,
#			endif
				also_implements(fstat64),   /* for backwards compatibility */
				file_table
		{
			out code( buf );
			alloc( buf, STAT_SIZE );
		}

#	endif

#	if !defined(SWITCH) || !defined(STAT_NEEDS_SPECIAL_SWITCH)
		int stat( map_name(const char *name), struct stat *buf ) :
#			if defined(STAT_NEEDS_EXTRACT)
				extract,
#			endif
				also_implements(stat64),   /* for backwards compatibility */
				file_table
		{
			SEND_PATH( name );
			ALLOC_PATH( name );
			out code( buf );
			alloc( buf, STAT_SIZE );
		}

#	endif

#	if !defined(SWITCH) || !defined(STAT_NEEDS_SPECIAL_SWITCH)
		int lstat( map_name(const char *name), struct stat *buf ) :
#			if defined(STAT_NEEDS_EXTRACT)
				extract,
#			endif
				also_implements(lstat64),   /* for backwards compatibility */
				file_table
		{
			SEND_PATH( name );
			ALLOC_PATH( name );
			out code( buf );
			alloc( buf, STAT_SIZE );
		}

#	endif

	/*
	64-bit system calls all generate their own switches and senders,
	but they send the name of the 32-bit system call on the wire.
	*/

#	if defined(HAS_64BIT_SYSCALLS) 

#	if defined(Solaris)

		int fstat64( map(int fd), struct stat64 *buf ) :
			remote_name(fstat)
		{
			out code( buf );
			alloc( buf, STAT64_SIZE );
		}
	
		int stat64( map_name(const char *path), struct stat64 *buf ) : 
			remote_name(stat) 
		{ 
			SEND_PATH( path );
			ALLOC_PATH( path );
			out code( buf );
			alloc( buf, STAT64_SIZE );
		}
	
		int lstat64( map_name(const char *path), struct stat64 *buf ) : 
			remote_name(lstat) 
		{ 
			SEND_PATH( path );
			ALLOC_PATH( path );
			out code( buf );
			alloc( buf, STAT64_SIZE );
		}
#	endif
#	endif /* HAS_64BIT_SYSCALLS */

	int fchown( map(int fd), uid_t owner, gid_t group );
	int fchmod( map(int fd), mode_t mode );

#	if defined(Solaris)
		int statfs( const char *path, struct statfs *buf, rdiscard(int len), rdiscard(int fstyp) ) : pseudo {
#	else
		int statfs( const char *path, struct statfs *buf ) : pseudo {
#	endif
			SEND_PATH( path );
			ALLOC_PATH( path );
			out code( buf );
			alloc( buf, STATFS_SIZE );
		}

#	if defined(Solaris)
		int fstatfs( map(int fd), struct statfs *buf, int len, int fstyp ) {
#	else
		int fstatfs( map(int fd), struct statfs *buf ) {
#	endif
			out code( buf );
			alloc( buf, STATFS_SIZE );
		}

	int flock( map(int fd), int op );
	int lockf( map(int fd), int op, off_t where ) : also_implements(lockf64);
	int lockf64( map(int fd), int op, off64_t where )
		: remote_name(lockf);

/* This only happens for senders/receivers, there is a special switch for
	this call which handles the odd unmapping of the passed in file descriptor.

	For this call, we don't map() the fd since it will call into getdents which
	also map()'s the fd causing it to fail. The special switch has more
	detail about how to unmap the fd in certain circumstances.
*/
#if !defined(SWITCH)
#	if defined(LINUX)
#		if defined(I386)
			int getdirentries( int fd, char *buf, size_t nbytes, 
							off_t *basep ) : no_sys_chk, extract 
#		else
			ssize_t getdirentries( int fd, char *buf, size_t nbytes, 
							off_t *basep ) : no_sys_chk, extract 
#		endif

		{
			out code_bytes_bool( buf, ret_val );
			in code_bytes_bool( basep, EIGHT );
			out code_bytes_bool( basep, EIGHT );
			alloc( buf, nbytes );
			alloc( basep, LONG_SIZE );
		}
#	endif
#endif

#	if defined(Solaris) || ( defined(LINUX) && !defined(SWITCH) )
		int getdents( map(int fd), struct dirent *buf, size_t nbytes )
		{
			out code_bytes_bool( buf, nbytes );
			alloc( buf, nbytes );
		}

#	endif

#if defined(Solaris) || defined(LINUX)
		int getdents64( map(int fd), struct dirent64 *buf, size_t nbytes )
		{
			out code_bytes_bool( buf, nbytes );
			alloc( buf, nbytes );
		}
#endif

	/*
	These calls do not need switches because they are pseudo calls,
	only invoked by supervisory code in the syscall lib.
	*/

#	if !defined(SWITCH)

		off_t lseekread( int fd, off_t offset, int whence, void *buf, size_t len )
			: pseudo
		{
			out code_bytes_bool( buf, len );
			alloc( buf, len );
		}

		off_t lseekwrite( int fd, off_t offset, int whence, const void *buf, size_t len )
			: pseudo
		{
			in code_bytes_bool( buf, len );
			alloc( buf, len );
	        }
#	endif /* not SWITCH */

	/*
	Condor supports sockets now!  The socket is created and managed
	within the OpenFileTable, and we simply map it into place.  The
	prototypes are very different between systems, so macros are
	used to identify parameter types.  On linux, socket calls
	are indirect system calls.
	*/

	not_supported int socketpair( int domain, int type, int protocol, int *fds ) : INDIRECT;

	int accept(
		map(int fd),
		SOCKET_ADDR_CONST_ACCEPT SOCKET_ADDR_TYPE addr,
		SOCKET_ALTERNATE_LENGTH_TYPE * length) : INDIRECT;
	int bind(
		map(int fd),
		SOCKET_ADDR_CONST_BIND SOCKET_ADDR_TYPE addr,
		SOCKET_LENGTH_TYPE length ) : INDIRECT;
	int connect(
		map(int fd),
		SOCKET_ADDR_CONST_CONNECT SOCKET_ADDR_TYPE addr,
		SOCKET_LENGTH_TYPE length) : INDIRECT;
	int getpeername(
		map(int fd),
		SOCKET_ADDR_TYPE addr,
		SOCKET_ALTERNATE_LENGTH_TYPE * length) : INDIRECT;
	int getsockname(
		map(int fd),
		SOCKET_ADDR_TYPE addr,
		SOCKET_ALTERNATE_LENGTH_TYPE * length) : INDIRECT;
	int getsockopt(
		map(int fd),
		int level,
		int option,
		SOCKET_DATA_TYPE value,
		SOCKET_ALTERNATE_LENGTH_TYPE * length) : INDIRECT;
	int listen(
		map(int fd),
		SOCKET_COUNT_TYPE count) : INDIRECT;

	/* LINUX/X86_64 doesn't support a separate send and recv. 
		They are implemented as sendto and recvfrom in switches.special.C */

#	if !(defined(LINUX) && defined(X86_64))
		SOCKET_SENDRECV_TYPE send(
			map(int fd),
			SOCKET_DATA_CONST SOCKET_DATA_TYPE data,
			SOCKET_SENDRECV_LENGTH_TYPE length,
			SOCKET_FLAGS_TYPE flags ) : INDIRECT;

		SOCKET_SENDRECV_TYPE recv(
			map(int fd),
			SOCKET_DATA_TYPE data,
			SOCKET_SENDRECV_LENGTH_TYPE length,
			SOCKET_FLAGS_TYPE flags) : INDIRECT;
#	endif

	SOCKET_RECVFROM_TYPE recvfrom(
		map(int fd),
		SOCKET_DATA_TYPE data,
		SOCKET_SENDRECV_LENGTH_TYPE length,
		SOCKET_FLAGS_TYPE flags,
		SOCKET_ADDR_TYPE addr,
		SOCKET_ALTERNATE_LENGTH_TYPE *addrlength) : INDIRECT

		;

	SOCKET_SENDRECV_TYPE recvmsg(
		map(int fd),
		struct msghdr *msg,
		SOCKET_FLAGS_TYPE flags) : INDIRECT;
	SOCKET_SENDRECV_TYPE sendmsg(
		map(int fd),
		SOCKET_MSG_CONST struct msghdr * msg,
		SOCKET_FLAGS_TYPE flags) : INDIRECT;
	SOCKET_SENDRECV_TYPE sendto(
		map(int fd),
		SOCKET_DATA_CONST SOCKET_DATA_TYPE data,
		SOCKET_SENDRECV_LENGTH_TYPE length,
		SOCKET_FLAGS_TYPE flags,
		const SOCKET_ADDR_TYPE addr,
		SOCKET_LENGTH_TYPE addrlength ) : INDIRECT;
	int setsockopt(
		map(int fd),
		int level,
		int option,
		SOCKET_DATA_CONST SOCKET_DATA_TYPE value,
		SOCKET_LENGTH_TYPE length) : INDIRECT;
	int shutdown (
		map(int fd),
		int how) : INDIRECT;

/*
Each of the following system calls deals with a pathname.
Pathnames must all be mapped from their logical names to
their physical locations by the file table when mapping
is in effect.  If a syscall deals with two path names,
it should apply map_name_two() to the second one, which
will compares its results to that of map_name() and
report an error if reside on different devices.
*/

	int link( map_name(const char *p1), map_name_two(const char *p2) ) {
		SEND_PATH( p1 );
		SEND_PATH( p2 );
		ALLOC_PATH( p1 );
		ALLOC_PATH( p2 );
	}

	int access( map_name(const char *path), int access_mode ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}

	int mknod( map_name(const char *path), mode_t mode, dev_t device ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}

	int chmod( map_name(const char *path), mode_t mode ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}

	int symlink( map_name(const char *path1), map_name_two(const char *path2) ) {
		SEND_PATH( path1 );
		SEND_PATH( path2 );
		ALLOC_PATH( path1 );
		ALLOC_PATH( path2 );
	}


#if	defined(LINUX) && (defined(GLIBC25) || defined(GLIBC27) || defined(GLIBC211) || defined(GLIBC212) || defined(GLIBC213) || defined(GLIBC217) )
	ssize_t readlink( map_name(const char *path), char *buf, size_t buf_size ) {
#else
	int readlink( map_name(const char *path), char *buf, size_t buf_size ) {
#endif
		SEND_PATH( path );
		ALLOC_PATH( path );
		out code_bytes_bool( buf, buf_size );
		alloc( buf, buf_size );
	}

#	if !defined(LINUX)
		int lchown( map_name(const char *path), uid_t owner, gid_t group ) {
			SEND_PATH( path );
			ALLOC_PATH( path );
		}
#	endif

	int chown( map_name(const char *path), uid_t owner, gid_t group ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}

#	if defined(Solaris) 
		int truncate( map_name(const char *path), off_t length ) : extract {
			SEND_PATH( path );
			ALLOC_PATH( path );
		}
#	else
		int truncate( map_name(const char *path), off_t length ) {
			SEND_PATH( path );
			ALLOC_PATH( path );
		}
#	endif /* Solaris */


	int mkdir( map_name(const char *path), mode_t mode ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}
	int rmdir( map_name(const char *path) ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}


	int utimes( map_name(const char *path), const struct timeval *times ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
		in code( times );
		alloc( times, TIMEVAL_SIZE );
	}

	int utime( map_name(const char *path), const struct utimbuf *buf) {
		SEND_PATH( path );
		ALLOC_PATH( path );
		in code( buf );
		alloc( buf, UTIMBUF_SIZE );
	}

/*
Miscellaneous file-related operations that do not deal with
either file names or file descriptors.
*/

#	if !defined(Solaris) && !defined(LINUX) && !defined(HPUX)
		int getfsstat( struct statfs buf[], long bufsize, int flags ) {
			out code_bytes_bool( buf, STATFS_ARRAY_SIZE );
			alloc( buf, bufsize );
		}
#	endif

#	if !defined(SWITCH)
		/* The shadow can choose whether or not to execute
			this particular security unconcious system call depending upon the
			administrator's policies. */
	int shell( char *command, int len ) : pseudo, no_sys_chk {
		in code_bytes_bool( command, len );
		alloc( command, len );
	}
#	endif

#endif /* REMOTE_SYSCALLS and not CLIP */

#	if !defined(SWITCH)
		/* We only define a sender/receiver pair for getwd(). This is so
			we can deal with the path variable properly in the remote i/o
			stubs without also having to mess with the char * return
			parameter of getwd(). The special hand written switch for 
			getwd() will deal with the correct return type of getwd().
		*/
		int getwd_special( char *&path_name ) : pseudo, 
			also_implements(getwd) 
		{
			GET_PATH( path_name );
			ALLOC_PATH( path_name );
		}
#	endif


/*
These are general-purpose system calls.
They are not needed for remote I/O, but *are* used by the old PVM
starter to figure out what uid/gid to try to run the job as, which is
why they can't be left inside an !defined(CLIP) block...
*/
#if defined(REMOTE_SYSCALLS)
	uid_t getuid() 
		: pseudo
#		if defined(AIX)
			, no_sys_chk
#		endif
		;
	gid_t getgid()  
		: pseudo
#		if defined(AIX)
			, no_sys_chk
#		endif
		;
#endif


/*
These are general-purpose system calls.
They are not needed for remote I/O or for the condor daemons.
*/

#if defined(REMOTE_SYSCALLS) && !defined(CLIP)

	pid_t getppid() : EXTRACT, pseudo;
	pid_t getpid()  : pseudo;
	pid_t getpgid( pid_t pid );
	pid_t getpgrp();
	
	/*
	getlogin() returns a pointer to a static buffer - our generator is not
	quite yet sophisticated enough to generate correct stubs for this.
	So we have a special switch for it in switches.special.c that
	allocates the static space for it.
	Furthermore, we make it pseudo cuz we want the shadow to return the
	job's Owner as the value.  -Todd , 4/97
	*/
#	if !defined(SWITCH)
		int getlogin( char *&loginbuf ) : pseudo {
			out code( loginbuf );
			null_alloc ( loginbuf );
		}  
#	endif /* not SWITCH */


	mode_t umask( mode_t cmask );
	int getpagesize();

	int getgroups( int gidsetsize, gid_t grouplist[] ) 
#if defined(LINUX) && (defined(GLIBC25) || defined(GLIBC27) || defined(GLIBC211) || defined(GLIBC212) || defined(GLIBC213) || defined(GLIBC217) ) && defined(I386)
	/* I'm not sure why, but SYS_getgroups32 seems to be in fashion for this
		glibc revision in the i386. The normal SYS_getgroups just returns
		garbage... */
	: local_name(getgroups32)
#endif
	{
		out code_array( grouplist, gidsetsize );
		alloc(grouplist, gidsetsize * GID_T_SIZE);
	}

#	if !defined(Solaris) && !defined(LINUX) && !defined(HPUX)
		int table( int id, int index, char *addr, int nel, unsigned int lel ) {
			out code_bytes_bool( addr, nel * lel );
			alloc( addr, nel * lel );
		}
#	endif

#	if defined(LINUX)
		int gethostname( char *address, size_t address_len ) {
#	else 
		int gethostname( char *address, int address_len ) {
#	endif
			out code_bytes_bool( address, address_len );
			alloc( address, address_len );
		}

	int getdtablesize();

	int setpriority( int which, int who, int priority );
	int getpriority( int which, int who );

#if !defined(SWITCH)
#	if defined(LINUX)
		int gettimeofday( struct timeval *tp, struct timezone *tzp ) {
#	else
		int gettimeofday( struct timeval *tp, void *tzp ) {
#	endif
			out code( tp );
			/* don't code( tzp ) since it is often a NULL pointer */
			alloc( tp, TIMEVAL_SIZE );
			alloc( tzp, TIMEZONE_SIZE );
		}
#endif

		int gethostid();

#	if defined(HPUX) || defined(LINUX) || defined(Solaris)
		int setrlimit( int resource, const  struct rlimit *rlp ) {
#	else
		int setrlimit( int resource, struct rlimit *rlp ) {
#	endif
			in code( rlp );
			alloc( rlp, RLIMIT_SIZE );
		}

	int getrlimit( int resource, struct rlimit *rlp )
#	if defined(LINUX) && defined(I386)
	/* We use a local_name of ugetrlimit here because SYS_getrlimit on
		i386 systems is fixated to a 2gb maximum. SYS_ugetrlimit
		is the preferred system call interface into the i386 kernel to
		get/set the higher values and deal with RLIM_INFINITY properly. */
	: local_name(ugetrlimit)
#	endif
	{
		out code( rlp );
		alloc( rlp, RLIMIT_SIZE );
	}

#	if HAS_64BIT_SYSCALLS
		int setrlimit64( int resource, const  struct rlimit64 *rlp ) {
			in code( rlp );
			alloc( rlp, RLIMIT64_SIZE );
		}

		int getrlimit64( int resource, struct rlimit64 *rlp ) {
			out code( rlp );
			alloc( rlp, RLIMIT64_SIZE );
		}
#	endif

	int getdomainname( char *name, int namelen ) {
		out code_bytes_bool( name, namelen );
		alloc( name, namelen );
	}

#	if defined(Solaris) || defined(LINUX) || defined(HPUX)
		not_supported { 
			int mvalid( char * addr, size_t len, int prot ) {
				out code_bytes_bool( addr, len );
				alloc( addr, len );
			}

			int uswitch( int cmd, int value );
		}
#	else
		int mvalid( char * addr, size_t len, int prot ) {
			out code_bytes_bool( addr, len );
			alloc( addr, len );
		}

		int uswitch( int cmd, int value );
#	endif /* Solaris || Linux */

#endif /* REMOTE_SYSCALLS and not CLIP */

/*
These are used by the starter AND by the remote system calls, and thus get
generated even in the "clipped" version.
*/

#if defined(REMOTE_SYSCALLS) || defined(CLIP)

	uid_t geteuid() : EXTRACT, pseudo;
	gid_t getegid() : EXTRACT, pseudo;

#endif /* REMOTE_SYSCALLS or CLIP */


/*
These are speical operations performed by the syscall lib.  Since they
are special Condor operations, not system calls, we don't need a
switch for them.  However, we only need to generate these if we're
doing remote system calls.
*/
#if defined(REMOTE_SYSCALLS) && !defined( SWITCH )
	/*
	  This psuedo call is used by the syscall lib to register its
	  version string with the shadow so we can check for
	  compatibility.
	*/
	int register_syscall_version( const char *version ) : pseudo {
		SEND_PATH( version );
		ALLOC_PATH( version );
	}
#endif /* REMOTE_SYSCALLS and not SWITCH */


/*
These are speical operations performed by the starter, but have
no meaning in local mode.  Since they are special Condor operations,
they are generally used by Condor daemons, not user programs.  Thus,
they should be built in the special "clipped" version.
*/

#if !defined( SWITCH )

	/* allow the starter to explain to the shadow the checkpointing signature
		of the platform where a job is about to be executed. All platforms,
		even clipped platforms specify this string.  */
	int register_ckpt_platform( const char *platform, int len ) : pseudo
	{
		in code_bytes_bool( platform, len );
		alloc( platform, len );
	}

	int register_fs_domain( const char *domain ) : pseudo {
		SEND_PATH( domain );
		ALLOC_PATH( domain );
	}
	int register_uid_domain( const char *domain ) : pseudo {
		SEND_PATH( domain );
		ALLOC_PATH( domain );
	}
	int get_universe( int *univ_id ) : pseudo {
	    out code( univ_id );
	    alloc( univ_id, INT_SIZE );
	}

	int get_username( char *uname ) : pseudo {
	    GET_PATH( uname );
	    ALLOC_PATH( uname );
	}

	int extern_name( const char *path, char *buf, int bufsize ) : pseudo {
		SEND_PATH( path );
		ALLOC_PATH( path );
		out code_bytes_bool( buf, bufsize );
		alloc( buf, bufsize );
	}
	int free_fs_blocks( const char *pathname ) : pseudo {
		SEND_PATH( pathname );
		ALLOC_PATH( pathname );
	}
	int reallyexit( int *status, struct rusage *use_p ) : pseudo {
		in code( status );
		alloc( status, INT_SIZE );
		in code( use_p );
		alloc( use_p, RUSAGE_SIZE );
		return( NEG_ONE );
	}
	int subproc_status(int id,int *status,struct rusage *use_p) : pseudo {
		in code( status );
		alloc( status, INT_SIZE );
		in code( use_p );
		alloc( use_p, RUSAGE_SIZE );
		return( NEG_ONE );
	}
	int image_size( int kbytes ) : pseudo;
	int send_rusage( struct rusage *use_p ) : pseudo {
		in code( use_p );
		alloc( use_p, RUSAGE_SIZE );
	}
	int getrusage( int who, struct rusage *use_p ) : pseudo {
		out code( use_p );
		alloc( use_p, RUSAGE_SIZE );
	}
#	ifndef RECEIVER  /* We need a special receiver so that we don't leak memory */
		int startup_info_request( STARTUP_INFO *s ): pseudo {
			out code( s );
			alloc( s, STARTUP_INFO_SIZE );
		}
#	endif

	int report_error( char *msg ) : pseudo {
		in code( msg );
		null_alloc(msg);
	}

	/* This was the old remote call for reporting file actions.
	   int is not big enough to record moderate amounts of I/O,
	   so this is deprecated in favor of report_file_info_new.
	*/
	int report_file_info(
		char *kind, char *name,
		int open_count, int read_count, int write_count,
		int seek_count, int read_bytes, int write_bytes ) : pseudo {

		SEND_PATH(kind);
		ALLOC_PATH(kind);
		SEND_PATH(name);
		ALLOC_PATH(name);
	}
	int report_file_info_new(
		char *name,
		int64_t open_count, int64_t read_count, int64_t write_count,
		int64_t seek_count, int64_t read_bytes, int64_t write_bytes ) : pseudo {

		SEND_PATH(name);
		ALLOC_PATH(name);
	}
	int get_std_file_info( int fd, char *&logical_name ) : pseudo {
		GET_PATH( logical_name );
		ALLOC_PATH( logical_name );
	}
	/*
	This call transforms a logical name into a url chain, perhaps including
	multiple stages, e.g. /tmp/file -> buffer:remote:/tmp/file
	*/
	int get_file_info_new( const char *logical_name, char *&actual_url ): pseudo {
		SEND_PATH( logical_name );
		ALLOC_PATH( logical_name );
		GET_PATH( actual_url );
		ALLOC_PATH( actual_url );
	}
	/*
	The old version of the same call performed the same mapping, but only
	returns the basic file type, such as local: or remote:, and leaves
	it to the syscall lib to add wrapper stages.
	*/
	int get_file_info( const char *logical_name, char *&actual_url ): pseudo {
		SEND_PATH( logical_name );
		ALLOC_PATH( logical_name );
		GET_PATH( actual_url );
		ALLOC_PATH( actual_url );
	}
	/*
	These two calls have been superceded by get_std_file_info and
	get_file_info, which deal with urls instead of file names
	and integers.  They remain for compatibility with the old starter.
	*/
        int std_file_info( int fd, char *&logical_name, int *pipe_fd ) : pseudo {
                GET_PATH( logical_name );
                ALLOC_PATH( logical_name );
                out code( pipe_fd );
                alloc( pipe_fd, INT_SIZE );
        }
        int file_info( const char *logical_name, int *fd, char *&physical_name ): pseudo {
                SEND_PATH( logical_name );
                ALLOC_PATH( logical_name );
                GET_PATH( physical_name );
                ALLOC_PATH( physical_name );
                out code( fd );
                alloc( fd, INT_SIZE );
        }

	int get_buffer_info( int *bytes, int *block_size, int *prefetch_size ) : pseudo {
		out code( bytes );
		alloc( bytes, INT_SIZE );
		out code( block_size );
		alloc( block_size, INT_SIZE );
		out code( prefetch_size );
		alloc( prefetch_size, INT_SIZE );
	}

	int get_job_attr( const char *attrname, char *&expr ) : pseudo
	{
		in code(attrname);
		null_alloc(attrname);
		out code(expr);
		null_alloc(expr);
	}

	int set_job_attr( const char *attrname, const char *expr ) : pseudo
	{
		in code(attrname);
		null_alloc(attrname);
		in code(expr);
		null_alloc(expr);
	}

	int constrain( const char *expr ) : pseudo
	{
		in code(expr);
		null_alloc(expr);
	}

	int get_iwd( char *&path ) : pseudo {
		GET_PATH( path );
		ALLOC_PATH( path );
	}
	int get_ckpt_name( char *&path ) : pseudo {
		GET_PATH( path );
		ALLOC_PATH( path );
	}

	int get_ckpt_mode( condor_signal_t sig ) : pseudo;

	int get_ckpt_speed( ) : pseudo;

	int get_a_out_name( char *&path ) : pseudo {
		GET_PATH( path );
		ALLOC_PATH( path );
	}


#	if !defined (SWITCH)
		int pvm_info( const char *response, int mytid ) : pseudo {
			SEND_PATH( response );
			ALLOC_PATH( response );
		}

		int pvm_task_info( int v_pid, int pvm_tid) : pseudo;

		int suspended( int susp ) : pseudo;
#	endif
		/*
		This function is intended for setting up the transfer
		of a whole file via a TCP stream.  This allows more
		flexibility than the similar get_file() protocol, and may
		be more efficient as well, since we bypass XDR.  The name
		of the file is the single parameter sent to the shadow, and
		the result is the length of the file, a hostname, and a port
		number from which the actual bytes can be read.
		*/
	int get_file_stream( const char *file, size_t *len, unsigned int *ip_addr,
		u_short *port_num ): pseudo {

		SEND_PATH( file );
		ALLOC_PATH( file );

		out code( len );
		alloc( len, SIZE_T_SIZE );

		out code( ip_addr );
		alloc( ip_addr, U_INT_SIZE );

		out code( port_num );
		alloc( port_num, U_SHORT_SIZE );
	}

		/*
		This function is intended for setting up the transfer
		of a whole file via a TCP stream.  This allows more
		flexibility than the similar put_file() protocol, and may
		be more efficient as well, since we bypass XDR.  The name
		of the file is the single parameter sent to the shadow, and
		the result is a hostname and a port number to which the
		actual bytes can be written.
		*/
	int put_file_stream( const char *file, size_t len,
						unsigned int *ip_addr, u_short *port_num ): pseudo {

		SEND_PATH( file );
		ALLOC_PATH( file );

		out code( ip_addr );
		alloc( ip_addr, U_INT_SIZE );

		out code( port_num );
		alloc( port_num, U_SHORT_SIZE );
	}

	int register_ckpt_server( const char *host ): pseudo {
		SEND_PATH( host );
		ALLOC_PATH( host );
	}

	int register_arch( const char *arch ): pseudo {
		SEND_PATH( arch );
		ALLOC_PATH( arch );
	}

	int register_opsys( const char *opsys ): pseudo {
		SEND_PATH( opsys );
		ALLOC_PATH( opsys );
	}

	int register_begin_execution( ): pseudo;

#	if !defined( SENDER )
		/*
		These two functions implement protocols for sending and fetching
		whole files at a time.  Since there is a more complex protocol
		involved, it's easier to just code the senders by hand.
		They are implemented in "senders.epilogue".
		*/
		int send_a_file( const char *name, mode_t mode ) : pseudo {
			SEND_PATH( name );
			ALLOC_PATH( name );
		}
		int get_file( const char *name ) : pseudo {
			SEND_PATH( name );
			ALLOC_PATH( name );
		}
#	endif	/* not SENDER */
#endif	/* not SWITCH */


/*
Finally, a long list of the things we don't support
*/

#if defined(REMOTE_SYSCALLS) && !defined(CLIP)

/*
We don't support these everywhere, but we ignore attempts to do them remotely
for the benefit of Fortran compilers...
*/

ignored {
	int setsysinfo( unsigned long op, char *buffer, unsigned long nbytes, char * arg, unsigned long flag );
}

/* Memory mapped files */

not_supported {
#	if defined(HPUX)
		void * mmap( void * a, size_t l, int p, int f, map(int fd), off_t o ) : EXTRACT;
		int mprotect( const void * addr, size_t len, int prot );
		int madvise( void * addr, size_t len, int behav );
#	elif defined(LINUX)
        // Don't define mmap(), since it doesn't return NULL on error.
		int mprotect( MMAP_T addr, size_t len, int prot );
#	else
		char * mmap( char * a, size_t l, int p, int f, map(int fd), off_t o ) : EXTRACT;
		int mprotect( char * addr, size_t len, int prot );
		int madvise( char * addr, size_t len, int behav );
#	endif

#	if HAS_64BIT_SYSCALLS
		MMAP_T mmap64( MMAP_T addr, size_t len, int prot, int flags, map(int fd), off64_t off);
#	endif
}

ignored {
#	if defined(HPUX)
		int msync( void * addr, size_t len, int flags );
#	elif defined(LINUX)
		int msync( MMAP_T addr, size_t len, int flags );
#	else
		int msync( char * addr, size_t len, int flags );
#	endif
}

not_supported {
	int setuid( uid_t uid );
	int setgid( gid_t gid );
	int setreuid( uid_t ruid, uid_t euid );
	int setregid( uid_t rgid, uid_t egid );
	int setlogin( char *name );
	int revoke( char *path );
	int chroot( const char *path );
#	if defined(Solaris)
		int setgroups( int gidsetsize, const gid_t grouplist[] );
#	else
		int setgroups( int gidsetsize, gid_t grouplist[] );
#	endif
	int plock( int op );
	int adjtime( struct timeval *delta, struct timeval *old_delta );
	int sethostid( int host_id );
	int async_daemon();

	int getfh( map(int fd), fhandle_t *fhp, int exp_fd );

	int exportfs( int access, int *record, struct exportfsdata *exdata );

#	if defined(LINUX)
		int mount( const char *spec, const char *dir, const char *fstyp,
			unsigned long rwflag, const void *data );
		int umount( const char* dir );
		int acct( const char *path );
		int reboot( int magic, int magic_too, int flag );
		int sethostname( const char *address, size_t address_len );
		int settimeofday( const struct timeval *tp, const struct timezone *tzp );
		int setdomainname( const char *name, size_t namelen );
		int swapon( const char *path, int swapflags );
		int swapoff( const char *path );
		int bdflush( int func, long data );
		caddr_t create_module( const char* name, size_t size ) : hidden_ptr;
		caddr_t delete_module( const char* name ) : hidden_ptr; 
		int init_module( const char* name, struct module* image ); 
		int iopl( int level );
		void idle();
		int ioperm( unsigned long from, unsigned long num, int turn_on );
#	else
#		if defined(Solaris)
			int mount( const char *spec, const char *dir, int mflag, int fstyp, char *pt, int len );
			int acct( const char *path );
#		else
			int mount( char *spec, char *dir, int mflag, int fstyp, char *pt, int len );
			int acct( char *path );
#		endif

		void reboot( int howto );

		int sethostname( char *address, int address_len );

		int settimeofday( struct timeval *tp, struct timezone *tzp );
		int setdomainname( char *name, int namelen );

		int swapon( char *path, int flags, int lo_water, int hi_water );
#	endif  /* not LINUX */
}

/* Multiple processes */

not_supported {
	pid_t fork() : EXTRACT;
#	if defined(LINUX)
#		if defined(GLIBC22) || defined(GLIBC23) || defined(GLIBC24) || defined(GLIBC25) || defined(GLIBC27) || defined(GLIBC211) || defined(GLIBC212) || defined(GLIBC213) || defined(GLIBC217)
			/* XXX the stub generator doesn't understand function prototypes */
/*			pid_t clone(int (*)(void*), void *sp, int *, void *);*/
#		else
			pid_t clone(void *sp, unsigned long flags);
#		endif
#	elif defined(Solaris)
		pid_t fork1();
#	endif

	pid_t vfork();

	int execve( const char *path, char * const argv[], char * const envp [] );

#	if defined(HPUX)
		/* Need better stub gen */
#	else
		int execv( const char *path, char * const argv[] );
#	endif
	

	int exec_with_loader( int flags, const char *loader, const char *file,
					  char * const argv[], char * const envp[] );
	int execvp( const char *file, char *const argv[] );

#	if defined(LINUX)
		pid_t wait4( pid_t pid, void *status, int options, struct rusage *ru );
#	else
		pid_t wait4( pid_t pid, int *status, int options, struct rusage *ru );
#	endif

	pid_t wait(int *status);

#	if defined(LINUX)
		pid_t waitpid(pid_t pid, int *status, int options);
#	endif

#	if defined(Solaris29)
		long ptrace( int req, pid_t process, long address, long data);
#	elif defined(Solaris28)
		long ptrace( int req, pid_t process, int address, int data);
#	elif defined(Solaris27)
		long ptrace( int req, long process, long address, long data);
#	elif defined(Solaris)
		int ptrace( int req, long process, int address, int data);
#	else
		int ptrace( long req, long int process, unsigned long *address, unsigned long data );
#	endif
		int setpgid( pid_t process_id, pid_t gid );
		pid_t setsid();
		pid_t setpgrp( );
}

/* Profiling and measuring */

not_supported {
#	if defined(LINUX)
		int profil( char *buf, int buf_size, int offset, int scale );
#	elif defined(Solaris27) || defined(Solaris28) || defined(Solaris29)
		void profil( unsigned short *buf, unsigned int buf_size, unsigned long offset, unsigned int scale );
#	elif defined(Solaris26)
		void profil( unsigned short *buf, unsigned int buf_size, unsigned int offset, unsigned int scale );
#	else
		void profil( short *buf, unsigned int buf_size, unsigned int offset, unsigned int scale );
#	endif

	int quotactl( char *path, int cmd, int id, char *addr );
	int getsysinfo( unsigned long op, char * buf, unsigned long nbytes, int *start, char *arg );

#	if defined(LINUX)
		int setitimer( int which, const struct itimerval *value, struct itimerval *oval );
		int getitimer( int which, struct itimerval *value );
#	elif defined(HPUX)
		/* get/set itimer are special on HPUX */
#	else
		int setitimer( int which, struct itimerval *value, struct itimerval *oval );
		int getitimer( int which, struct itimerval *value );
#	endif
}

/* SYSV messages, semaphores, and shared memory */

not_supported {
	int msgctl( int msgid, int cmd, struct msqid_ds *buf );
	int msgget( key_t key, int msgflg );
	int msgrcv(int qid, void *msgp, size_t msgsz, long msgtyp, int msgflg );
	int msgsnd( int msqid, const void *msgp, size_t msgsz, int msgflg );

	int semctl( int semid, int semnum, int cmd, void *arg );
	int semget( key_t key, int nsems, int semflag );
	int semop( int semid, struct sembuf *sops, unsigned int nsops );

	int shmctl( int shmid, int cmd, struct shmid_ds *buf );
	int shmdt( const void * addr );
	int shmget( key_t key, size_t size, int flags );
	void * shmat( int shmid, const void * shmaddr, int shmflg );
}

#endif /* REMOTE_SYSCALLS and not CLIP */

/*
These calls are only built specially for CARMI.
*/

#ifdef CARMI_OPS

#define RequestId int
#define ResponseTag int
#define HostId int
#define ProcessId int
#define ResourceClass char* /* for the time being */

	int carmi_cancel_request(RequestId id, ResponseTag resp_tag) : pseudo; 

	int carmi_config( ResponseTag resp_tag)	: pseudo; 

	int carmi_get_class_ad(HostId id, ResponseTag resp_tag) : pseudo; 

	int carmi_addhosts(char *class_name, int count, ResponseTag resp_tag) 
		: pseudo {
		SEND_PATH( class_name );
		ALLOC_PATH( class_name );
	}

	int carmi_delhosts(int count, HostId* hosts, ResponseTag resp_tag) 
		:pseudo {
		in code_bytes_bool( hosts, count*sizeof(HostId) );
		alloc( hosts, count*sizeof(HostId) );
	}	

	int carmi_add_notify(char *class_name, ResponseTag resp_tag) :pseudo{
		SEND_PATH( class_name );
		ALLOC_PATH( class_name );
	}

	int carmi_delete_notify(int count, HostId *host_ids, 
                                ResponseTag resp_tag): pseudo {
		in code_bytes_bool( host_ids, count*sizeof(HostId) );
		alloc( host_ids, count*sizeof(HostId) );
	}

	int carmi_suspend_notify(int count, HostId *host_ids,
                                 ResponseTag resp_tag) : pseudo {
		in code_bytes_bool( host_ids, count*sizeof(HostId) );
		alloc( host_ids, count*sizeof(HostId) );
	}

	int carmi_resume_notify(int count, HostId *host_ids,
			ResponseTag resp_tag)  : pseudo{
		in code_bytes_bool( host_ids, count*sizeof(HostId) );
		alloc( host_ids, count*sizeof(HostId) );
	}

	int carmi_class_spawn(char *executable, char* argv[], char *class_name,
		  ResponseTag resp_tag) : pseudo {
		SEND_PATH( executable );
		ALLOC_PATH( executable );
		SEND_PATH( class_name );
		ALLOC_PATH( class_name );
	}

	int carmi_process_info( ResponseTag resp_tag) : pseudo; 

	int carmi_class_definitions( ResponseTag resp_tag) : pseudo; 

	int carmi_define_class( rcclass resc_class, 
				ResponseTag resp_tag) : pseudo {
	}

	int carmi_remove_class( char *class_name, 
                                ResponseTag resp_tag) : pseudo{
		SEND_PATH( class_name );
		ALLOC_PATH( class_name );
	}

	int carmi_ckpt(int ckpt_cnt, ProcessId *ckpt_list, 
	   int consistent_cnt, ProcessId *consistent_list, int flush_cnt, 
	   ProcessId *flush_list, HostId id) : pseudo{

		in code_bytes_bool( ckpt_list, ckpt_cnt*sizeof(ProcessId) );
		alloc( ckpt_list, ckpt_cnt*sizeof(ProcessId) );

		in code_bytes_bool( consistent_list, consistent_cnt*sizeof(ProcessId) );
		alloc( consistent_list, consistent_cnt*sizeof(ProcessId) );

		in code_bytes_bool( flush_list, flush_cnt*sizeof(ProcessId) );
		alloc( flush_list, flush_cnt*sizeof(ProcessId) );

	}

	int carmi_restart(int restart_cnt, ProcessId *restart_list, 
	  int consistent_cnt, ProcessId *consistent_list): pseudo {

		in code_bytes_bool( restart_list, restart_cnt*sizeof(ProcessId) );
		alloc( restart_list, restart_cnt*sizeof(ProcessId) );

		in code_bytes_bool( consistent_list, consistent_cnt*sizeof(ProcessId) );
		alloc( consistent_list, consistent_cnt*sizeof(ProcessId) );

	}

	int carmi_migrate(ProcessId target, HostId host, int
	  consistent_cnt, ProcessId *consistent_list): pseudo {

		in code_bytes_bool( consistent_list, consistent_cnt*sizeof(ProcessId) );
		alloc( consistent_list, consistent_cnt*sizeof(ProcessId) );

	}
#endif /* CARMI_OPS */



