#! /usr/bin/env perl
##**************************************************************
##
## Copyright (C) 1990-2013, Condor Team, Computer Sciences Department,
## University of Wisconsin-Madison, WI.
## 
## Licensed under the Apache License, Version 2.0 (the "License"); you
## may not use this file except in compliance with the License.  You may
## obtain a copy of the License at
## 
##    http://www.apache.org/licenses/LICENSE-2.0
## 
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
##**************************************************************

use strict;
use CondorTest;
use Check::SimpleJob;

my $testname = CondorTest::GetDefaultTestName();
my $temptest = CondorTest::TempFileName("$testname");

my $append_condor_config = '
  DAEMON_LIST = MASTER,SCHEDD,COLLECTOR,NEGOTIATOR,STARTD
  ChirpPath = "$(LIBEXEC)/condor_chirp"
  STARTD_ATTRS = $(STARTD_ATTRS) ChirpPath
';

CondorTest::StartCondorWithParams(
    append_condor_config => $append_condor_config
);

# expected memory for shadows by platform.
# these are lowercase so that we can do case-insensitive lookup
#
# for X86_64 shadows
my %memory_data64 = (
	"debian6"  => "920",
	"debian7"  => "1004",
	"fedora17" => "620",
	"fedora18" => "868",
	"fedora19" => "876",
	"fedora20" => "876",
	"redhat5"  => "680",
	"redhat6"  => "752",
	"redhat7"  => "1032",
	"sl6"      => "728",
	"sl7"      => "728",
	"ubuntu10" => "740",
	"ubuntu12" => "1032",
);
# for X86 shadows
my %memory_data32 = (
	"debian6" => "512",
	"redhat5" => "528",
	"redhat6" => "588",
	"sl5"     => "528",
);

my $opsys;
my $arch;
if (CondorUtils::is_windows()) {
   $arch = "x86"; # assume arch on windows
   $opsys = "Windows";
} else {
   my @plat = `condor_config_val arch opsysandver`;
   chomp @plat;
   $arch = $plat[0];	 # should really be checking the bitness of the shadow here
   $opsys = $plat[1];
}

#my $nmi_platform = `condor_config_val CONDOR_BUILD_PLATFORM`; CondorUtils::fullchomp $nmi_platform;
#print "Detected platform from ccv as $arch, $opsys, $nmi_platform. NMI_PLATFORM=$ENV{NMI_PLATFORM}.\n";

my $tolerance = 1.05;
my $expectedmemory = 0;
if ($arch =~ /64/) { 
   $expectedmemory = $memory_data64{lc($opsys)};
} else {
   $expectedmemory = $memory_data32{lc($opsys)};
}
my $allowedmemory = ComputeMemLimit($tolerance, $expectedmemory);
print "Platform is $arch $opsys, expecting shadow memory = $expectedmemory, will error if > $allowedmemory.\n";

# run a job and look at shadow memory usage
my $append_submit_commands = '
+WantIOProxy = true
executable = x_shadow_mem_usage.pl
output = ' . $testname . '.out
error  = ' . $testname . '.err
';

my $on_ulog = sub {
  my %info = @_; # contains cluster,job,date,time,ulog
  CondorTest::debug("Job $info{cluster} ulog: $info{ulog}.\n",1);
  my $text = $info{ulog};
  if ($text =~ /shadow_pid\s*=\s*(\d+)/) {
     my $pid = $1;
     CondorTest::debug("Got shadow PID: $pid.\n",1);
     # CondorTest::runcmd("cat /proc/$pid/smaps");
     # system("proc_pid_smap_summary.pl -h $pid");
     smap_sum_verbose($pid);
  }
};

SimpleJob::RunCheck(
  append_submit_commands=>$append_submit_commands
  , on_ulog=>$on_ulog
);

CondorTest::EndTest();

# scan /proc/<PID>/smaps and add up dirty private pages.
#
sub smap_sum_verbose {

   my $pid = shift;

   my $lib = ""; my $perm; my $inode; my $exe;
   #my $fd; my $addr1; my $addr2;
   my %tot;
   $tot{Heap} = 0;
   $tot{Stack} = 0;
   $tot{LibData} = 0;

   open (SMAP, "</proc/$pid/smaps");
   while (<SMAP>) {
      if ($_ =~ /^([0-9A-Fa-f]+)-([0-9A-Fa-f]+)\s+(r[w-][x-]p)\s+(\S+\s+\S+)\s+(.*)$/) {

         $perm = $3; # perm
         $inode = $5; $lib=""; if ($inode =~ /^(\S+)\s+(.*)$/) { $inode = $1; $lib = $2; }
         #$addr1 = $1; $addr2 = $2; $fd = $4;

         if ( ! ($lib =~ /\.so/) && $lib =~ /condor_/) { $exe = $lib; }
         #
      } elsif ($_ =~ /^(\w+):\s+(\d+)/) {

         my $n = $2;
         $tot{$1} += $n;
         if ($1 =~ /Private_Dirty/) { 
            if ($perm eq "r--p") { $tot{LibRO} += $n; }
            if ($lib eq "") { 
               $tot{Anon} += $n;
            } else {
               if ($lib eq "[heap]") { $tot{Heap} += $n; }
               elsif ($lib eq "[stack]") { $tot{Stack} += $n; }
               elsif ($perm eq "rw-p") { $tot{LibData} += $n; }
               
               if ($lib =~ /condor_util/) { $tot{Utils} += $n; }
               elsif ($lib =~ /condor_/)  { $tot{Exec} += $n; }
               elsif ($lib =~ /condor/)   { 
                  if ($lib =~ /globus|voms/) { $tot{Globus} += $n; }
                  elsif ($lib =~ /classad/)  { $tot{Classad} += $n; }
                  else                       { $tot{Other} += $n; }
               } elsif ($lib =~ /lib/) { $tot{Other} += $n; }
            }
         }
      }
   } #while

   my $lbl = $pid;
   if ($exe) { 
      $exe =~ s/.*\///g;
      $lbl = "$pid:$exe";
   }

   print 'PID:Process            Total Dynamic =(Heap+Stack+Anon) LibRO LibData =(Exec+Utils+Clasad+Globus+System) Clean' . "\n";
   printf "%-22.22s %5d %7d %6d %5d %5d %5d %7d %6d %5d %6d %6d %6d %6d\n", $lbl, 
          $tot{Private_Dirty}, $tot{Heap}+$tot{Stack}+$tot{Anon}, $tot{Heap}, $tot{Stack}, $tot{Anon},
          $tot{LibRO}, $tot{LibData}, $tot{Exec}, $tot{Utils}, $tot{Classad}, $tot{Globus}, $tot{System}+$tot{Other},
          $tot{Private_Clean};

   if ($allowedmemory) {
      if($tot{Private_Dirty} > $allowedmemory) {
         die "Shadow on this platform is allowed to be this <$allowedmemory>, this is over <$tot{Private_Dirty}>\n";
      }
   }

}

sub ComputeMemLimit
{
	my $changerate = shift;
	my $memstat = shift;
	my $newsize = ($changerate * $memstat);
	#print "$changerate * $memstat = $newsize\n";
	return($newsize);
}
