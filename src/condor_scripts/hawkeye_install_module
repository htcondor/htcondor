#! /usr/bin/env perl
use strict;
use warnings;
$| = 1;

# Prototypes
sub Main( );
sub CommandLine( @ );
sub FindConfigFile( );
sub ReadConfigFile( );
sub ReadDescriptionFile( $$ );
sub InstallModules( );
sub InstallModule( $ );
sub ConfigureModule( $ );
sub ProcessConfigLine( $ );
sub WriteConfig( );
sub Expand( $ );
sub Usage ( $ );
sub Help ( );

# ******************************************************
# Command line options
# ******************************************************
my $Distribution = "hawkeye";
my %Options =
    (
     "[--modules=dir]"	=> "Specify modules directory",
     "[--config=file]"	=> "Specify $Distribution config file",
     "[--no-update|-n]"	=> "Don't update the config file",
     "[--update=file]"	=> "Specify config file to update",
     "[--update|-u]"	=> "Enable config update <default>",
     "[--manual|-m]"	=> "Manual mode; asks lots of questions",
     "[--defaults]"	=> "Use defaults if possible",
     "[--all|-a]"	=> "Install all modules found in packages",
     "[--ask]"		=> "Ask before installing each module",
     "File [File..]"	=> "List of module package files to install",
     "[--help|-h]"	=> "Dump help",
    );

# Hash of directories & files
my %Config = (
	      Modules => [],
	      RootDir => "",
	      BaseConfigFile => "",
	      ConfigFile => "",
	      ModulesDir => "",
	      UpdateConfig => 0,
	      UseDefaults => 1,
	      AskAll => 0,
	      InstallAll => 1,
	      Startd => -1,
	      CronName => "",
	      );

my %ConfigMacros;
my %ConfigLines;	# Hash of arrays; 1 per file
my @NewConfig;		# New configuration lines

# Valid "Options"
my @ModuleOptions = qw ( continuous kill nokill reconfig waitforexit );
my $ModuleOptionsRe =
    "(" . join( ")|(", @ModuleOptions ) . ")";

# "Main" Logic
if ( ! exists $ENV{PWD} )
{
    $ENV{PWD} = `/bin/pwd`; chomp $ENV{PWD};
}

# Look at $0, see what we can gleen from it...
if ( $0 =~ /(condor|hawkeye)_install/ )
{
    $Distribution = $1;
}
if ( exists $ENV{CONDOR_DISTRIBUTION} )
{
    $Distribution = $1;
}
my $Program = $Distribution . "_install_module";
my $ConfigEnv = uc $Distribution . "_CONFIG";

# Process command line, etc..
CommandLine( @ARGV );
$#ARGV = -1;
$| = 1;

# Find the config file to use
$ENV{$ConfigEnv} = $Config{BaseConfigFile} if ( ! exists $ENV{$ConfigEnv} );
FindConfigFile( );

# Read the config file
ReadConfigFile( );

# Install the modules
InstallModules( );

# end of "main"
# ******************************************************

# ******************************************************
# Parse the command line, etc.
# ******************************************************
sub CommandLine( @ )
{
    foreach my $Arg ( @_ )
    {
	# Speicfy modules directory
	if ( $Arg =~ /^--modules=(.+)/ )
	{
	    die "Directory '$1' does not exist" if ( ! -d $1 );
	    $Config{ModulesDir} = $1;
	}

	# Speicify config file
	elsif ( $Arg =~ /--config=(.+)/ )
	{
	    die "Config file '$1' does not exist" if ( ! -f $1 );
	    my $File = $1;
	    if ( ! $File =~ /^\// )
	    {
		$File = $ENV{PWD} . "/$File";
	    }
	    $Config{BaseConfigFile} = $File;
	}

	# Config file to update
	elsif ( $Arg =~ /^--update=(.+)/ )
	{
	    $Config{ConfigFile} = $1;
	    $Config{UpdateConfig} = 1;
	}

	# Config update
	elsif ( ( $Arg eq "-u") || ( $Arg eq "--update" ) )
	{
	    $Config{UpdateConfig} = 1;
	}

	# Don't update config
	elsif ( ( $Arg eq "-n") || ( $Arg eq "--no-update" ) )
	{
	    $Config{UpdateConfig} = 0;
	}

	# "Install all modules" mode
	elsif ( ( $Arg eq "-a" ) || ( $Arg eq "--all" ) )
	{
	    $Config{InstallAll} = 1;
	}

	# "Ask" mode
	elsif ( $Arg eq "--ask" )
	{
	    $Config{InstallAll} = 0;
	}

	# Manual mode
	elsif ( ( $Arg eq "-m" ) || ( $Arg eq "--manual" ) )
	{
	    $Config{InstallAll} = 0;
	    $Config{UseDefaults} = 0;
	    $Config{AskAll} = 1;
	}

	# Hawkeye mode
	elsif ( $Arg eq "--hawkeye" )
	{
	    $Distribution = "hawkeye";
	}

	# Condor mode
	elsif ( $Arg eq "--condor" )
	{
	    $Distribution = "condor";
	}

	# Specify the modules directory...
	elsif ( $Arg =~ "--modules=(.+)" )
	{
	    $Config{ModulesDir} = $1;
	}

	# Help
	elsif ( ( $Arg =~ /^-h/ ) || ( $Arg eq "--help" ) )
	{
	    Help( );
	    exit 0;
	}

	# Unknown option
	elsif ( $Arg =~ /^-/ )
	{
	    Usage( $Arg );
	    exit( 1 );
	}

	# Must be a file
	else
	{
	    if ( ! -f $Arg )
	    {
		print STDERR "Warning: Can't find $Arg\n";
		next;
	    }

	    # Make sure it's absolute
	    if ( $Arg =~ /^\// )
	    {
		push( @{$Config{Modules}}, $Arg );
	    }
	    else
	    {
		push( @{$Config{Modules}}, $ENV{PWD} . "/$Arg" );
	    }
	}
    }

    # Any modules to install?
    if ( $#{@{$Config{Modules}}} < 0 )
    {
	print STDERR "No modules specified\n";
	Usage( "" );
	exit 1;
    }

} # CommandLine( )
# ******************************************************

# ******************************************************
# Find the configuration file to use
# ******************************************************
sub FindConfigFile( )
{

    # Check the config env variable...
    if ( ( $Config{BaseConfigFile} eq "" ) && ( exists $ENV{$ConfigEnv} ) )
    {
	warn "$ENV{$ConfigEnv} (from ENV) does not exist!"
	    if ( ! -f $ENV{$ConfigEnv} );
	$Config{BaseConfigFile} = $ENV{$ConfigEnv};
    }

    # Fallbacks...
    my @FallbackConfigs = [ "/home/$Distribution", ];
    my $RootEnv = uc $Distribution . "_ROOT_DIR";
    unshift @FallbackConfigs, $ENV{$RootEnv}
	if ( exists $ENV{$RootEnv} );
    foreach my $TempConfig ( @FallbackConfigs )
    {
	if (  ( $Config{BaseConfigFile} eq "" ) && ( -f $TempConfig )  )
	{
	    $Config{BaseConfigFile} = $TempConfig;
	}
    }

    # Finally, let's go check the config
    if ( $Config{BaseConfigFile} eq "" )
    {
	print STDERR "No config found\n";
	Usage( "" );
	print STDERR "\tOr, set the $ConfigEnv env variable\n";
	exit 1;
    }

} # FindConfigFile()
# ******************************************************

# ******************************************************
# Read the config file
# ******************************************************
sub ReadConfigFile( )
{
    my @ConfigFiles = $Config{BaseConfigFile};

    # Read all of the config files
    foreach my $File ( @ConfigFiles )
    {
	open( CONFIG, $File ) || die "Can't read config @ $File";

	print "Reading config file $File ...";
	my $Line = "";
	while( <CONFIG> )
	{
	    chomp;
	    push( @{$ConfigLines{$File}}, $_ );
	    s/^\s+//;
	    s/\s+$//;

	    # Comment? ( /\#/ )
	    if ( /\#/ )
	    {
		ProcessConfigLine( $Line ) if ( $Line ne "" );
		$Line = "";
	    }

	    # Continuation?
	    elsif ( /(.*)\\$/ )
	    {
		$Line = ( $Line eq "" ) ? $1 : $Line . " " . $1;
	    }

	    # "Normal" line
	    else
	    {
		$Line = ( $Line eq "" ) ? $_ : $Line . " " . $_;
		ProcessConfigLine( $Line ) if ( $Line ne "" );
		$Line = "";
	    }
	}
	close( CONFIG );
	print "Done\n";

	# Evaluate the local configs
	if ( ( $File eq $Config{BaseConfigFile} ) &&
	     ( exists $ConfigMacros{LOCAL_CONFIG_FILE} )  )
	{
	    my $Local = Expand( "LOCAL_CONFIG_FILE" );
	    push( @ConfigFiles, split( /[\,\s]+/, $Local ) );
	}
    }
    print "\n";

    # Add basic things to the config if they're not defined...
    $Config{CronName} = Expand( "STARTD_CRON_NAME" );
    if ( ! defined $Config{CronName} )
    {
	$Config{CronName} =
	    ( $Distribution eq "hawkeye" ) ? "Hawkeye" : "Cron";
	push @NewConfig, "STARTD_CRON_NAME = $Config{CronName}";
	$ConfigMacros{STARTD_CRON_NAME} = $Config{CronName};
    }

    # Find the modules directory location
    my $Modules = $ConfigMacros{MODULES};
    if ( ! defined $Modules )
    {
	my $Hawkeye = Expand( "HAWKEYE" );
	my $HawkeyeDir = Expand( "HAWKEYE_DIR" );
	my $ReleaseDir = Expand( "RELEASE_DIR" );

	# 1. Look for direct config via cmd line
	if ( $Config{ModulesDir} ne "" )
	{
	    $Modules = $Config{ModulesDir};
	}
	# 2. Look for HAWKEYE_DIR in config
	elsif ( ( defined $HawkeyeDir ) && ( -d $HawkeyeDir ) )
	{
	    $Modules = "\$(HAWKEYE_DIR)/modules";
	}
	# 3. Look for HAWKEYE in config
	elsif ( ( defined $Hawkeye ) && ( -d $Hawkeye ) )
	{
	    $Modules = "\$(HAWKEYE)/modules";
	}
	# 4. Look for RELEASE_DIR in config
	elsif ( defined $ReleaseDir )
	{
	    $Modules = "\$(RELEASE_DIR)/modules";
	}
	else
	{
	    print STDERR "No MODULES, HAWKEYE or RELEASE_DIR setting" .
		"found in $Config{BaseConfigFile}\n";
	    print STDERR "Specify --modules=<dir> to correct this\n";
	    exit 1;
	}

	# Configure the new values
	push @NewConfig, "MODULES = $Modules";
	$ConfigMacros{MODULES} = $Modules;
    }

    # Now, expand it and set our internal config
    if ( $Config{ModulesDir} eq "" )
    {
	# Bomb if the modules directory doesn't exist
	my $Dir = Expand( "MODULES" );
	if ( ! -d $Dir )
	{
	    print STDERR "Modules directory '$Modules' does not exist!\n";
	    exit 1;
	}

	# Store the expanded version for internal use
	$Config{ModulesDir} = $Dir if ( $Config{ModulesDir} eq "" );
    }

    # Give up...
    die "Unable to find modules directory\n"
	if ( $Config{ModulesDir} eq "" );
    print "Found modules directory '$Config{ModulesDir}'\n";

    # Jobs defined?
    my $CronJobsVar = uc( $ConfigMacros{STARTD_CRON_NAME} ) . "_JOBS";
    my $Jobs = Expand( $CronJobsVar );
    if ( ! defined $Jobs )
    {
	push @NewConfig, "$CronJobsVar = ";
	$ConfigMacros{$CronJobsVar} = "";
    }
    $Config{CronJobsVar} = $CronJobsVar;

    # Try to find the file that last definied the job list
    if ( $Config{ConfigFile} eq "" )
    {
	my $File = Expand( "INSTALL_MODULE_CONFIG_FILE" );
	$Config{ConfigFile} = $File if ( defined $File );
    }

    # Try to find the file that last definied the job list
    if ( $Config{ConfigFile} eq "" )
    {
	foreach my $File ( reverse @ConfigFiles )
	{
	    my @List = grep( /^\s*$CronJobsVar\s+=/, @{$ConfigLines{$File}} );
	    if ( scalar @List )
	    {
		$Config{ConfigFile} = $File;
		last;
	    }
	}
    }

    # Try to find the file that last defined STARTD_CRON_NAME
    if ( $Config{ConfigFile} eq "" )
    {
	foreach my $File ( reverse @ConfigFiles )
	{
	    my @List = grep( /^\s*START_CRON_NAME\s+=/, @{$ConfigLines{$File}} );
	    if ( scalar @List )
	    {
		$Config{ConfigFile} = $File;
		last;
	    }
	}
    }

    # If there's a local config that's named ".jobs" or similar, use it as
    # the config to modify
    if ( $Config{ConfigFile} eq "" )
    {
	foreach my $File ( @ConfigFiles )
	{
	    if ( $File =~ /(jobs|joblist)$/ )
	    {
		$Config{ConfigFile} = $File;
		last;
	    }
	}
    }

    # If no config specified, use the base
    $Config{ConfigFile} = $Config{BaseConfigFile}
	if ( $Config{ConfigFile} eq "" );
    print "Config Updates will be written to $Config{ConfigFile}\n";


} # ReadConfigFile
# ******************************************************

# ******************************************************
# Configure & Install all Modules
# ******************************************************
sub InstallModules ( )
{
    my $TmpDir = "/tmp/$$";
    my $OrigDir = $ENV{PWD};
    die "$TmpDir already exists!" if ( -d $TmpDir );
    mkdir( $TmpDir, 0700 ) || die "Can't mkdir '$TmpDir'";
    chdir $TmpDir || die "Can't chdir to $TmpDir";

    # Summary info
    my @Ok;
    my @Failed;
    my $ConfigUpdated = scalar @NewConfig;

    # Walk through the list of modules...
    print "Installing modules\n";
    foreach my $Module ( @{$Config{Modules}} )
    {
	die "$Module does not exist" if ( ! -f $Module );
	my $Cmd = "gzip -d < $Module | tar xvfp -";
	if ( system "$Cmd 2>&1 > /dev/null" )
	{
	    warn "Error extracting '$Module'\n";
	    next;
	}

	opendir( DIR, $TmpDir ) || die "Can't read dir $TmpDir";
	my @Files = grep { /^[^\.]/ } readdir( DIR );
	closedir( DIR );

	# Find the description ".hawk" file...
	my @DatFiles = grep { /\.hawk$/ } @Files;
	if ( $#DatFiles < 0 )
	{
	    print STDERR "$Module does not appear to be a valid module file\n";
	    system "/bin/rm *";
	    next;
	}

	# Loop through the list of modules to install...
	foreach my $Description ( @DatFiles )
	{
	    my %ModuleData;

	    # Read the description file for this module..
	    my $Errors = ReadDescriptionFile( $Description, \%ModuleData );
	    if ( $Errors )
	    {
		print "Errors encountered in description " .
		  "file; skipping $Module\n";
		push @Failed, $Module;
		next;
	    }

	    # Get it's name..
	    my $Name = $ModuleData{Name};
	    print "\n\nModule $Name:\n";

	    # Install it?
	    my $Status = InstallModule( \%ModuleData );
	    if ( $Status )
	    {
		push @Failed, $Module if ( $Status < 0 );
		next;
	    }

	    # Enable it?
	    if ( ! $Config{InstallAll} )
	    {
		print "  Do you wish to enable this module? ";
		my $Answer = "";
		while( <> )
		{
		    chomp;
		    if ( /^[yn]/i )
		    {
			$Answer = lc($_);
			last;
		    }
		    print "  Please answer 'y' or 'n': ";
		}
		next if ( $Answer ne "y" );
	    }

	    # Configure it?
	    if ( ! ConfigureModule( \%ModuleData ) )
	    {
		push @Failed, $Module if ( $Status < 0 );
		next;
	    }

	    # Update the config file
	    $Status = UpdateConfig( \%ModuleData );

	    # Add to the failed list?
	    if ( $Status < 0 )
	    {
		push @Failed, $Module
	    }
	    elsif ( $Status == 1 )
	    {
		push @Ok, $Name;
		$ConfigUpdated += $ModuleData{ConfigChanged};
	    }
	}

	# Clean up
	system( "/bin/rm *" );

    }

    # Create the new config file
    if ( $ConfigUpdated )
    {
	WriteConfig( );
    }
    else
    {
	print "No configuration updates required\n";
    }

    # Final clean-up
    chdir $OrigDir;
    system "/bin/rm -fr $TmpDir";

    # Summary
    if ( $#Ok >= 0 )
    {
	print "Fully installed modules:\n";
	foreach my $Tmp ( @Ok )
	{
	    print "   $Tmp\n";
	}
    }
    if ( $#Failed >= 0 )
    {
	print "Failed modules:\n";
	foreach my $Tmp ( @Failed )
	{
	    print "   $Tmp\n";
	}
    }

} # InstallModules()
# ******************************************************

# ******************************************************
# Read the module description file
# ******************************************************
sub ReadDescriptionFile( $$ )
{
    my $DescriptionFile = shift;
    my $Data = shift;

    if ( ! open( DESCRIPTION, $DescriptionFile ) )
    {
	print "Can't read description file '$DescriptionFile'; skipping\n";
	return -1;
    }

    # List of keywords..
    my @KeyWords =
	qw ( modulefiles default options parameter period version );
    my $KeyWordsRe =
	"^(" . join( ":)|(", @KeyWords ) . ":)";
    #print "KeyWordsRe='$KeyWordsRe'\n";

    # Read the description file
    my $Errors = 0;
  READLINE:
    while( <DESCRIPTION> )
    {
	chomp;
	my $Orig = $_;
	s/\#.*//;
	s/^\s+//;
	s/\s+$//;
	next if ( $_ eq "" );

	# Parse the line..
	my $Attribute = "";
	my $Value = "";
	if ( /(\w+):(\s*)(.*)/ )
	{
	    $Attribute = uc $1;
	    $Value = $3 if ( defined $3 );
	}

	# Module files
	if ( $Attribute eq "MODULEFILES" )
	{
	    if ( $Value eq "" )
	    {
		print STDERR
		    "$DescriptionFile line $.: No modules files specfied\n";
		$Errors++;
		last;
	    }
	    my @Files = split( /\s+/, $Value );
	    foreach my $File ( @Files )
	    {
		if ( ! -f $File )
		{
		    print STDERR
			"Can't find '$File' specified in module line $.\n";
		    $Errors++;
		    last;
		}
	    }

	    # Store it all away...
	    $Data->{ModuleFile} = shift @Files
		if ( ! exists $Data->{ModuleFiles} );
	    push( @{$Data->{OtherFiles}}, \@Files )
		if ( $#Files >= 0 );
	    $#Files = -1;
	}

	# Description
	elsif ( $Attribute eq "DESCRIPTION" )
	{

	    # Read the module description
	    my @Description;
	    while( <DESCRIPTION> )
	    {
		chomp;
		s/\s+$//;
		my $Key = $_; $Key =~ s/\s.*$//;
		if ( ( $_ eq "" ) || ( /^\#/ ) || ( $Key =~ /$KeyWordsRe/i ) )
		{
		    #print "Key '$Key' matches\n";
		    $Data->{Description} = \@Description;
		    redo READLINE;
		}
		push @Description, $_;
	    }
	}

	# Default name
	elsif ( $Attribute eq "DEFAULT" )
	{
	    if ( $Value eq "" )
	    {
		print STDERR
		    "$DescriptionFile line $.: No default name specfied\n";
		$Errors++;
		last;
	    }
	    $Data->{DefaultName} = $Value;
	}

	# Prefix
	elsif ( $Attribute eq "PREFIX" )
	{
	    if ( $Value eq "" )
	    {
		print STDERR "$DescriptionFile line $.: No prefix specfied\n";
		$Errors++;
		last;
	    }
	    $Data->{Prefix} = $Value;
	}

	# Version (stored, but not used)
	elsif ( $Attribute eq "VERSION" )
	{
	    if ( $Value eq "" )
	    {
		print STDERR "$DescriptionFile line $.: No version specfied\n";
		$Errors++;
		last;
	    }
	    $Data->{Version} = $Value;
	}

	# Period
	elsif ( $Attribute eq "PERIOD" )
	{
	    if ( $Value eq "" )
	    {
		print STDERR "$DescriptionFile line $.: No period specfied\n";
		$Errors++;
		last;
	    }
	    if ( $Value =~ /((\d+)[sSmMhHdD]?)/ )
	    {
		if ( $2 <= 0 )
		{
		    print STDERR "Period must be > 0\n";
		    $Errors++;
		}
		else
		{
		    $Data->{Period} = $1;
		}
	    }
	    else
	    {
		print STDERR
		    "$DescriptionFile line $.: Invalid period specfied\n";
		$Errors++;
		last;
	    }
	}

	# Options
	elsif ( $Attribute eq "OPTIONS" )
	{
	    @{$Data->{Options}} = split( /\s+/, $Value );
	    foreach my $Opt ( @{$Data->{Options}} )
	    {
		if ( ! $Opt =~ /$ModuleOptionsRe/i )
		{
		    print STDERR "Line $.: Unknown option '$Opt'\n";
		    $Errors++;
		}
	    }
	}

	# Parameter
	elsif ( $Attribute eq "PARAMETER" )
	{
	    my $ParamName = "";
	    my $Default = "";
	    if ( $Value =~ /(\w+)(\s+=\s*(.*))?/ )
	    {
		$ParamName = $1;
		$Default = $3 if ( defined $3 );
	    }
	    else
	    {
		print STDERR
		    "$DescriptionFile line $.: No parameter name specified\n";
		$Errors++;
		last;
	    }
	    my $p = ();
	    my $OrigName = $ParamName;
	    $p->{Default} = $Default;

	    # For backward compatibility, mesage the old
	    # HAWKEYE_<NAME>_<PARAM>
	    # parameter names to just plain <PARAM>
	    my $Pat1 = "hawkeye_" . $Data->{DefaultName} . "_(\\w+)";
	    my $Pat2 = "hawkeye_[a-zA-Z]+_(\\w+)";
	    if ( $ParamName =~ /^$Pat1$/i )
	    {
		$ParamName = $1;
	    }
	    elsif ( $ParamName =~ /^$Pat2/i )
	    {
		$ParamName = $1;
	    }
	    $p->{Name} = $ParamName;
	    $p->{OrigName} = $OrigName;
	    $p->{Required} = 0;
	    my @Description;
	    while( <DESCRIPTION> )
	    {
		chomp;
		s/\s+$//;

		# Is it a keyword (ie the start of something else)?
		my $Key = $_; $Key =~ s/\s.*$//;
		if ( ( $_ eq "" ) || ( /^\#/ ) || ( $Key =~ /$KeyWordsRe/i ) )
		{
		    $p->{Description} = \@Description;
		    push ( @{$Data->{Parameters}}, $p );
		    $p = ();
		    redo READLINE;
		}

		# Parse flags, if provided
		elsif ( /^flags:\s*(.*)/i )
		{
		    foreach my $Flag ( split( /[\s+\,]+/, lc $1 ) )
		    {
			if ( $Flag eq "required" )
			{
			    $p->{Required} = 1;
			}
			else
			{
			    print STDERR "Line $.: Unknown flag '$Flag'\n";
			    $Errors++;
			}
		    }
		    next;
		}

		# Must be a description line; add it
		else
		{
		    s/$OrigName/$ParamName/ if ( $OrigName ne $ParamName );
		    push @Description, $_;
		}
	    }

	    # Store it
	    $p->{Description} = \@Description;
	    push (@{$Data->{Parameters}}, $p );
	    $p = ();

	    # Done
	    last;
	}

	# Unknown
	else
	{
	    print "Can't parse module description file".
		" '$DescriptionFile' line $.\n";
	    print "$Orig\n";
	    $Errors++;
	    last;
	}
    }
    close( DESCRIPTION );


    # For backward compatibility, message the old HAWKEYE_<NAME>_<PARAM>
    # parameter names to just plain <PARAM>
    # Clean up the description, too
    for my $Param ( @{$Data->{Parameters}} )
    {
	next if ( $Param->{Name} eq $Param->{OrigName} );
	foreach my $LineNo ( 0 .. $#{$Data->{Description}} )
	{
	    $Data->{Description}[$LineNo] =~
		s/$Param->{OrigName}/$Param->{Name}/;
	}
    }

    # Final checks
    if ( ! exists $Data->{ModuleFile} )
    {
	print STDERR "No module file specified\n";
	$Errors++;
    }
    if ( ! exists $Data->{Period} )
    {
	print STDERR "No period specified\n";
	$Errors++;
    }

    # Finally, fill in some defaults...
    my $Name = $Data->{ModuleFile};
    $Name = $Data->{DefaultName} if ( exists $Data->{DefaultName} );
    $Data->{Name} = $Name;

    # Prefix
    $Data->{Prefix} = $Name . "_" if ( ! exists $Data->{Prefix} );

    return $Errors;

} # ReadDescriptionFile()
# ******************************************************

# ******************************************************
# Install the module
# ******************************************************
sub InstallModule( $ )
{
    my $Data = shift;
    my $Name = $Data->{Name};

    # Should we install this?
    foreach my $Text ( @{$Data->{Description}} )
    {
	print "\t$Text\n";
    }
    # Only ask if the InstallAll option is off
    if ( ! $Config{InstallAll} )
    {
	print "  Do you wish to install this module? ";
	my $Answer = "";
	while( <> )
	{
	    chomp;
	    if ( /^[yn]/i )
	    {
		$Answer = lc($_);
		last;
	    }
	    print "  Please answer 'y' or 'n': ";
	}
	return 1 if ( $Answer ne "y" );
    }

    # Install the files..
    $| = 1;
    foreach my $File ( $Data->{ModuleFile}, @{$Data->{OtherFiles}} )
    {
	print "  File = '$File'\n";
	my $Cmd = "cp $File $Config{ModulesDir}";
	print "\t$File -> $Config{ModulesDir}...";
	system $Cmd;
	print "\n";
    }

    # Check to see if it's already configured
    my $Found = 0;
    my $JobString = Expand( $Config{CronJobsVar} );
    foreach my $Job ( split( /\s+/, $JobString ) )
    {
	my @Fields = split( /:/, $Job );
	if ( scalar @Fields >= 4 )
	{
	    if ( $Fields[0] eq $Name )
	    {
		$Found++;
		$Data->{Current}{Name} = shift @Fields;
		$Data->{Current}{Prefix} = shift @Fields;
		$Data->{Current}{Path} = shift @Fields;
		$Data->{Current}{Period} = shift @Fields;
		if ( scalar @Fields )
		{
		    @{$Data->{Current}{Options}} = @Fields;
		}
		else
		{
		    $#{@{$Data->{Current}{Options}}} = -1;
		}
		last;
	    }
	}
    }
    $Data->{Configured} = $Found;

    # Done
    return 0;

} # InstallModule( )
# ******************************************************

# ******************************************************
# Configure the module
# ******************************************************
sub ConfigureModule( $ )
{
    my $Data = shift;
    my $Name = $Data->{Name};
    my $NeedsConfig = $Config{AskAll};
    my $OldLineNum = -1;
    my $OldFileName = "";
    my $Errors = 0;

    # By default, nothing has changed.
    $Data->{ConfigChanged} = 0;

    # If we've already found this one, try to use the old values
    if ( $Data->{Configured} )
    {
	my $Match = uc( $Distribution . "_JOBS" ) . ".*\\s$Name:";
    FILE:
	for my $f ( keys %ConfigLines )
	{
	    for my $i ( 0 .. $#{$ConfigLines{$f}} )
	    {
		my $Line = $ConfigLines{$f}[$i];
		$Line =~ s/\#.*$//;
		if ( $Line =~ /$Match/ )
		{
		    $OldLineNum = $i;
		    $OldFileName = $f;
		    last FILE;
		}
	    }
	}

	my $Import = 0;
	if ( $Config{NoAsk} )
	{
	    $Import = 1;
	}
	else
	{
	    print "  Previous configuration for $Name found; import it [Y/n]? ";
	    $_ = <>;
	    $Import = /^n/i ? 0 : 1;
	}

	# Ok, import from the old
	if ( $Import )
	{
	    print "  Importing settings for $Name ...";
	    $Data->{Options} = $Data->{Current}{Options};
	    $Data->{Prefix}  = $Data->{Current}{Prefix};
	    $Data->{Period}  = $Data->{Current}{Period};

	    # UPdate the defaults with the old values
	    foreach my $Param ( @{$Data->{Parameters}} )
	    {
		my $ParamName =
		    uc( $Distribution . "_" . $Name . "_" . $Param->{Name} );
		my $Current = Expand( $ParamName );
		$Param->{Current} = $Current;
		$Param->{Default} = $Current
		    if ( ( defined $Current ) && ( $Current ne "" ) );
	    }
	    print "  Done\n";
	}
    }
    else
    {
	# Nothing to import; by definition modified!!
	$Data->{ConfigChanged}++;
    }

    # Give the user an update
    my @Required;
    print "  Logical name: $Name\n";
    print "  Options: " . join( " ", @{$Data->{Options}} ) . "\n";
    print "  ClassAd prefix: " . $Data->{Prefix} . "\n";
    print "  Parameters:\n";
    foreach my $Param ( @{$Data->{Parameters}} )
    {
	$Param->{String} = "<NONE>";
	if ( exists $Param->{Default} && $Param->{Default} ne "" )
	{
	    $Param->{String} = $Param->{Default};
	}
	print "    $Param->{Name} = $Param->{String}\n";
	if ( $Param->{Required} )
	{
	    if ( !exists $Param->{Default} || $Param->{Default} eq "" )
	    {
		push( @Required, $Param->{Name} );
		$NeedsConfig++;
	    }
	}
    }

    # Fill in the default parameter values
    foreach my $Param ( @{$Data->{Parameters}} )
    {
	next if ( ! exists $Param->{Default} );
	if ( ( exists $Param->{Current} ) &&
	     ( $Param->{Current} ne $Param->{Default} ) )
	{
	    $Data->{ConfigChanged}++;
	}
	$Param->{Value} = $Param->{Default};
    }

    # Fill in the location of the original config
    $Data->{OriginalConfigLines} = $OldLineNum;
    $Data->{OriginalConfigFile} = $OldFileName;

    # Check the results
    if ( $Config{NoAsk} )
    {
	# Done
	if ( $Data->{ConfigChanged} && ( $OldLineNum >= 0 ) )
	{
	    print "  Check original configuration lines around line ".
		"$OldLineNum\n";
	}
	return 1;
    }

    # Are we done?
    if ( $NeedsConfig )
    {
	print "  $NeedsConfig parameters require configuration; forcing\n";
    }
    else
    {
	print "  Would you like to change these settings (N/y): ";
	$_ = <>;
	$NeedsConfig = 1 if ( $_ =~ /^y/i );
    }

    # What name to give it?
    if ( $NeedsConfig )
    {
	print "  What logical name do you wish to use for this module".
	    " <default=$Name>: ";
	$_ = <>; chomp;
	if ( /\S/ )
	{
	    my $NewName = $_;
	    if ( $NewName ne $Name )
	    {
		$Data->{Name} = $Name = $NewName;
		$Data->{ConfigChanged}++;
	    }
	    print "  New name -> '$Name'\n";
	}
    }

    # Options
    if ( $NeedsConfig )
    {
	print "  Default options for $Name = " .
	    join( " ", @{$Data->{Options}} ) . "\n";

	# Get options from the user
	while( 1 )
	{
	    print "  What options would you like set ".
		"<enter = default; \"none\"; list>: ";
	    $_ = <>; chomp; s/^\s+//;
	    if ( $_ eq "none" )
	    {
		$#{@{$Data->{Options}}} = -1;
		last;
	    }
	    elsif ( $_ ne "" )
	    {
		my @Options = split;
		foreach my $Opt ( @Options )
		{
		    if ( ! ( $Opt =~ /$ModuleOptionsRe/i ) )
		    {
			print STDERR "  -> Unknown option '$Opt'\n";
			$Errors++;
		    }
		}
		if ( ! $Errors )
		{
		    $Data->{Options} = @Options;
		    $Data->{ConfigChanged}++;
		    last;
		}
	    }
	    else
	    {
		# Empty line; use defaults
		last;
	    }
	}
    }

    # Period
    if ( $NeedsConfig )
    {
	my $Default = "";
	my $DefString = "<no default>";
	if ( defined $Data->{Period} )
	{
	    $Default = $Data->{Period};
	    $DefString = "<enter = $Default>";
	}
	print "  Default period for $Name = $Default\n";
	while( 1 )
	{
	    print "  At what period should this module run " .
		"(s/m/h/d modifiers ok) $DefString? ";
	    $_ = <>; chomp;
	    last if ( ( $_ eq "" ) && ( $Default ne "" ) );
	    if ( /^(\d+[sSmMhHdD]?)$/)
	    {
		$Data->{Period} = $1;
		$Data->{ConfigChanged}++;
		last;
	    }
	    print "  '$_' is invalid.  Please enter a number ".
		"optionally followed by an s, an m, h, or a d\n";
	}
    }

    # Prefix
    if ( $Config{AskAll} )
    {
	print "  What prefix would you like for the ClassAd ".
	    "<enter = $Data->{Prefix}> ";
	$_ = <>; chomp;
	if ( $_ ne "" )
	{
	    $Data->{Prefix} = $_;
	    $Data->{ConfigChanged}++;
	}
    }

    # Parameter questions
    if ( $#{@{$Data->{Parameters}}} >= 0 )
    {
	if ( $NeedsConfig || scalar( @Required ) )
	{
	    print "  Parameters for module $Name:\n";
	    foreach my $Param ( @{$Data->{Parameters}} )
	    {
		next if ( !$NeedsConfig &&
			  !$Param->{Required} && $Param->{Value} eq "" );

		print "     $Param->{Name}\n";
		print "\t" . join( "\n\t", @{$Param->{Description}} );
		print "\n\tDefault: " . $Param->{String} . "\n";
		print "\tWhat value would you like for $Param->{Name}?".
		    " <enter for default> ";
		$_ = <>; chomp;

		$Param->{Value} = ( $_ eq "" ) ? $Param->{Default} : $_;
		$Data->{ConfigChanged}++;
	    }
	}
    }

    # Problems?
    if ( $Errors )
    {
	return 0;
    }
    return 1;

} # ConfigureModule()
# ******************************************************

# ******************************************************
# UpdateConfig
# ******************************************************
sub UpdateConfig( $ )
{
    my $Data = shift;
    my $Name = $Data->{Name};

    # Config changed?
    return 1 if ( ! $Data->{ConfigChanged} );

    # Do it
    print "  Updating config for $Name\n";
    push( @NewConfig, "" );
    push( @NewConfig, "##" );
    push( @NewConfig, "## Configuration for Module $Name" );
    foreach my $Text ( @{$Data->{Description}} )
    {
	push( @NewConfig, "##\t$Text" );
    }

    push( @NewConfig,
	  "$Config{CronJobsVar} = \$($Config{CronJobsVar}) " .
	  $Name . ":" . $Data->{Prefix} . ":" .
	  "\$(MODULES)/" . $Data->{ModuleFile} . ":" .
	  $Data->{Period} . ":" . join(":", @{$Data->{Options}} ) );
    push( @NewConfig, "##  Parameters for module $Name:" );
    foreach my $Param ( @{$Data->{Parameters}} )
    {
	push( @NewConfig, "##  $Param->{Name}" );
	foreach my $Text ( @{$Param->{Description}} )
	{
	    push( @NewConfig, "##    $Text" );
	}
	my $Default= (defined $Param->{Default} ) ? $Param->{Default} : "";
	push( @NewConfig, "##    Default: $Default" );

	my $ParamName = uc( $Config{CronName} . "_" . $Name . "_"  . $Param->{Name} );
	if ( defined $Param->{Value} )
	{
	    push( @NewConfig, "$ParamName = $Param->{Value}" );
	}
	else
	{
	    push( @NewConfig, "# $ParamName =" );
	}
	push( @NewConfig, "##" );
    }

    # Check these lines
    push( @NewConfig, "##" );
    if ( $Data->{OriginalConfigLines} >= 0 )
    {
	my $LineNo = $Data->{OriginalConfigLines} + 1;
	my $File = $Data->{OriginalConfigFile} + 1;
	my $Text = "## Check original configuration around line $LineNo "
	       . "in $File";
	push( @NewConfig, $Text );

    }
    push( @NewConfig, "## End of Configuration for Module $Name" );
    push( @NewConfig, "##" );

    return 1;

} # UpdateConfig()
# ******************************************************

# ******************************************************
# Write the new config file
# ******************************************************
sub WriteConfig( )
{
    my $File = $Config{ConfigFile};
    my $TmpFile = "$File.tmp.$$";
    open( TMP, ">$TmpFile" ) || die "Can't create temp config '$TmpFile'";

    my $EmacsLocal = 0;
    foreach ( @{$ConfigLines{$File}} )
    {
	if ( /\#\#\# Local Variables:/ )
	{
	    $EmacsLocal = 1;
	    push( @NewConfig, "" );
	    push( @NewConfig, $_ );
	    next;
	}
	if ( $EmacsLocal )
	{
	    if ( /\#\#\#/ )
	    {
		push( @NewConfig, $_ );
		$EmacsLocal = 0 if ( /End:/ );
		next;
	    }
	    else
	    {
		$EmacsLocal = 0;
	    }
	}
	print TMP "$_\n";
    }
    foreach ( @NewConfig )
    {
	print TMP "$_\n";
    }
    close( TMP );

    # Ask the user unless they explicietly asked us to overwrite it
    my $OverWrite = $Config{UpdateConfig};
    if ( ! $OverWrite )
    {
	if ( -f $Config{ConfigFile} )
	{
	    print "About to overwrite $Config{ConfigFile}; ok? ";
	    $OverWrite = 1 if ( <> =~ /^y/ );
	}
	else
	{
	    $OverWrite = 1;
	}
    }

    # OverWrite it?
    if ( $OverWrite )
    {
	unlink( $Config{ConfigFile} );
	rename( $TmpFile, $Config{ConfigFile} );
	print "\n$Config{ConfigFile} updated\n";
    }
    else
    {
	print "New config in $TmpFile\n";
    }

    return 1;

} # WriteConfig()
# ******************************************************

# ******************************************************
# Process a line from a config file
# ******************************************************
sub ProcessConfigLine( $ )
{
    my $Line = shift;

    $Line =~ s/^\s+//;
    $Line =~ s/\s+$//;
    return 0 if ( $Line eq "" ) ;

    # MACRO = value
    if ( $Line =~ /^(\S+)\s*=\s*(.+)/ )
    {
	my $Macro = uc( $1 );
	my $Value = $2;

	if ( exists $ConfigMacros{$Macro} )
	{
	    my $CurValue = $ConfigMacros{$Macro};
	    $Value =~ s/\$\($Macro\)/$CurValue/g;
	}
	$ConfigMacros{$Macro} = $Value;
    }
    elsif ( $Line =~ /^(\S+)\s*=$/ )
    {
	my $Macro = uc( $1 );
	$ConfigMacros{$Macro} = "";
    }
}


# ******************************************************
# Expand a macro from the config file
# ******************************************************
sub Expand( $ )
{
    my $Var = shift;

    # One more check
    return undef if ( ! exists ( $ConfigMacros{$Var} ) );

    # Now, expand it out...
    my $Value = $ConfigMacros{$Var};
    while( $Value =~ /(.*)\$\((\w+)\)(.*)/ )
    {
	if ( $2 eq $Var )
	{
	    $Value = $1 . $3;
	}
	elsif ( exists ( $ConfigMacros{$2} ) )
	{
	    $Value = $1 . $ConfigMacros{$2} . $3;
	    last if ( $2 eq $Var );
	}
	elsif ( exists ( $ENV{$2} ) )
	{
	    $Value = $1 . $ENV{$2} . $3;
	    last if ( $2 eq $Var );
	}
	else
	{
	    print STDERR "Warning: Unable to expand $Value\n";
	    last;
	}
    }
    $Value;

} # Expand()
# ******************************************************

# ******************************************************
# Dump out usage
# ******************************************************
sub Usage ( $ )
{
    my $Unknown = shift;

    print "$Program: unknown option '$Unknown'\n" if ( $Unknown ne "" );
    printf "usage: $Program [options] [files]\n";
    print "use '-h' for more help\n";
    exit 1;

} # usage ()
# ******************************************************

# ******************************************************
# Dump out help
# ******************************************************
sub Help ( )
{
    my ($opt, $text);

    printf "usage: $Program [options] [files]\n";
    foreach $opt (sort {lc($a) cmp lc($b) } keys %Options)
    {
	printf ("  %15s : %-40s\n", $opt, $Options{$opt} );
    }
    exit 0;

} # help ()
# ******************************************************
