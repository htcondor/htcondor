#! /usr/bin/perl -w
use strict;
$| = 1;

# Prototypes
sub Main( );
sub CommandLine( @ );
sub FindConfigFile( );
sub ReadConfigFile( );
sub ReadDataFile( $$ );
sub InstallModules( );
sub InstallModule( $ );
sub ConfigureModule( $ );
sub ProcessConfigLine( $ );
sub WriteConfig( );
sub Expand( $ );
sub Usage ( $ );
sub Help ( );

# ******************************************************
# Command line options
# ******************************************************
my $Program = "hawkeye_install_module";
my %Options =
    (
     "[-d=dir]"		=> "Specify modules directory",
     "[-c=file]"	=> "Specify Hawkeye config file",
     "[-n]"		=> "Don't update the config file",
     "[-m]"		=> "Manual mode; asks lots of questions",
     "[-a]"		=> "Ask before installing each module",
     "File [File..]"	=> "List of module files to install",
     #"[-v]"		=> "Verbose",
     "[-h]"		=> "Dump help",
    );

# Hash of directories & files
my %Config = (
	      HawkeyeDir => "",
	      HawkeyeConfig => "",
	      ModulesDir => "",
	      UpdateConfig => 1,
	      UseDefaults => 1,
	      InstallAll => 1,
	      Startd => -1,
	      );
my %ConfigMacros;
my @ConfigLines;

# Valid "Options"
my @ModuleOptions = qw ( continuous kill nokill );
my $ModuleOptionsRe =
    "(" . join( ")|(", @ModuleOptions ) . ")";

# "Main" Logic
if ( ! exists $ENV{PWD} )
{
    $ENV{PWD} = `/bin/pwd`; chomp $ENV{PWD};
}
CommandLine( @ARGV );
$#ARGV = -1;
$| = 1;

# Find the config file to use
$ENV{HAWKEYE_CONFIG} = $Config{HawkeyeConfig} if ( ! exists $ENV{HAWKEYE_CONFIG} );
FindConfigFile( );

# Read the config file
ReadConfigFile( );

# Install the modules
InstallModules( );

# end of "main"
# ******************************************************

# ******************************************************
# Parse the command line, etc.
# ******************************************************
sub CommandLine( @ )
{
    foreach my $Arg ( @_ )
    {
	# Speicfy modules directory
	if ( $Arg =~ /^-d=(.+)/ )
	{
	    die "Directory '$1' does not exist" if ( ! -d $1 );
	    $Config{ModulesDir} = $1;
	}
	# Speicify config file
	elsif ( $Arg =~ /-c=(.+)/ )
	{
	    die "Config file '$1' does not exist" if ( ! -f $1 );
	    my $File = $1;
	    if ( ! $File =~ /^\// )
	    {
		$File = $ENV{PWD} . "/$File";
	    }
	    $Config{HawkeyeConfig} = $File;
	}
	# No config update
	elsif ( $Arg eq "-n")
	{
	    $Config{UpdateConfig} = 0;
	}
	# "Ask" mode
	elsif ( $Arg eq "-a" )
	{
	    $Config{InstallAll} = 0;
	}
	# Manual mode
	elsif ( $Arg eq "-m" )
	{
	    $Config{InstallAll} = 0;
	    $Config{UseDefaults} = 0;
	}
	elsif ( $Arg =~ /^-h/ )
	{
	    Help( );
	    exit 0;
	}
	elsif ( $Arg =~ /^-/ )
	{
	    Usage( $Arg );
	    exit( 1 );
	}
	else
	{
	    if ( ! -f $Arg )
	    {
		print STDERR "Warning: Can't find $Arg\n";
		next;
	    }
	    # Make sure it's absolute
	    if ( $Arg =~ /^\// )
	    {
		push( @{$Config{Modules}}, $Arg );
	    }
	    else
	    {
		push( @{$Config{Modules}}, $ENV{PWD} . "/$Arg" );
	    }
	}
    }

    # Any modules to install?
    if ( $#{@{$Config{Modules}}} < 0 )
    {
	print STDERR "No modules specified\n";
	Usage( "" );
	exit 1;
    }

} # CommandLine( )
# ******************************************************

# ******************************************************
# Find the configuration file to use
# ******************************************************
sub FindConfigFile( )
{

    # Check the config env variable...
    if ( ( $Config{HawkeyeConfig} eq "" ) && ( exists $ENV{HAWKEYE_CONFIG} ) )
    {
	warn "$ENV{HAWKEYE_CONFIG} (from ENV) does not exist!"
	    if ( ! -f $ENV{HAWKEYE_CONFIG} );
	$Config{HawkeyeConfig} = $ENV{HAWKEYE_CONFIG};
    }

    # Fallbacks...
    my @FallbackConfigs = [ "/home/hawkeye", ];
    unshift @FallbackConfigs, $ENV{HAWKEYE_ROOT_DIR}
	if ( exists $ENV{HAWKEYE_ROOT_DIR} );
    foreach my $TempConfig ( @FallbackConfigs )
    {
	if (  ( $Config{HawkeyeConfig} eq "" ) && ( -f $TempConfig )  )
	{
	    $Config{HawkeyeConfig}{HawkeyeConfig} = $TempConfig;
	}
    }

    # Finally, let's go check the config
    if ( $Config{HawkeyeConfig} eq "" )
    {
	print STDERR "No config found\n";
	Usage( "" );
	print STDERR "\tOr, set the HAWKEYE_CONFIG env variable\n";
	exit 1;
    }

} # FindConfigFile()
# ******************************************************

# ******************************************************
# Read the config file
# ******************************************************
sub ReadConfigFile( )
{
    print "Reading config file $Config{HawkeyeConfig}...";
    open( CONFIG, $Config{HawkeyeConfig} ) ||
	die "Can't read config @ $Config{HawkeyeConfig}";
    my $Line = "";
    while( <CONFIG> )
    {
	chomp;
	push @ConfigLines, $_;
	s/^\s+//;
	s/\s+$//;

	# Comment?
	if ( /\#/ )
	{
	    ProcessConfigLine( $Line ) if ( $Line ne "" );
	    $Line = "";
	}

	# Continuation?
	elsif ( /(.*)\\$/ )
	{
	    $Line = ( $Line eq "" ) ? $1 : $Line . " " . $1;
	}

	# "Normal" line
	else
	{
	    $Line = ( $Line eq "" ) ? $_ : $Line . " " . $_;
	    ProcessConfigLine( $Line ) if ( $Line ne "" );
	    $Line = "";
	}
    }
    close( CONFIG );
    print "Done\n";

    # Ok, let's find the by evaluating the config
    if ( $Config{ModulesDir} eq "" )
    {
	my $Tmp = Expand( "MODULES" );
	$Config{ModulesDir} = $Tmp if ( ( defined $Tmp ) && ( -d $Tmp ) );
    }
    # Last resort
    if ( $Config{ModulesDir} eq "" )
    {
	if ( $Config{HawkeyeConfig} =~ /(.*)\/hawkeye_config/ )
	{
	    my $Tmp = $1 . "/modules";
	    $Config{ModulesDir} = $Tmp if ( -d $Tmp );
	}
    }

    # Give up...
    die "Unable to find modules directory\n"
	if ( $Config{ModulesDir} eq "" );


    # Add basic things to the config if they're not defined...
    my $CronName = Expand( "STARTD_CRON_NAME" );
    if ( ! defined $CronName )
    {
	push @ConfigLines, "STARTD_CRON_NAME = Hawkeye";
	$ConfigMacros{STARTD_CRON_NAME} = "Hawkeye";
    }
    my $Modules = Expand( "MODULES" );
    if ( ! defined $Modules )
    {
	my $Value = $Config{HawkeyeConfig};
	my $Hawkeye = Expand( "HAWKEYE" );
	if ( defined $Hawkeye )
	{
	    $Hawkeye =~ s/\//\\\//g;
	    $Value = "\$(HAWKEYE)/$1" if ( $Value =~ /^$Hawkeye\/(.*)/ );
	}
	push @ConfigLines, "MODULES = $Value";
	$ConfigMacros{MODULES} = $Value;
    }
    my $Jobs = Expand( "HAWKEYE_JOBS" );
    if ( ! defined $Jobs )
    {
	push @ConfigLines, "HAWKEYE_JOBS = ";
	$ConfigMacros{HAWKEYE_JOBS} = "";
    }

    print "Found modules directory '$Config{ModulesDir}'\n";

} # ReadConfigFile
# ******************************************************

# ******************************************************
# Configure & Install all Modules
# ******************************************************
sub InstallModules ( )
{
    my $TmpDir = "/tmp/$$";
    my $OrigDir = $ENV{PWD};
    die "$TmpDir already exists!" if ( -d $TmpDir );
    mkdir( $TmpDir, 0700 ) || die "Can't mkdir '$TmpDir'";
    chdir $TmpDir || die "Can't chdir to $TmpDir";

    # Summary info
    my @Ok;
    my @Failed;

    # Walk through the list of modules...
    print "Installing modules\n";
    foreach my $Module ( @{$Config{Modules}} )
    {
	die "$Module does not exist" if ( ! -f $Module );
	my $Cmd = "gzip -d < $Module | tar xvfp -";
	if ( system "$Cmd 2>&1 > /dev/null" )
	{
	    warn "Error extracting '$Module'\n";
	    next;
	}

	opendir( DIR, $TmpDir ) || die "Can't read dir $TmpDir";
	my @Files = grep { /^[^\.]/ } readdir( DIR );
	closedir( DIR );

	# Find the meta-data ".hawk" file...
	my @DatFiles = grep { /\.hawk$/ } @Files;
	if ( $#DatFiles < 0 )
	{
	    print STDERR "$Module does not appear to be a valid module file\n";
	    system "/bin/rm *";
	    next;
	}

	# Loop through the list of modules to install...
	foreach my $Data ( @DatFiles )
	{
	    my %ModuleData;

	    # Read the data file for this module..
	    my $Errors = ReadDataFile( $Data, \%ModuleData );
	    if ( $Errors )
	    {
		print "Errors encountered in data file; skipping $Module\n";
		push @Failed, $Module;
		next;
	    }

	    # Get it's name..
	    my $Name = $ModuleData{Name};
	    print "\n\nModule $Name:\n";

	    # Install it?
	    my $Status = InstallModule( \%ModuleData );
	    if ( $Status )
	    {
		push @Failed, $Module if ( $Status < 0 );
		next;
	    }

	    # Enable it?
	    if ( ! $Config{InstallAll} )
	    {
		print "  Do you wish to enable this module? ";
		my $Answer = "";
		while( <> )
		{
		    chomp;
		    if ( /^[yn]/i )
		    {
			$Answer = lc($_);
			last;
		    }
		    print "  Please answer 'y' or 'n': ";
		}
		next if ( $Answer ne "y" );
	    }

	    # Configure it?
	    if ( ! $Config{UseDefaults} )
	    {
		$Status = ConfigureModule( \%ModuleData );
	    }
	    else
	    {
		$Status = ConfigureModuleDefaults( \%ModuleData );
	    }

	    # Add to the failed list?
	    if ( $Status )
	    {
		push @Failed, $Module if ( $Status < 0 );
		next;
	    }

	    # Update the config file
	    $Status = UpdateConfig( \%ModuleData );

	    # Add to the failed list?
	    if ( $Status < 0 )
	    {
		push @Failed, $Module
	    }
	    elsif ( $Status == 0 )
	    {
		push @Ok, $Name;
	    }
	}

	# Clean up
	system( "/bin/rm *" );

    }

    # Create the new config file
    WriteConfig( );

    # Final clean-up
    chdir $OrigDir;
    system "/bin/rm -fr $TmpDir";

    # Summary
    if ( $#Ok >= 0 )
    {
	print "Fully installed modules:\n";
	foreach my $Tmp ( @Ok )
	{
	    print "   $Tmp\n";
	}
    }
    if ( $#Failed >= 0 )
    {
	print "Failed modules:\n";
	foreach my $Tmp ( @Failed )
	{
	    print "   $Tmp\n";
	}
    }


} # InstallModules()
# ******************************************************

# ******************************************************
# Read the module data file
# ******************************************************
sub ReadDataFile( $$ )
{
    my $DataFile = shift;
    my $Data = shift;

    if ( ! open( DATA, $DataFile ) )
    {
	print "Can't read data file '$DataFile'; skipping\n";
	return -1;
    }

    # List of keywords..
    my @KeyWords =
	qw ( modulefiles default options parameter period version );
    my $KeyWordsRe =
	"^(" . join( ":)|(", @KeyWords ) . ":)";
    #print "KeyWordsRe='$KeyWordsRe'\n";

    # Read the data file
    my $Errors = 0;
  READLINE:
    while( <DATA> )
    {
	chomp;
	my $Orig = $_;
	s/\#.*//;
	s/^\s+//;
	s/\s+$//;
	next if ( $_ eq "" );

	# Parse the line..

	# Module files
	if ( /MODULEFILES:\s*(.+)/i )
	{
	    my @Files = split( /\s+/, $1 );
	    foreach my $File ( @Files )
	    {
		if ( ! -f $File )
		{
		    print STDERR
			"Can't find '$File' specified in module line $.\n";
		    $Errors++;
		}
	    }

	    # Store it all away...
	    $Data->{ModuleFile} = shift @Files
		if ( ! exists $Data->{ModuleFiles} );
	    push( @{$Data->{OtherFiles}}, \@Files )
		if ( $#Files >= 0 );
	    $#Files = -1;
	}

	# Description
	elsif ( /DESCRIPTION:/i )
	{

	    # Read the module description
	    my @Description;
	    while( <DATA> )
	    {
		chomp;
		s/\s+$//;
		my $Key = $_; $Key =~ s/\s.*$//;
		if ( ( $_ eq "" ) || ( /^\#/ ) || ( $Key =~ /$KeyWordsRe/i ) )
		{
		    #print "Key '$Key' matches\n";
		    $Data->{Description} = \@Description;
		    redo READLINE;
		}
		push @Description, $_;
	    }
	}

	# Default name
	elsif ( /DEFAULT:\s*(\S+)/i )
	{
	    $Data->{DefaultName} = $1;
	}

	# Prefix
	elsif ( /PREFIX:\s*(\S+)/i )
	{
	    $Data->{Prefix} = $1;
	}

	# Version (stored, but not used)
	elsif ( /VERSION:\s*(\S+)/i )
	{
	    $Data->{Version} = $1;
	}

	# Period
	elsif ( /PERIOD:\s*((\d+)[sSmMhHdD]?)/i )
	{
	    if ( $2 <= 0 )
	    {
		print STDERR "Period must be > 0\n";
		$Errors++;
	    }
	    else
	    {
		$Data->{Period} = $1;
	    }
	}

	# Options
	elsif ( /OPTIONS:\s*(.*)/i )
	{
	    @{$Data->{Options}} = split( /\s+/, $1 );
	    foreach my $Opt ( @{$Data->{Options}} )
	    {
		if ( ! $Opt =~ /$ModuleOptionsRe/ )
		{
		    print STDERR "Line $.: Unknown option '$Opt'\n";
		    $Errors++;
		}
	    }
	}

	# Parameter
	elsif ( /PARAMETER:\s*(\S+)(\s+=(.*))?/i )
	{
	    my $p = ();
	    $p->{Name} = $1;
	    $p->{Default} = $3 if ( defined $3 );
	    my @Description;
	    while( <DATA> )
	    {
		chomp;
		s/\s+$//;
		my $Key = $_; $Key =~ s/\s.*$//;
		if ( ( $_ eq "" ) || ( /^\#/ ) || ( $Key =~ /$KeyWordsRe/i ) )
		{
		    $p->{Description} = \@Description;
		    push ( @{$Data->{Parameters}}, $p );
		    $p = ();
		    redo READLINE;
		}
		push @Description, $_;
	    }

	    # Store it
	    $p->{Description} = \@Description;
	    push (@{$Data->{Parameters}}, $p );
	    $p = ();

	    # Done
	    last;
	}

	# Unknown
	else
	{
	    print "Can't parse dat file '$DataFile' line $.\n";
	    print "$Orig\n";
	    $Errors++;
	}
    }
    close( DATA );

    # Final checks
    if ( ! exists $Data->{ModuleFile} )
    {
	print STDERR "No module file specified\n";
	$Errors++;
    }
    if ( ! exists $Data->{Period} )
    {
	print STDERR "No period specified\n";
	$Errors++;
    }

    # Finally, fill in some defaults...
    my $Name = $Data->{ModuleFile};
    $Name = $Data->{DefaultName} if ( exists $Data->{DefaultName} );
    $Data->{Name} = $Name;

    # Prefix
    $Data->{Prefix} = $Name . "_" if ( ! exists $Data->{Prefix} );

    return $Errors;

} # ReadDataFile()
# ******************************************************

# ******************************************************
# Install the module
# ******************************************************
sub InstallModule( $ )
{
    my $Data = shift;
    my $Name = $Data->{Name};

    # Should we install this?
    foreach my $Text ( @{$Data->{Description}} )
    {
	print "\t$Text\n";
    }
    # Only ask if the InstallAll option is off
    if ( ! $Config{InstallAll} )
    {
	print "  Do you wish to install this module? ";
	my $Answer = "";
	while( <> )
	{
	    chomp;
	    if ( /^[yn]/i )
	    {
		$Answer = lc($_);
		last;
	    }
	    print "  Please answer 'y' or 'n': ";
	}
	return 1 if ( $Answer ne "y" );
    }

    # Install the files..
    $| = 1;
    foreach my $File ( $Data->{ModuleFile}, @{$Data->{OtherFiles}} )
    {
	print "File = '$File'\n";
	my $Cmd = "cp $File $Config{ModulesDir}";
	print "\t$File -> $Config{ModulesDir}...";
	system $Cmd;
	print "\n";
    }

    # Check to see if it's already configured
    my $Found = 0;
    my $JobString = Expand( "HAWKEYE_JOBS" );
    foreach my $Job ( split( /\s+/, $JobString ) )
    {
	if ( $Job =~ /([^:]+):([^:]*):([^:]+):([^:]+)(:?).*/ )
	{
	    $Found++ if ( $1 eq $Name );
	}
    }
    $Data->{Configured} = $Found;

    # Done
    return 0;

} # InstallModule( )
# ******************************************************

# ******************************************************
# Configure the module
# ******************************************************
sub ConfigureModule( $ )
{
    my $Data = shift;
    my $Name = $Data->{Name};

    # Is it already configured?
    if ( $Data->{Configured} )
    {
	$Data->{ConfigChanged} = 0;
	print "  $Name appears to be previously configured; good\n";
	return 0;
    }

    # Note modified config...
    $Data->{ConfigChanged} = 1;

    # What name to give it?
    print "  What logical name do you wish to use <default=$Name>: ";
    $_ = <>; chomp;
    if ( /\S/ )
    {
	$Data->{Name} = $Name = $_;
	print "  New name -> '$Name'\n";
    }

    # Options
    print "  Default options for $Name = " . join( " ", @{$Data->{Options}} ) . "\n";
    while( 1 )
    {
	print "  What options would you like set ".
	    "<enter = default; \"none\"; list>: ";
	$_ = <>; chomp; s/^\s+//;
	if ( $_ eq "none" )
	{
	    $#{@{$Data->{Options}}} = -1;
	    last;
	}
	elsif ( $_ ne "" )
	{
	    @{$Data->{Options}} = split;
	    my $Errors = 0;
	    foreach my $Opt ( @{$Data->{Options}} )
	    {
		if ( ! ( $Opt =~ /$ModuleOptionsRe/i ) )
		{
		    print STDERR "  -> Unknown option '$Opt'\n";
		    $Errors++;
		}
	    }
	    last if ( ! $Errors );
	}
	else
	{
	    # Empty line; use defaults
	    last;
	}
    }

    # Period
    my $Default = "";
    my $DefString = "<no default>";
    if ( defined $Data->{Period} )
    {
	$Default = $Data->{Period};
	$DefString = "<enter = $Default>";
    }
    print "  Default period for $Name = $Default\n";
    while( 1 )
    {
	print "  At what period should this module run " .
	    "(s/m/h/d modifiers ok) $DefString? ";
	$_ = <>; chomp;
	last if ( ( $_ eq "" ) && ( $Default ne "" ) );
	if ( /^(\d+[sSmMhHdD]?)$/)
	{
	    $Data->{Period} = $1;
	    last;
	}
	print "  '$_' is invalid.  Please enter a number ".
	    "optionally followed by an s, an m, h, or a d\n";
    }

    # Prefix
    print "  What prefix would you like for the ClassAd <enter = $Data->{Prefix}> ";
    $_ = <>; chomp;
    if ( $_ ne "" )
    {
	$Data->{Prefix} = $_;
    }

    # Parameter questions
    if ( $#{@{$Data->{Parameters}}} >= 0 )
    {
	print "  Parameters for module $Name:\n";
	foreach my $Param ( @{$Data->{Parameters}} )
	{
	    print "     $Param->{Name}\n";
	    print "\t" . join( "\n\t", @{$Param->{Description}} );
	    print "\n\tDefault: " .
		( $Param->{Default} eq "" ? "<NONE>" : $Param->{Default} ) .
		    "\n";
	    print "\tWhat value would you like for $Param->{Name}?".
		" <enter for default> ";
	    $_ = <>; chomp;
	    $Param->{Value} = ( $_ eq "" ) ? $Param->{Default} : $_;
	}
    }

    return 0;

} # ConfigureModule()
# ******************************************************

# ******************************************************
# Configure the module for defaults
# ******************************************************
sub ConfigureModuleDefaults( $ )
{
    my $Data = shift;
    my $Name = $Data->{Name};

    # Already configured?
    if ( $Data->{Configured} )
    {
	$Data->{ConfigChanged} = 0;
	print "  $Name appears to be previously configured; good\n";
	return 0;
    }

    # Fill in the default parameter values
    foreach my $Param ( @{$Data->{Parameters}} )
    {
	$Param->{Value} = $Param->{Default};
    }
    $Data->{ConfigChanged} = 1;

    # Done
    return 0;

} # ConfigureModuleDefaults()

# ******************************************************
# UpdateConfig
# ******************************************************
sub UpdateConfig( $ )
{
    my $Data = shift;
    my $Name = $Data->{Name};

    # Config changed?
    return 0 if ( ! $Data->{ConfigChanged} );

    # Do it
    print "  Updating config for $Name\n";
    push( @ConfigLines, "" );
    push( @ConfigLines, "##" );
    push( @ConfigLines, "## Configuration for Module $Name" );
    foreach my $Text ( @{$Data->{Description}} )
    {
	push( @ConfigLines, "##\t$Text" );
    }
    push( @ConfigLines,
	  "HAWKEYE_JOBS = \$(HAWKEYE_JOBS) " .
	  $Name . ":" . $Data->{Prefix} . ":" .
	  "\$(MODULES)/" . $Data->{ModuleFile} . ":" .
	  $Data->{Period} . ":" . join(":", @{$Data->{Options}} ) );
    push( @ConfigLines, "##  Parameters for module $Name:" );
    foreach my $Param ( @{$Data->{Parameters}} )
    {
	push( @ConfigLines, "##  $Param->{Name}" );
	foreach my $Text ( @{$Param->{Description}} )
	{
	    push( @ConfigLines, "##    $Text" );
	}
	my $Default= (defined $Param->{Default} ) ? $Param->{Default} : "";
	push( @ConfigLines, "##    Default: $Default" );

	if ( defined $Param->{Value} )
	{
	    push( @ConfigLines, "$Param->{Name} = $Param->{Value}" );
	}
	else
	{
	    push( @ConfigLines, "# $Param->{Name} =" );
	}
    }

    return 0;

} # UpdateConfig()
# ******************************************************

# ******************************************************
# Write the new config file
# ******************************************************
sub WriteConfig( )
{
    my $TmpFile = "/tmp/config.$$";
    open( TMP, ">$TmpFile" ) || die "Can't create temp config '$TmpFile'";
    foreach my $Line ( @ConfigLines )
    {
	print TMP "$Line\n";
    }
    close( TMP );

    # Write it?
    if ( $Config{UpdateConfig} )
    {
	system( "/bin/cp $TmpFile $Config{HawkeyeConfig}" );
	print "\n$Config{HawkeyeConfig} updated\n";
    }
    else
    {
	system( "/bin/cp $TmpFile $Config{HawkeyeConfig}.$$" );
	print "New config in $Config{HawkeyeConfig}.$$\n";
    }

} # WriteConfig()
# ******************************************************

# ******************************************************
# Expand a macro from the config file
# ******************************************************
sub ProcessConfigLine( $ )
{
    my $Line = shift;

    $Line =~ s/^\s+//;
    $Line =~ s/\s+$//;
    return 0 if ( $Line eq "" ) ;

    # MACRO = value
    if ( $Line =~ /^(\S+)\s*=\s*(.+)/ )
    {
	my $Macro = uc( $1 );
	my $Value = $2;
	$ConfigMacros{$Macro} = $Value;
    }
    elsif ( $Line =~ /^(\S+)\s*=$/ )
    {
	my $Macro = uc( $1 );
	$ConfigMacros{$Macro} = "";
    }
}

# ******************************************************
# Expand a macro from the config file
# ******************************************************
sub Expand( $ )
{
    my $Var = shift;

    # No dice; try getting it from the startd
    if ( ! exists ( $ConfigMacros{$Var} ) )
    {
	# Can we / should we?
	if ( $Config{Startd} )
	{
	    print "Trying to contact the startd to expand '$Var'...\n";
	    my $Cmd = "hawkeye_config_val -startd MODULES";
	    my $Tmp = `$Cmd`;

	    if ( $Tmp eq "" )
	    {
		$Config{Startd} = 0;
	    }
	    else
	    {
		# Note that the startd is available..
		$Config{Startd} = 1;
		if ( $Tmp ne "Not defined" )
		{
		    $ConfigMacros{ModulesDir} = $Tmp;
		    return $Tmp;
		}
	    }
	}
    }

    # One more check
    return undef if ( ! exists ( $ConfigMacros{$Var} ) );

    # Now, expand it out...
    my $Value = $ConfigMacros{$Var};
    while( $Value =~ /(.*)\$\(([^\$]+)\)(.*)/ )
    {
	if ( exists ( $ConfigMacros{$2} ) )
	{
	    $Value = $1 . $ConfigMacros{$2} . $3;
	    last if ( $2 eq $Var );
	}
	elsif ( exists ( $ENV{$2} ) )
	{
	    $Value = $1 . $ENV{$2} . $3;
	    last if ( $2 eq $Var );
	}
	else
	{
	    print STDERR "Warning: Unable to expand $Value\n";
	    last;
	}
    }
    $Value;

} # Expand()
# ******************************************************

# ******************************************************
# Dump out usage
# ******************************************************
sub Usage ( $ )
{
    my $Unknown = shift;

    print "$Program: unknown option '$Unknown'\n" if ( $Unknown ne "" );
    printf "usage: $Program %s\n", join (" ", sort keys %Options);
    print "use '-h' for more help\n";
    exit 1;

} # usage ()
# ******************************************************

# ******************************************************
# Dump out help
# ******************************************************
sub Help ( )
{
    my ($opt, $text);

    printf "usage: $Program %s\n", join (" ", sort keys %Options);
    foreach $opt (sort {lc($a) cmp lc($b) } keys %Options)
    {
	printf ("  %15s : %-40s\n", $opt, $Options{$opt} );
    }
    exit 0;

} # help ()
# ******************************************************
