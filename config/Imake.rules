/***************************************************************
 *
 * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
 * University of Wisconsin-Madison, WI.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you
 * may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 * 
 *    http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ***************************************************************/

/* --------------------------------------------------------------------- */
/* This section is for helper utility functions and shared common rules and
	definitions. */

#define EXECUTABLE_MODE		0755
#define OBJECT_MODE		0644
#define TEXT_MODE		OBJECT_MODE

.SUFFIXES: .c .C .cpp .f .f90

.c.o:
	$(CC) $(CFLAGS) -c $< -o $@
	$(PostCompileHook) --pwd=$(shell pwd) --arch=$(ARCHITECTURE) --platform=$(PLATFORM) --distro=$(DISTRIBUTION) --source-file=$< --obj-file=$@

.cpp.o:
	$(CPlusPlus) $(C_PLUS_FLAGS) -c $< -o $@
	$(PostCompileHook) --pwd=$(shell pwd) --arch=$(ARCHITECTURE) --platform=$(PLATFORM) --distro=$(DISTRIBUTION) --source-file=$< --obj-file=$@

.C.o:
	$(CPlusPlus) $(C_PLUS_FLAGS) -c $< -o $@
	$(PostCompileHook) --pwd=$(shell pwd) --arch=$(ARCHITECTURE) --platform=$(PLATFORM) --distro=$(DISTRIBUTION) --source-file=$< --obj-file=$@

.f.o:
	$(Fortran) $(FFLAGS) -c $< -o $@
	$(PostCompileHook) --pwd=$(shell pwd) --arch=$(ARCHITECTURE) --platform=$(PLATFORM) --distro=$(DISTRIBUTION) --source-file=$< --obj-file=$@

.f90.o:
	$(Fortran) $(FFLAGS) -c $< -o $@
	$(PostCompileHook) --pwd=$(shell pwd) --arch=$(ARCHITECTURE) --platform=$(PLATFORM) --distro=$(DISTRIBUTION) --source-file=$< --obj-file=$@

#if HAVE_CC_PIC_FLAG
/* These rules are a bit scary, basically when we build a shared library of
	something, we adjust the filename from foo.o to foo-pic.o, and then use
	these particular suffix rules to compile them mixing in the
	shared library goo we need. Also, sometimes we can't build these files with
	-fstack-protect, so we turn that off on some platforms. */
%-pic.o: %.c
	$(CC) $(CC_PIC_FLAGS) $(CFLAGS) $(GCC_NO_STACK_PROTECTOR) -c $< -o $@

%-pic.o: %.cpp
	$(CPlusPlus) $(CC_PIC_FLAGS) $(C_PLUS_FLAGS) $(GCC_NO_STACK_PROTECTOR) -c $< -o $@
	$(PostCompileHook) --pwd=$(shell pwd) --arch=$(ARCHITECTURE) --platform=$(PLATFORM) --distro=$(DISTRIBUTION) --source-file=$< --obj-file=$@

%-pic.o: %.C
	$(CPlusPlus) $(CC_PIC_FLAGS) $(C_PLUS_FLAGS) $(GCC_NO_STACK_PROTECTOR) -c $< -o $@
	$(PostCompileHook) --pwd=$(shell pwd) --arch=$(ARCHITECTURE) --platform=$(PLATFORM) --distro=$(DISTRIBUTION) --source-file=$< --obj-file=$@

/* make functions to help produce pic versions of things... */
picobjs = $(patsubst %.o,%-pic.o,$(1))
#endif


/* Since the *_target macros use the objlist and libs variables BOTH
	for the link line AND the dependency list, we get screwed if we
	ever need to pass special flags or something in the libs variable
	via the *_target macro since those flags show up in the dependancy
	line and screw up make. So, these are the things we are going
	to allow to exist on the dependancy line for the program. */
#define DEP_FILTER %.o %.a %.so %.la

/* print out information about the function I'm translating. */
#define func(x)[Concat(FUNC_,x):__LINE__]

/* When I mangle certain tokens to have prefixes, what should they be? */
/* Add a 'condor_' prefix to whatever token I asked for */
#ifndef precon
#define precon(x)Concat(condor_,x)
#endif /* precon */

/* Add a 'strip_' prefix to whatever token I asked for */
#ifndef prestrip
#define prestrip(x)Concat(strip_,x)
#endif /* prestrip */

/* Add a 'static_' prefix to whatever token I asked for */
#ifndef prestatic
#define prestatic(x)Concat(static_,x)
#endif /* prestatic */

/* Add a '_dir' suffix to whatever token I asked for */
#ifndef sufdir
#define sufdir(x)Concat(x,_dir)
#endif /* sufdir */

/* --------------------------------------------------------------------- */
/* This section are all of the available rules for Imakefiles */

#define junkdir(daemon)Concat3(junk,_,daemon)
#define soapname(daemon)Concat(soap_,daemon)
#define gsoapname(daemon)Concat(gsoap_,daemon)

/*
** Set up to make all the objects in a particular directory.
*/

/* Create an object target */
#ifndef object_target
#define object_target(_name,obj_name)					@@\
XCOMM Begin translation of func(object_target) @@\
_name: obj_name					@@\
	cd obj_name; $(MAKE) $(SMP_FLAGS)			@@\
release:: obj_name					@@\
	cd obj_name; $(MAKE) release			@@\
stripped:: obj_name					@@\
	cd obj_name; $(MAKE) stripped			@@\
static:: obj_name					@@\
	cd obj_name; $(MAKE) static			@@\
depend:: obj_name					@@\
	cd obj_name; $(MAKE) depend			@@\
clean:: obj_name					@@\
	cd obj_name; $(MAKE) clean			@@\
docs:: obj_name					@@\
	cd obj_name; $(MAKE) html				@@\
testbin:: obj_name					@@\
	cd obj_name; $(MAKE) testbin				@@\
makefiles:: obj_name obj_name/Makefile	@@\
obj_name/Makefile:					@@\
	cd obj_name; ../condor_imake 	@@\
object_dir_target(obj_name)		@@\
XCOMM End translation of func(object_target) 
#endif /* object_target */

/* Create an object target under the condor_* namespace.
 * Don't be tempted to redefine this rule in terms of the above
 * object_target() macro.  CPP does not allow directives inside a
 * macro argument.
 */
#ifndef condor_object_target
#define condor_object_target(obj_name)					@@\
XCOMM Begin translation of func(condor_object_target) @@\
obj_name: precon(obj_name)					@@\
	cd precon(obj_name); $(MAKE) $(SMP_FLAGS)			@@\
release:: precon(obj_name)					@@\
	cd precon(obj_name); $(MAKE) release			@@\
stripped:: precon(obj_name)					@@\
	cd precon(obj_name); $(MAKE) stripped			@@\
static:: precon(obj_name)					@@\
	cd precon(obj_name); $(MAKE) static			@@\
depend:: precon(obj_name)					@@\
	cd precon(obj_name); $(MAKE) depend			@@\
clean:: precon(obj_name)					@@\
	cd precon(obj_name); $(MAKE) clean			@@\
docs:: precon(obj_name)					@@\
	cd precon(obj_name); $(MAKE) html				@@\
testbin:: precon(obj_name)					@@\
	cd precon(obj_name); $(MAKE) testbin				@@\
makefiles:: precon(obj_name) precon(obj_name)/Makefile	@@\
precon(obj_name)/Makefile:					@@\
	cd precon(obj_name); ../condor_imake 	@@\
object_dir_target(precon(obj_name))		@@\
XCOMM End translation of func(condor_object_target) 
#endif /* condor_object_target */

/*
** List everything which should be built in this object tree.
*/
#define all_target(targetlist)				@@\
XCOMM Begin translation of func(all_target) @@\
all:: targetlist @@\
XCOMM End translation of func(all_target)

/*
** Just build a given thing from a given directory.
*/
#define single_target(dir,target)			@@\
XCOMM Begin translation of func(single_target) @@\
dir/target: dir							@@\
	cd dir; $(MAKE) $(SMP_FLAGS) target	@@\
XCOMM End translation of func(single_target)



/***********************************************************************
** building targets
**
** These rules are used for building various aspects of Condor.
** Primarily, binaries and libraries.  Binaries be dymanically
** linked, include debugging info, and not be stripped.
***********************************************************************/

/*
** Build a library from .o files.
*/
#ifndef library_target
#define library_target(libname,objlist)		@@\
XCOMM Begin translation of func(library_target) @@\
libname: objlist					@@\
	rm -f libname					@@\
	AR_REPLACE(libname,objlist)			@@\
clean::							@@\
	rm -f libname objlist		@@\
XCOMM End translation of func(library_target)
#endif /* library_target */

#ifdef HAVE_CC_SHARED_FLAG
/*
** Build a shared library from .o files, and force PIC code for the objs.
*/
#ifndef shared_library_target
#define shared_library_target(libname,objlist)		@@\
XCOMM Begin translation of func(shared_library_target) @@\
libname: $(call picobjs,objlist)					@@\
	rm -f libname						@@\
	$(CC) $(CC_SHARED_FLAGS) $(CC_PIC_FLAGS) -o libname $(call picobjs,objlist) @@\
clean::							@@\
	rm -f libname $(call picobjs,objlist)		@@\
XCOMM End translation of func(shared_library_target)
#endif /* sahred_library_target */
#endif

/*
** Build a C program from .o files and libraries.
*/
/* everyone else gets a normal link rule */
#ifndef program_target
#define	program_target(program,objlist,libs)		@@\
XCOMM Begin translation of func(program_target) @@\
program: $(filter DEP_FILTER,objlist libs)						@@\
	$(C_LINK) $(CFLAGS) -o program objlist libs $(ALL_LDFLAGS)	@@\
clean::								@@\
	rm -f program objlist			@@\
XCOMM End translation of func(program_target)
#endif /* program_target */


/*
** Build a C program from .o files and libraries supplying the compile time
** and link time flags. For building utilites with special flags.
*/
#ifndef program_target_complex
#define	program_target_complex(program,objlist,comflags,linkflags,libs)	@@\
XCOMM Begin translation of func(program_target_complex) @@\
program: $(filter DEP_FILTER,objlist libs)						@@\
	$(C_LINK) comflags -o program objlist libs linkflags	@@\
clean::								@@\
	rm -f program objlist			@@\
XCOMM End translation of func(program_target_complex)
#endif  /* program_target_complex */


/*
** Build a C++ program from .o files and libraries.
*/
#ifndef c_plus_target_real
#define c_plus_target_real(program,objlist,libs,ldflags)	@@\
XCOMM Begin translation of func(c_plus_target_real)		@@\
program: $(filter DEP_FILTER,objlist libs)			@@\
	$(CC_LINK) $(C_PLUS_FLAGS) -o program objlist libs ldflags @@\
clean::								@@\
	rm -f program objlist					@@\
XCOMM End translation of func(c_plus_target_real)
#endif  /* c_plus_target_real */

#ifndef c_plus_target
#define	c_plus_target(program,objlist,libs)			@@\
XCOMM Begin translation of func(c_plus_target)			@@\
c_plus_target_real(program,objlist,libs,$(ALL_LDFLAGS))		@@\
XCOMM End translation of func(c_plus_target)
#endif  /* c_plus_target */

#ifndef c_plus_nowrap_target
#define	c_plus_nowrap_target(program,objlist,libs)		@@\
XCOMM Begin translation of func(c_plus_nowrap_target)		@@\
c_plus_target_real(program,objlist,libs,$(NOWRAP_LDFLAGS))	@@\
XCOMM End translation of func(c_plus_nowrap_target)
#endif  /* c_plus_nowrap_target */



/*
** Build a C++ program from .o files and libraries supplying the compile and
** link flags. For building utility programs with special flags.
*/
#ifndef c_plus_target_complex
#define	c_plus_target_complex(program,objlist,comflags,linkflags,libs)	@@\
XCOMM Begin translation of func(c_plus_target_complex) @@\
program: $(filter DEP_FILTER,objlist libs)						@@\
	$(CC_LINK) comflags -o program objlist libs linkflags @@\
clean::								@@\
	rm -f program objlist			@@\
XCOMM End translation of func(c_plus_target_complex)
#endif  /* c_plus_target_complex */


/*
** Build a Java class from a .java file.
**
*/

#ifndef java_target
#define java_target(classfile,sourcefile,cpath)        @@\
XCOMM Begin translation of func(java_target) @@\
classfile: sourcefile                                      @@\
	$(JAVAC) $(JAVACFLAGS) -classpath cpath sourcefile @@\
clean::                                                    @@\
	rm -f classfile										@@\
XCOMM End translation of func(java_target)
#endif

/*
** Build a JAR file from several .java files.
**
*/

#ifndef jar_target
#define jar_target(jarfile,sourcefiles,classroot) @@\
XCOMM Begin translation of func(jar_target) @@\
jarfile: sourcefiles                                  @@\
	$(JAVAC) $(JAVACFLAGS) -d . sourcefiles       @@\
	$(JAR) $(JARFLAGS) cf $@ classroot            @@\
clean::                                               @@\
	rm -rf jarfile classroot						@@\
XCOMM End translation of func(jar_target)
#endif

/***********************************************************************
** Auto generated file rules
**
** These rules are for building autogenerated files by various
** mechanisms.
***********************************************************************/

#ifdef HAVE_EXT_GSOAP
/* given the name of the daemon, produce a list of object files for the
	generated sources from soapcpp2 
*/
#define soapobjs(daemon) @@\
SOAP_OBJS = Concat(soapname(daemon),C).o Concat(soapname(daemon),Server).o Concat(soapname(daemon),Stub).o @@\
SOAP_SRC = Concat(soapname(daemon),C).cpp Concat(soapname(daemon),Server).cpp Concat(soapname(daemon),H).h Concat(soapname(daemon),Stub).h

/* given a daemon name, and a service, use the soap compiler to produce a 
	set of interface files in a temporary directory and then copy the files
	to the current working directory, and also copy the generated
	wsdl files into the proper release directories if requestred.
*/
#define gen_soapfiles(daemon,service) @@\
soapfiles:: gsoapname(daemon).h @@\
	$(SOAPCPP2) -I ../condor_daemon_core.V6 -S -L -x -p soapname(daemon) gsoapname(daemon).h @@\
	touch soapfiles @@\
	@@\
release_copy_target(service.wsdl,lib/webservice,service.wsdl,TEXT_MODE) @@\
strip_copy_target(service.wsdl,lib/webservice,service.wsdl,TEXT_MODE) @@\
static_copy_target(service.wsdl,lib/webservice,service.wsdl,TEXT_MODE) @@\
	@@\
clean:: @@\
	/bin/rm -f service.nsmap Concat(soapname(daemon),H).h Concat(soapname(daemon),Stub).h service.wsdl Concat(soapname(daemon),C).cpp Concat(soapname(daemon),Server).cpp soapfiles @@\
XCOMM Specifically add a dependancy from the generated .cpp files to the @@\
XCOMM .o files. Otherwise, the suffix rules do not get the dependencies @@\
XCOMM right. @@\
$(SOAP_OBJS): $(SOAP_SRC) @@\
$(SOAP_SRC): soapfiles
#else /* no HAVE_EXT_GSOAP */
#define soapobjs(daemon)
#define gen_soapfiles(daemon,service)
#endif /* HAVE_EXT_GSOAP */

/***********************************************************************
** testbin targets
**
** This rule simply copies a file to the testbin directory with the permissions
** specified.
***********************************************************************/

/*
** Copy the given file to the testbin directory
*/
#ifndef testbin_target
#define testbin_target(file,mode)		@@\
XCOMM Begin translation of func(testbin_target) @@\
$(TESTBIN_DIR)/file: file			@@\
	/bin/rm -f $(TESTBIN_DIR)/file	@@\
	cp file $(TESTBIN_DIR)			@@\
	chmod mode $(TESTBIN_DIR)/file	@@\
testbin:: $(TESTBIN_DIR)/file			@@\
XCOMM End translation of func(testbin_target)
#endif /* testbin_target */

/***********************************************************************
** release targets
**
** These rules are used for copying files that have already been built
** into the release_dir, which is unstripped, for use at our pool.
** All directories need to support a "release" rule.
***********************************************************************/

/*
** Copy the given file to the specified directory, with the given mode.
*/
#ifndef release_target
#define release_target(file,dir,mode)		@@\
XCOMM Begin translation of func(release_target) @@\
$(RELEASE_DIR)/dir/file: file			@@\
	/bin/rm -f $(RELEASE_DIR)/dir/file	@@\
	ln file $(RELEASE_DIR)/dir 2>/dev/null || cp file $(RELEASE_DIR)/dir			@@\
	chmod mode $(RELEASE_DIR)/dir/file	@@\
release:: $(RELEASE_DIR)/dir/file			@@\
XCOMM End translation of func(release_target)
#endif /* release_target */

/*
** Copy the given library to the specified directory, and run ranlib.
*/
#ifndef release_library
#define release_library(lib,dir) 			@@\
XCOMM Begin translation of func(release_library) @@\
$(RELEASE_DIR)/dir/lib: lib					@@\
	if [ -h lib ]; then COPY_LIBRARY(lib,$(RELEASE_DIR)/dir/lib); else ln lib $(RELEASE_DIR)/dir 2>/dev/null || COPY_LIBRARY(lib,$(RELEASE_DIR)/dir/lib); fi@@\
	RANLIB_TOUCH($(RELEASE_DIR)/dir/lib)			@@\
release:: $(RELEASE_DIR)/dir/lib	@@\
XCOMM End translation of func(release_library)
#endif  /* release_library */

/*
** Copy the given shared library to the specified directory
*/
#ifndef release_shared_library
#define release_shared_library(lib,dir) 			@@\
XCOMM Begin translation of func(release_shared_library) @@\
$(RELEASE_DIR)/dir/lib: lib					@@\
	COPY_LIBRARY(lib,$(RELEASE_DIR)/dir/lib)		@@\
release:: $(RELEASE_DIR)/dir/lib	@@\
XCOMM End translation of func(release_shared_library)
#endif  /* release_shared_library */


/*
** Target is released by creating a symbolic link to another.
*/
#ifndef release_symlink_target
#define release_symlink_target(src,dir,dest)	@@\
XCOMM Begin translation of func(release_symlink_target) @@\
release:: $(RELEASE_DIR)/dir/dest			@@\
							@@\
$(RELEASE_DIR)/dir/dest: 			@@\
	/bin/rm -f $(RELEASE_DIR)/dir/dest	@@\
	ln -s src $(RELEASE_DIR)/dir/dest			@@\
XCOMM End translation of func(release_symlink_target)
#endif /* release_symlink_target */

/*
** Just create a symlink. We need this for the test suite 
*/
#ifndef release_plain_symlink_target
#define release_plain_symlink_target(src,dest)		@@\
XCOMM Begin translation of func(release_plain_symlink_target) @@\
release:: dest					@@\
dest: 						@@\
	/bin/rm -f dest				@@\
	ln -s src dest				@@\
clean::						@@\
	/bin/rm -f dest		@@\
XCOMM End translation of func(release_plain_symlink_target)
#endif /* release_plain_symlink_target */

/*
** Target is released by creating a hard link to another.
*/
#ifndef release_link_target
#define release_link_target(dir,src,dest)	@@\
XCOMM Begin translation of func(release_link_target) @@\
release:: $(RELEASE_DIR)/dir/dest		@@\
						@@\
$(RELEASE_DIR)/dir/dest: $(RELEASE_DIR)/dir/src	@@\
	/bin/rm -f $(RELEASE_DIR)/dir/dest	@@\
	ln $(RELEASE_DIR)/dir/src $(RELEASE_DIR)/dir/dest	@@\
XCOMM End translation of func(release_link_target)
#endif /* release_link_target */


/*
** Target is released by copying
*/
#ifndef release_copy_target
#define release_copy_target(src,dir,dest,mode)	@@\
XCOMM Begin translation of func(release_copy_target) @@\
release:: $(RELEASE_DIR)/dir/dest		@@\
							@@\
$(RELEASE_DIR)/dir/dest: src			@@\
	/bin/rm -f $(RELEASE_DIR)/dir/dest	@@\
	cp src $(RELEASE_DIR)/dir/dest		@@\
	chmod mode $(RELEASE_DIR)/dir/dest	@@\
XCOMM End translation of func(release_copy_target)
#endif /* release_copy_target */



/*
** Target is released by recursive copying
*/
#ifndef release_recursive_copy_target
#define release_recursive_copy_target(src, dest )	@@\
XCOMM Begin translation of func(release_recursive_copy_target) @@\
release:: $(RELEASE_DIR)/dest	       			@@\
							@@\
$(RELEASE_DIR)/dest: src				@@\
	/bin/rm -rf $(RELEASE_DIR)/dest		@@\
	$(CP_CMD) src $(RELEASE_DIR)/dest	@@\
XCOMM End translation of func(release_recursive_copy_target)
#endif /* release_recursive_copy_target */

/***********************************************************************
** strip targets
**
** These rules are used for copying files that have already been built
** into the strip_dir, then stripping them if they're binaries, for
** distribution to the world.  All directories need to support a
** "stripped" rule. 
***********************************************************************/

/*
** This function is the method by which the debugging symbols are stripped
** from an executable. Sometimes, they are just stripped and that's it, 
** other times the stripping of the file results in a debug file being made
** which contains the debugging symbols. These debugging symbol files will
** always have .dbg appended to the file name.
*/
#if HAVE_DEBUGLINK_TARBALL

#ifndef strip_file
#define strip_file(file)$(OBJCOPY_CMD) $(OBJCOPY_KEEPDEBUG_FLAG) file file.dbg && $(OBJCOPY_CMD) $(OBJCOPY_STRIPUNNEEDED_FLAG) file && $(OBJCOPY_CMD) $(OBJCOPY_DEBUGLINK_FLAG)=file.dbg file && chmod 0644 file.dbg
#endif /* strip_file */

#else

#ifndef strip_file
#define strip_file(file)$(STRIP) file
#endif /* strip_file */

#endif

/*
** Copy a given file to the specified directory, with the given mode,
** and strip the binary.
*/
#ifndef strip_target
#define strip_target(file,dir,mode)			@@\
XCOMM Begin translation of func(strip_target) @@\
$(STRIP_DIR)/dir/file: file			@@\
	/bin/rm -f $(STRIP_DIR)/dir/file		@@\
	cp file $(STRIP_DIR)/dir			@@\
	strip_file($(STRIP_DIR)/dir/file) @@\
	chmod mode $(STRIP_DIR)/dir/file		@@\
stripped:: $(STRIP_DIR)/dir/file @@\
XCOMM End translation of func(strip_target) 
#endif  /* strip_target */


/*
** Copy the given library to the specified directory, and run ranlib.
*/
#ifndef strip_library
#define strip_library(lib,dir)			@@\
XCOMM Begin translation of func(strip_library) @@\
$(STRIP_DIR)/dir/lib: lib				@@\
	COPY_LIBRARY(lib,$(STRIP_DIR)/dir/lib)	@@\
	RANLIB_TOUCH($(STRIP_DIR)/dir/lib)	@@\
	chmod OBJECT_MODE $(STRIP_DIR)/dir/lib	@@\
stripped:: $(STRIP_DIR)/dir/lib		@@\
XCOMM End translation of func(strip_library)
#endif  /* strip_library */

/*
** Copy the given shared library to the specified directory
*/
#ifndef strip_shared_library
#define strip_shared_library(lib,dir)			@@\
XCOMM Begin translation of func(strip_shared_library) @@\
$(STRIP_DIR)/dir/lib: lib				@@\
	COPY_LIBRARY(lib,$(STRIP_DIR)/dir/lib)	@@\
	chmod OBJECT_MODE $(STRIP_DIR)/dir/lib	@@\
stripped:: $(STRIP_DIR)/dir/lib		@@\
XCOMM End translation of func(strip_shared_library)
#endif  /* strip_shared_library */


/* 
** Stripped target is released just by copying
*/
#ifndef strip_copy_target
#define strip_copy_target(src,dir,file,mode)	@@\
XCOMM Begin translation of func(strip_copy_target) @@\
$(STRIP_DIR)/dir/file: src			@@\
	/bin/rm -f $(STRIP_DIR)/dir/file		@@\
	cp src $(STRIP_DIR)/dir/file		@@\
	chmod mode $(STRIP_DIR)/dir/file		@@\
stripped:: $(STRIP_DIR)/dir/file		@@\
XCOMM End translation of func(strip_copy_target)
#endif /* strip_copy_target */


/*
** Stripped target is released by recursive copying
*/
#ifndef strip_recursive_copy_target
#define strip_recursive_copy_target(src,dest)			@@\
XCOMM Begin translation of func(strip_recursive_copy_target)	@@\
stripped:: $(STRIP_DIR)/dest					@@\
								@@\
$(STRIP_DIR)/dest: src						@@\
	/bin/rm -rf $(STRIP_DIR)/dest				@@\
	$(CP_CMD) src $(STRIP_DIR)/dest				@@\
XCOMM End translation of func(strip_recursive_copy_target)
#endif /* strip_recursive_copy_target */


/*
** Stripped target is released by creating a hard link to another. 
*/
#ifndef strip_link_target
#define strip_link_target(dir,src,dest)		@@\
XCOMM Begin translation of func(strip_link_target) @@\
stripped:: $(STRIP_DIR)/dir/dest		@@\
						@@\
$(STRIP_DIR)/dir/dest: $(STRIP_DIR)/dir/src	@@\
	/bin/rm -f $(STRIP_DIR)/dir/dest	@@\
	ln $(STRIP_DIR)/dir/src $(STRIP_DIR)/dir/dest	@@\
XCOMM End translation of func(strip_link_target)
#endif /* strip_link_target */



/*
** Stripped target is released by creating a symbolic link to another.
*/
#ifndef strip_symlink_target
#define strip_symlink_target(src,dir,dest)	@@\
XCOMM Begin translation of func(strip_symlink_target) @@\
stripped:: $(STRIP_DIR)/dir/dest		@@\
							@@\
$(STRIP_DIR)/dir/dest: 			@@\
	/bin/rm -f $(STRIP_DIR)/dir/dest		@@\
	ln -s src $(STRIP_DIR)/dir/dest		@@\
XCOMM End translation of func(strip_symlink_target)
#endif /* strip_symlink_target */



/***********************************************************************
** static targets
**
** These rules are used for creating the statically linked, stripped
** binary distribution for distribution to the world.  Any binary
** will be statically linked, then stripped, then copied into the
** given directory.  Other files should be put in the appropriate
** places for a full binary distribution (e.g. scripts, example files,
** libraries, etc).  All directories need to support a "static" rule. 
***********************************************************************/

/*
** Target to build a statically linked, stripped binary, placed in the
** specified directory.
*/
#ifndef static_target_real
#if HAS_STATIC
#define static_target_real(program,objlist,libs,dir,ldflags)	@@\
XCOMM Begin translation of func(static_target_real)		@@\
$(STATIC_DIR)/dir/program: program.static			@@\
	/bin/rm -f $(STATIC_DIR)/dir/program			@@\
	cp program.static $(STATIC_DIR)/dir/program		@@\
	chmod EXECUTABLE_MODE $(STATIC_DIR)/dir/program		@@\
	strip_file($(STATIC_DIR)/dir/program)			@@\
program.static: $(filter DEP_FILTER,objlist libs) 		@@\
	$(CC_LINK) $(STATIC)  $(C_PLUS_FLAGS) -o program.static objlist libs ldflags @@\
clean:: 							@@\
	rm -f program.static objlist				@@\
static:: $(STATIC_DIR)/dir/program @@\
XCOMM End translation of func(static_target_real)
#else  /* ! HAS_STATIC */
#define static_target_real(program,objlist,libs,dir,ldflags)	@@\
XCOMM Begin translation of func(static_target_real)		@@\
static::							@@\
XCOMM End translation of func(static_target_real)
#endif  /* HAS_STATIC */
#endif  /* static_target_real */

#ifndef static_target
#define static_target(program,objlist,libs,dir)			@@\
XCOMM Begin translation of func(static_target)			@@\
static_target_real(program,objlist,libs,dir,$(ALL_LDFLAGS))	@@\
XCOMM End translation of func(static_target)
#endif  /* static_target */

#ifndef static_nowrap_target
#define static_nowrap_target(program,objlist,libs,dir)		@@\
XCOMM Begin translation of func(static_nowrap_target)		@@\
static_target_real(program,objlist,libs,dir,$(NOWRAP_LDFLAGS))	@@\
XCOMM End translation of func(static_nowrap_target)
#endif  /* static_target */



/*
** Copy the given library to the specified directory, and run ranlib.
*/
#ifndef static_library
#if HAS_STATIC
#define static_library(lib,dir)			@@\
XCOMM Begin translation of func(static_library) @@\
$(STATIC_DIR)/dir/lib: lib			@@\
	COPY_LIBRARY(lib,$(STATIC_DIR)/dir/lib) @@\
	RANLIB_TOUCH($(STATIC_DIR)/dir/lib)	@@\
	chmod OBJECT_MODE $(STATIC_DIR)/dir/lib	@@\
static:: $(STATIC_DIR)/dir/lib @@\
XCOMM End translation of func(static_library)
#else  /* ! HAS_STATIC */
#define static_library(lib,dir)			@@\
XCOMM Begin translation of func(static_library) @@\
static::					@@\
XCOMM End translation of func(static_library)
#endif  /* HAS_STATIC */
#endif  /* static_library */

/*
** Copy the given shared library to the specified directory
*/
#ifndef static_shared_library
#if HAS_STATIC
#define static_shared_library(lib,dir)			@@\
XCOMM Begin translation of func(static_shared_library) @@\
$(STATIC_DIR)/dir/lib: lib			@@\
	COPY_LIBRARY(lib,$(STATIC_DIR)/dir/lib) @@\
	chmod OBJECT_MODE $(STATIC_DIR)/dir/lib	@@\
static:: $(STATIC_DIR)/dir/lib @@\
XCOMM End translation of func(static_shared_library)
#else  /* ! HAS_STATIC */
#define static_shared_library(lib,dir)			@@\
XCOMM Begin translation of func(static_shared_library) @@\
static::					@@\
XCOMM End translation of func(static_shared_library)
#endif  /* HAS_STATIC */
#endif  /* static_shared_library */


/* 
** Static target is released just by copying
*/
#ifndef static_copy_target
#if HAS_STATIC
#define static_copy_target(src,dir,file,mode)	@@\
XCOMM Begin translation of func(static_copy_target) @@\
$(STATIC_DIR)/dir/file: src			@@\
	/bin/rm -f $(STATIC_DIR)/dir/file	@@\
	cp src $(STATIC_DIR)/dir/file		@@\
	chmod mode $(STATIC_DIR)/dir/file	@@\
static:: $(STATIC_DIR)/dir/file	@@\
XCOMM End translation of func(static_copy_target)
#else  /* ! HAS_STATIC */
#define static_copy_target(src,dir,file,mode)	@@\
XCOMM Begin translation of func(static_copy_target) @@\
static::					@@\
XCOMM End translation of func(static_copy_target)
#endif  /* HAS_STATIC */
#endif /* static_copy_target */


/*
** Static target is released by recursive copying
*/
#ifndef static_recursive_copy_target
#if HAS_STATIC
#define static_recursive_copy_target(src,dest)			@@\
XCOMM Begin translation of func(static_recursive_copy_target)	@@\
static:: $(STATIC_DIR)/dest @@\
$(STATIC_DIR)/dest: src						@@\
	/bin/rm -rf $(STATIC_DIR)/dest				@@\
	$(CP_CMD) src $(STATIC_DIR)/dest			@@\
XCOMM End translation of func(static_recursive_copy_target)
#else  /* ! HAS_STATIC */
#define static_recursive_copy_target(src,dest)			@@\
XCOMM Begin translation of func(static_recursive_copy_target)	@@\
static::							@@\
XCOMM End translation of func(static_recursive_copy_target)
#endif  /* HAS_STATIC */
#endif /* static_recursive_copy_target */


/*
** Static target is released by creating a hard link to another. 
*/
#ifndef static_link_target
#if HAS_STATIC
#define static_link_target(dir,src,dest)	@@\
XCOMM Begin translation of func(static_link_target) @@\
static:: $(STATIC_DIR)/dir/dest	@@\
						@@\
$(STATIC_DIR)/dir/dest: $(STATIC_DIR)/dir/src	@@\
	/bin/rm -f $(STATIC_DIR)/dir/dest	@@\
	ln $(STATIC_DIR)/dir/src $(STATIC_DIR)/dir/dest	@@\
XCOMM End translation of func(static_link_target)
#else  /* ! HAS_STATIC */
#define static_link_target(dir,src,dest)	@@\
XCOMM Begin translation of func(static_link_target) @@\
static::					@@\
XCOMM End translation of func(static_link_target)
#endif  /* HAS_STATIC */
#endif /* static_link_target */

/*
** Static target is released by creating a symbolic link to another.
*/
#ifndef static_symlink_target
#if HAS_STATIC
#define static_symlink_target(src,dir,dest)	@@\
XCOMM Begin translation of func(static_symlink_target) @@\
static:: $(STATIC_DIR)/dir/dest @@\
$(STATIC_DIR)/dir/dest: 			@@\
	/bin/rm -f $(STATIC_DIR)/dir/dest	@@\
	ln -s src $(STATIC_DIR)/dir/dest	@@\
XCOMM End translation of func(static_symlink_target)
#else  /* ! HAS_STATIC */
#define static_symlink_target(src,dir,dest)	@@\
XCOMM Begin translation of func(static_symlink_target) @@\
static::					@@\
XCOMM End translation of func(static_symlink_target)
#endif  /* HAS_STATIC */
#endif /* static_symlink_target */


/***********************************************************************
** "public" targets
**
** These rules are used for "make public", which is how we build our
** actual releases (since "make release" has different legacy
** meaning).  these are basically just used to simplify your
** Imakefile, since anytime we want to put something in a tarball, we
** usually have to have 3 rules for it (release, static and
** stripped).  this way, we can just use a single target that invokes
** the other 3 for us automatically.  in some cases, like if we want
** to copy a separate ".static" version of something for "make
** static", we'll still have to use the individual rules directly, but
** in most cases, this will simplify a lot.
**
***********************************************************************/

/* Build public super target.
 * Build a program from C++ source, as well as the most common
 * dependent public release targets.
 */
#ifndef public_c_plus_target
#define public_c_plus_target(program,dir,objlist,libs) @@\
XCOMM Begin translation of func(c_plus_public_target) @@\
all_target(program) @@\
c_plus_target(program,objlist,libs) @@\
release_target(program,dir,EXECUTABLE_MODE) @@\
strip_target(program,dir,EXECUTABLE_MODE) @@\
static_target(program,objlist,libs,dir) @@\
XCOMM End translation of func(c_plus_public_target)
#endif /* public_c_plus_target */


/* Build public super target without any --wrap flags
 * Build a program from C++ source, as well as the most common
 * dependent public release targets.
 */
#ifndef public_c_plus_nowrap_target
#define public_c_plus_nowrap_target(program,dir,objlist,libs) @@\
XCOMM Begin translation of func(c_plus_public_nowrap_target) @@\
all_target(program) @@\
c_plus_nowrap_target(program,objlist,libs) @@\
release_target(program,dir,EXECUTABLE_MODE) @@\
strip_target(program,dir,EXECUTABLE_MODE) @@\
static_nowrap_target(program,objlist,libs,dir) @@\
XCOMM End translation of func(c_plus_public_nowrap_target)
#endif /* public_c_plus_nowrap_target */

/*
** Target is released by copying
*/
#ifndef public_copy_target
#define public_copy_target(src,dir,dest,mode)	@@\
XCOMM Begin translation of func(public_copy_target) @@\
release_copy_target(src,dir,dest,mode) @@\
strip_copy_target(src,dir,dest,mode) @@\
static_copy_target(src,dir,dest,mode) @@\
XCOMM End translation of func(public_copy_target)
#endif /* public_copy_target */


/* Build the super public_link_target, which generates the other kinds
   of hard-link targets.  all of these behave the same way, and we
   almost always want all 3 whenever we want one of them, so just
   group them.
*/
#ifndef public_link_target
#define public_link_target(dir,src,dst) @@\
XCOMM Begin translation of func(public_link_target) @@\
release_link_target(dir,src,dst)		    @@\
strip_link_target(dir,src,dst)			    @@\
static_link_target(dir,src,dst)			    @@\
XCOMM End translation of func(public_link_target)
#endif /* public_link_target */


/* Build the super public_symlink_target, which generates the other
   kinds of symbolic-link targets.  all of these behave the same way,
   and we almost always want all 3 whenever we want one of them, so
   just group them.
*/
#ifndef public_symlink_target
#define public_symlink_target(src,dir,dst) @@\
XCOMM Begin translation of func(public_symlink_target) @@\
release_symlink_target(src,dir,dst)		       @@\
strip_symlink_target(src,dir,dst)		       @@\
static_symlink_target(src,dir,dst)		       @@\
XCOMM End translation of func(public_symlink_target)
#endif /* public_symlink_target */


#ifndef public_library
#define public_library(lib,dir) 		@@\
XCOMM Begin translation of func(public_library) @@\
release_library(lib,dir)			@@\
strip_library(lib,dir)				@@\
static_library(lib,dir)				@@\
XCOMM End translation of func(public_library)
#endif /* public_symlink_target */


#ifndef public_shared_library
#define public_shared_library(lib,dir) 		@@\
XCOMM Begin translation of func(public_shared_library) @@\
release_shared_library(lib,dir)			@@\
strip_shared_library(lib,dir)				@@\
static_shared_library(lib,dir)				@@\
XCOMM End translation of func(public_library)
#endif /* public_symlink_target */


/***********************************************************************
** Misc link-related targets
**
** These rules are used for creating hard and soft links for various
** make targets.
**
***********************************************************************/


/*
** The all* targets make the links when you do a "make all".  They
** only take two args, a src and a dest, since they assume you want
** the links in the current directory.
*/
#ifndef all_link_target
#define all_link_target(src,dest)		@@\
XCOMM Begin translation of func(all_link_target) @@\
all:: dest					@@\
dest: src					@@\
	/bin/rm -f dest				@@\
	ln src dest				@@\
clean::						@@\
	/bin/rm -f dest			@@\
XCOMM End translation of func(all_link_target)
#endif /* all_link_target */


#ifndef all_symlink_target
#define all_symlink_target(src,dest)		@@\
XCOMM Begin translation of func(all_symlink_target) @@\
all:: dest					@@\
dest: src					@@\
	/bin/rm -f dest				@@\
	ln -s src dest				@@\
clean::						@@\
	/bin/rm -f dest			@@\
XCOMM End translation of func(all_symlink_target)
#endif /* all_symlink_target */


#ifndef all_copy_target
#define all_copy_target(src,dest)		@@\
XCOMM Begin translation of func(all_copy_target) @@\
all:: dest					@@\
dest: src					@@\
	/bin/rm -f dest				@@\
	cp src dest				@@\
clean::						@@\
	/bin/rm -f dest			@@\
XCOMM End translation of func(all_copy_target)
#endif /* all_copy_target */

/***********************************************************************
** tarball targets
**
** These rules are used for creating the contrib and release tarballs.
**
** The "both_tarball" is made with the first list of files from the
** regular, main directory, and the second list of contrib files that
** are copied in from the appropriate contrib directory, included in
** the tarball, then removed.
**
***********************************************************************/
#ifndef contrib_tarball
#define contrib_tarball(name,files)		@@\
XCOMM Begin translation of func(contrib_tarball) @@\
full_tarball(name,files,contrib)	@@\
move_contrib_tarballs(name)			@@\
XCOMM End translation of func(contrib_tarball)
#endif /* contrib_tarball */


#ifndef move_contrib_tarballs
#if HAS_STATIC
#define move_contrib_tarballs(name)			@@\
XCOMM Begin translation of func(move_contrib_tarball) @@\
name:: strip_contrib/name static_contrib/name	@@\
	mv strip_contrib/name strip_dir/name	@@\
	mv static_contrib/name static_dir/name	@@\
XCOMM End translation of func(move_contrib_tarball)
#else /* ! HAS_STATIC */
#define move_contrib_tarballs(name)			@@\
XCOMM Begin translation of func(move_contrib_tarball) @@\
name:: strip_contrib/name				@@\
	mv strip_contrib/name strip_dir/name @@\
XCOMM End translation of func(move_contrib_tarball)
#endif /* HAS_STATIC */
#endif /* move_contrib_tarballs */


#ifndef release_tarball
#define release_tarball(name,files)	@@\
XCOMM Begin translation of func(release_tarball) @@\
full_tarball(name,files,dir)		@@\
XCOMM End translation of func(release_tarball)
#endif /* release_tarball */


#ifndef full_tarball
#define full_tarball(name,files,type)		@@\
XCOMM Begin translation of func(full_tarball) @@\
strip_full_tarball(name,files,type)	@@\
static_full_tarball(name,files,type)	@@\
XCOMM End translation of func(full_tarball)
#endif /* full_tarball */


#ifndef strip_full_tarball
#define strip_full_tarball(name,files,type)		@@\
XCOMM Begin translation of func(strip_full_tarball) @@\
name:: prestrip(type)/name			@@\
							@@\
prestrip(type)/name: stripped			@@\
	/bin/rm -f prestrip(type)/name		@@\
	cd prestrip(type); $(TAR_CMD) -cvf name files	@@\
XCOMM End translation of func(strip_full_tarball)
#endif /* strip_full_tarball */


#ifndef static_full_tarball
#if HAS_STATIC
#define static_full_tarball(name,files,type)	@@\
XCOMM Begin translation of func(static_full_tarball) @@\
name:: prestatic(type)/name			@@\
							@@\
prestatic(type)/name: static			@@\
	/bin/rm -f prestatic(type)/name		@@\
	cd prestatic(type); $(TAR_CMD) -cvf name files	@@\
XCOMM End translation of func(static_full_tarball)
#else 
#define static_full_tarball(name,files,type) /* NULL MACRO */ @@\
XCOMM Begin translation of func(static_full_tarball)	@@\
XCOMM NULL BODY									@@\
XCOMM End translation of func(static_full_tarball)
#endif /* HAS_STATIC */
#endif /* static_full_tarball */



#ifndef both_tarball
#define both_tarball(name,files,contribfiles)		@@\
XCOMM Begin translation of func(both_tarball) @@\
strip_both_tarball(name,files,contribfiles)	@@\
static_both_tarball(name,files,contribfiles)	@@\
XCOMM End translation of func(both_tarball)
#endif /* both_tarball */


#ifndef strip_both_tarball
#define strip_both_tarball(name,files,contribfiles)		@@\
XCOMM Begin translation of func(strip_both_tarball) @@\
name:: strip_dir/name		@@\
							@@\
strip_dir/name: stripped	@@\
	perl condor_scripts/make_both_tarball -cmd "$(TAR_CMD)" strip, name, files, contribfiles	@@\
XCOMM End translation of func(strip_both_tarball)
#endif /* strip_both_tarball */


#ifndef static_both_tarball
#if HAS_STATIC
#define static_both_tarball(name,files,contribfiles)	@@\
XCOMM Begin translation of func(static_both_tarball) @@\
name:: static_dir/name					@@\
								@@\
static_dir/name: static					@@\
	perl condor_scripts/make_both_tarball -cmd "$(TAR_CMD)" static, name, files, contribfiles	@@\
XCOMM End translation of func(static_both_tarball)
#else 
#define static_both_tarball(name,files,contribfiles) /* NULL MACRO */ @@\
XCOMM Begin translation of func(static_both_tarball)	@@\
XCOMM NULL BODY									@@\
XCOMM End translation of func(static_both_tarball)
#endif /* HAS_STATIC */
#endif /* static_both_tarball */

/***********************************************************************
** condor_compile rules
**
** Rules to link programs with the Condor libraries using
** condor_compile.  These are used primarily in the test suites. 
***********************************************************************/

/* This is a little weird, but if "FLAGS_MACRO_NAME" is defined, we're
   in a compiler-specific subdirectory of the test suite.  If it's
   not, we're at the top-level, so how we find condor_compile and
   condor_arch link are different...
*/
#ifdef FLAGS_MACRO_NAME
CONDOR_COMPILE = ../../condor_scripts/condor_compile
CONDOR_ARCH_LINK = perl ../../condor_scripts/condor_arch_link
PRE_BUILT_RELEASE = ../../release_dir
#else
CONDOR_COMPILE = ../condor_scripts/condor_compile
CONDOR_ARCH_LINK = perl ../condor_scripts/condor_arch_link
PRE_BUILT_RELEASE = ../release_dir
#endif


/*
** Link a program with Condor libraries for the standard universe
*/
#ifndef CLINK
#if IS_CLIPPED
#define CLINK(compiler,name,obj) /* */ @@\
XCOMM Begin translation of func(CLINK)    @@\
XCOMM NULL BODY!           @@\
XCOMM End translation of func(CLINK)
#else
#define CLINK(compiler,name,obj)    @@\
XCOMM Begin translation of func(CLINK)    @@\
all:: name.cndr.exe           @@\
name:: name.cndr.exe          @@\
	@$(TRUE)          @@\
name.cndr.exe: $(CONDOR_COMPILE) $(PRE_BUILT_RELEASE)/lib obj  @@\
	$(CONDOR_COMPILE) $(CONDOR_COMPILE_FLAGS) compiler -o name.cndr.exe obj $(TEST_LDFLAGS) @@\
	$(CONDOR_ARCH_LINK) name.cndr.exe      @@\
clean::                 @@\
	rm -f name.cndr.exe obj       @@\
XCOMM End translation of func(CLINK)
#endif /* IS_CLIPPED */
#endif /* CLINK */


/*
** Link a program to run normally intended for the standard universe
** without libraries at all
*/
#ifndef CLINK_NOSTD
#define CLINK_NOSTD(compiler,name,obj)    @@\
XCOMM Begin translation of func(CLINK_NOSTD) @@\
all:: name.exe             @@\
name:: name.exe               @@\
	@$(TRUE)          @@\
name.exe: obj x_fake_ckpt.o         @@\
	compiler -o name.exe obj x_fake_ckpt.o $(TEST_LDFLAGS)   @@\
clean::                 @@\
	rm -f name.exe obj         @@\
XCOMM End translation of func(CLINK_NOSTD)
#endif /* CLINK_NOSTD */


/*
** Link a program to run normally (no condor libraries at all)
*/
#ifndef LINK
#define LINK(compiler,name,obj)			@@\
XCOMM Begin translation of func(LINK)		@@\
LINK_LIB(compiler,name,obj,)			@@\
XCOMM End translation of func(LINK)
#endif /* LINK */

/*
** Link a program to run normally (no condor libraries at all)
** This takes a final argument for libraries to link with which 
** we do NOT attempt to remove in make clean...
*/
#ifndef LINK_LIB
#define LINK_LIB(compiler,name,obj,lib)		@@\
XCOMM Begin translation of func(LINK_LIB)	@@\
all:: name.exe					@@\
name:: name.exe					@@\
	@$(TRUE)				@@\
name.exe: obj					@@\
	compiler -o name.exe obj lib $(TEST_LDFLAGS)  @@\
clean::						@@\
	rm -f name.exe obj			@@\
XCOMM End translation of func(LINK_LIB)
#endif /* LINK_LIB */


/***********************************************************************
** test suite rules
**
** Rules to build, submit, and verify the test suite
***********************************************************************/

/*
** Make directory and Makefile for a compiler in the test suite.
*/

#ifndef C_COMPILER_TARGET
#define C_COMPILER_TARGET(compiledir,compiler,flags_macro_name) @@\
XCOMM Begin translation of func(C_COMPILER_TARGET)		@@\
all:: compiledir compiledir/Makefile				@@\
	cd compiledir; $(MAKE)					@@\
								@@\
compiledir: 							@@\
	mkdir compiledir					@@\
								@@\
compiledir/Imakefile:	CImakefile				@@\
	cd compiledir; /bin/rm -f Imakefile			@@\
	cd compiledir; ln -s ../CImakefile Imakefile		@@\
								@@\
compiledir/Makefile: compiledir compiledir/Imakefile		@@\
	cd compiledir; ../../condor_imake -I../../../config \	@@\
	   -I.. -DC_COMPILER=compiler \				@@\
	   -DFLAGS_MACRO_NAME=flags_macro_name			@@\
								@@\
clean::								@@\
	rm -rf compiledir compiler_list				@@\
								@@\
compiler_list:: compiler_list_compiledir			@@\
								@@\
compiler_list_compiledir:: safe_append.pl			@@\
	@perl safe_append.pl -v -f compiler_list -a compiledir	@@\
XCOMM End translation of func(C_COMPILER_TARGET)
#endif /* C_COMPILER_TARGET */


#ifndef CPP_COMPILER_TARGET
#define CPP_COMPILER_TARGET(compiledir,compiler,flags_macro_name)	@@\
XCOMM Begin translation of func(CPP_COMPILER_TARGET)		@@\
all:: compiledir compiledir/Makefile				@@\
	cd compiledir; $(MAKE)					@@\
								@@\
compiledir: 							@@\
	mkdir compiledir					@@\
								@@\
compiledir/Imakefile: CPPImakefile				@@\
	cd compiledir; /bin/rm -f Imakefile			@@\
	cd compiledir; ln -s ../CPPImakefile Imakefile		@@\
								@@\
compiledir/Makefile: compiledir compiledir/Imakefile		@@\
	cd compiledir; ../../condor_imake -I../../../config \	@@\
	   -I.. -DCPP_COMPILER=compiler \			@@\
	   -DFLAGS_MACRO_NAME=flags_macro_name			@@\
								@@\
clean::								@@\
	rm -rf compiledir compiler_list				@@\
								@@\
compiler_list:: compiler_list_compiledir			@@\
								@@\
compiler_list_compiledir:: safe_append.pl			@@\
	@perl safe_append.pl -v -f compiler_list -a compiledir	@@\
XCOMM End translation of func(CPP_COMPILER_TARGET)
#endif /* CPP_COMPILER_TARGET */


#ifndef F_COMPILER_TARGET
#define F_COMPILER_TARGET(compiledir,compiler,flags_macro_name,has_recursion) @@\
XCOMM Begin translation of func(F_COMPILER_TARGET) @@\
all:: compiledir compiledir/Makefile				@@\
	cd compiledir; $(MAKE)					@@\
								@@\
compiledir:							@@\
	mkdir compiledir					@@\
								@@\
compiledir/Imakefile: FImakefile				@@\
	cd compiledir; /bin/rm -f Imakefile			@@\
	cd compiledir; ln -s ../FImakefile Imakefile		@@\
								@@\
compiledir/Makefile: compiledir compiledir/Imakefile	@@\
	cd compiledir; ../../condor_imake -I../../../config \	@@\
		-I.. \	@@\
		-DF_COMPILER=compiler	\			@@\
		-DFLAGS_MACRO_NAME=flags_macro_name		@@\
								@@\
clean::								@@\
	rm -rf compiledir compiler_list				@@\
								@@\
compiler_list:: Concat(compiler_list_,compiledir)		@@\
								@@\
Concat(compiler_list_,compiledir):: safe_append.pl		@@\
	@perl safe_append.pl -v -f compiler_list -a compiledir	@@\
XCOMM End translation of func(F_COMPILER_TARGET)
#endif /* F_COMPILER_TARGET */


#ifndef F90_COMPILER_TARGET
#define F90_COMPILER_TARGET(compiledir,compiler,flags_macro_name,has_recursion) @@\
XCOMM Begin translation of func(F90_COMPILER_TARGET) @@\
all:: compiledir compiledir/Makefile				@@\
	cd compiledir; $(MAKE)					@@\
								@@\
compiledir:							@@\
	mkdir compiledir					@@\
								@@\
compiledir/Imakefile: F90Imakefile				@@\
	cd compiledir; /bin/rm -f Imakefile			@@\
	cd compiledir; ln -s ../F90Imakefile Imakefile		@@\
								@@\
compiledir/Makefile: compiledir compiledir/Imakefile	@@\
	cd compiledir; ../../condor_imake -I../../../config \	@@\
		-I.. \	@@\
		-DF_COMPILER=compiler	\			@@\
		-DFLAGS_MACRO_NAME=flags_macro_name		@@\
								@@\
clean::								@@\
	rm -rf compiledir compiler_list				@@\
								@@\
compiler_list:: Concat(compiler_list_,compiledir)		@@\
								@@\
Concat(compiler_list_,compiledir):: safe_append.pl		@@\
	@perl safe_append.pl -v -f compiler_list -a compiledir	@@\
XCOMM End translation of func(F90_COMPILER_TARGET)
#endif /* F_COMPILER_TARGET */


/***********************************************************************
** Rules for building, describing, and declaring tests
***********************************************************************/

#ifndef BUILD
#define BUILD(cmplr,name,ext)		@@\
XCOMM Begin translation of func(BUILD)	@@\
DEP_SYMLINK_EXT(name,ext)		@@\
LINK(cmplr,name,name.o)			@@\
XCOMM End translation of func(BUILD)
#endif /* BUILD */

#ifndef BUILD_DEP
#define BUILD_DEP(cmplr,name,ext,dep)	@@\
XCOMM Begin translation of func(BUILD_DEP) @@\
DEP_SYMLINK_EXT(name,ext)		@@\
LINK(cmplr,name,name.o dep)		@@\
XCOMM End translation of func(BUILD_DEP)
#endif /* BUILD_DEP */

#ifndef BUILD_DEP_LIB
#define BUILD_DEP_LIB(cmplr,name,ext,dep,lib)	@@\
XCOMM Begin translation of func(BUILD_DEP_LIB)	@@\
DEP_SYMLINK_EXT(name,ext)			@@\
LINK_LIB(cmplr,name,name.o dep,lib)		@@\
XCOMM End translation of func(BUILD_DEP_LIB)
#endif /* BUILD_DEP_LIB */

#ifndef CBUILD
#define CBUILD(cmplr,name,ext)		@@\
XCOMM Begin translation of func(CBUILD) @@\
DEP_SYMLINK_EXT(name,ext)		@@\
CLINK(cmplr,name,name.o)		@@\
CLINK_NOSTD(cmplr,name,name.o)		@@\
XCOMM End translation of func(CBUILD)
#endif /* CBUILD */

#ifndef CBUILD_DEP
#define CBUILD_DEP(cmplr,name,ext,dep)	@@\
XCOMM Begin translation of func(CBUILD_DEP) @@\
DEP_SYMLINK_EXT(name,ext)		@@\
CLINK(cmplr,name,name.o dep)		@@\
CLINK_NOSTD(cmplr,name,name.o dep)	@@\
XCOMM End translation of func(CBUILD_DEP)
#endif /* CBUILD_DEP */

#ifndef DEP_SYMLINK
#ifdef FLAGS_MACRO_NAME
#define DEP_SYMLINK(name,file)		@@\
XCOMM Begin translation of func(DEP_SYMLINK) @@\
name:: file				@@\
       @$(TRUE)				@@\
all:: file				@@\
file::					@@\
	/bin/rm -f file 		@@\
	ln -s ../file file		@@\
XCOMM End translation of func(DEP_SYMLINK)
#else /* ! defined(FLAGS_MACRO_NAME) */
#define DEP_SYMLINK(name,file)		@@\
XCOMM Begin translation of func(DEP_SYMLINK) @@\
XCOMM NULL BODY				@@\
XCOMM End translation of func(DEP_SYMLINK)
#endif /* defined(FLAGS_MACRO_NAME) */
#endif /* DEP_SYMLINK */

#ifndef DEP_SYMLINK_EXT
#define DEP_SYMLINK_EXT(name,ext)		@@\
XCOMM Begin translation of func(DEP_SYMLINK_EXT) @@\
DEP_SYMLINK(name,name.ext)			@@\
XCOMM End translation of func(DEP_SYMLINK_EXT)
#endif /* DEP_SYMLINK_EXT */


#ifndef DEPS
#define DEPS(name,deps)				@@\
XCOMM Begin translation of func(DEPS)		@@\
all:: deps					@@\
name:: deps					@@\
	@$(TRUE)				@@\
XCOMM End translation of func(DEPS)
#endif /* DEPS */


#ifndef RUN
#define RUN(name)				@@\
XCOMM Begin translation of func(RUN)		@@\
DEP_SYMLINK_EXT(name,run)			@@\
DEPS(name,Condor.pm CondorTest.pm CondorPersonal.pm x_param.basic_personal CondorUtils.pm x_general_client.pl)		@@\
list_all:: Concat(list_all__,name)		@@\
Concat(list_all__,name):: safe_append.pl name.run	@@\
	@perl safe_append.pl -v -f list_all -a name	@@\
XCOMM End translation of func(RUN)
#endif /* RUN */


/*
   TESTCLASS_DECL() is used to declare a new testclass in the test
   suite.  However, exactly what it has to do depends on if it's in
   the top-level Imakefile or in the compiler specific subdirs.  In
   the compiler specific subdirs, it just has to define a dummy rule
   for the given testclass so that "make [testclass]" will have at
   least 1 target, and will work, even if there are no tests to build
   for that class.  In the top-level, it has to find all the compiler
   subdirectories (by depending on the compiler_list), and for each
   one in the list, cd into the corresponding subdirectory and invoke
   "make [testclass]".

   There are some things this rule will do in common, regardless of if
   it's in the top-level or a compiler subdirectory.  These tasks are
   put in a common rule, TESTCLASS_DECL_BASE(), so they can be shared.
*/
#ifndef TESTCLASS_DECL
#ifdef FLAGS_MACRO_NAME
#define TESTCLASS_DECL(classname)		@@\
XCOMM Begin translation of func(TESTCLASS_DECL)	@@\
TESTCLASS_DECL_BASE(classname)			@@\
classname::					@@\
	@$(TRUE)				@@\
XCOMM End translation of func(TESTCLASS_DECL)
#else /* ! FLAGS_MACRO_NAME */
#define TESTCLASS_DECL(classname)		@@\
XCOMM Begin translation of func(TESTCLASS_DECL)	@@\
TESTCLASS_DECL_BASE(classname)			@@\
classname:: compiler_list			@@\
	for X in `cat compiler_list` ; do \	@@\
	    $(MAKE) $$X/Makefile; \		@@\
	     cd $$X; $(MAKE) classname; cd ..; \	@@\
	done					@@\
XCOMM End translation of func(TESTCLASS_DECL)
#endif /* FLAGS_MACRO_NAME */
#endif /* TESTCLASS_DECL */

/*
   This rule contains common stuff for both versions of
   TESTCLASS_DECL().  See the comment above for why there are two.
   This rule handles all the testclass list related work.  In
   particular, it ensures that the "all_lists" target depends on
   making a list for this class, it adds this class to the master list
   of all testclasses ("list_testclass"), it initializes the list for
   this specific testclass ("list_[classname]"), and cleans up all of
   the above on "make clean".
*/
#ifndef TESTCLASS_DECL_BASE
#define TESTCLASS_DECL_BASE(classname)		@@\
XCOMM Begin translation of func(TESTCLASS_DECL_BASE) @@\
all_lists:: Concat(list_,classname)		@@\
list_testclass:: Concat(list_testclass_,classname)	@@\
Concat(list_testclass_,classname):: safe_append.pl	@@\
	@perl safe_append.pl -v -f list_testclass -a classname	@@\
Concat(list_,classname):: list_testclass	@@\
	touch Concat(list_,classname)		@@\
clean::						@@\
	rm -f list_testclass Concat(list_,classname) @@\
XCOMM End translation of func(TESTCLASS_DECL_BASE)
#endif /* TESTCLASS_DECL_BASE */


/*
   This rule is how a given test is added to a specific testclass.
   It ensures that the "all_lists" target depends on this testclass's
   list, which helps us catch errors early in the build process.  It
   also ensures that the classname itself depends on this test
   (e.g. "TESTCLASS(foo,bar)" will ensure that "make bar" will build
   test foo), and it verifies that this testclass has been properly
   declared with a TESTCLASS_DECL() rule.  It does this final step by
   depending on the master list of testclasses (which is only created
   and populated by TESTCLASS_DECL() rules), and it greps through that
   list to find the given testclass this rule is envoked with.  If
   this rule is being called with a testclass not in the master list,
   make will fail with a verbose error message.  If it's being called
   with a valid testclass, it appends the given testname into the list
   for the given classname.
*/
#ifndef TESTCLASS
#define TESTCLASS(testname,classname)		@@\
XCOMM Begin translation of func(TESTCLASS)	@@\
all:: Concat(list_,classname)			@@\
all_lists:: Concat(list_,classname)		@@\
classname:: Concat4(list_,classname,__,testname)	@@\
classname:: testname				@@\
Concat(list_,classname):: Concat4(list_,classname,__,testname)	@@\
Concat4(list_,classname,__,testname):: list_testclass safe_append.pl	@@\
	@grep classname list_testclass > /dev/null; \	@@\
	if test $$? -ne 0 ; then \		@@\
	   CLASSNAME=str(classname); \		@@\
	   TESTNAME=str(testname); \		@@\
	   echo "ERROR: testclass \"$$CLASSNAME\" is not declared!"; \ @@\
	   echo "ERROR: test \"$$TESTNAME\" is in this testclass!"; \ @@\
	   echo "A) add a TESTCLASS_DECL() rule for \"$$CLASSNAME\", or"; \ @@\
	   echo "B) put \"$$TESTNAME\" in a different testclass"; \ @@\
	   exit 1; \				@@\
	fi					@@\
	@perl safe_append.pl -v -f Concat(list_,classname) -a testname  @@\
XCOMM End translation of func(TESTCLASS)
#endif /* TESTCLASS */


#ifndef DESC
#define DESC(name,description)	@@\
XCOMM Begin translation of func(DESC)		@@\
desc:: Concat(name,_desc)			@@\
	@$(TRUE)				@@\
Concat(name,_desc):				@@\
	@echo description > name.desc		@@\
XCOMM End translation of func(DESC)
#endif /* DESC */



/***********************************************************************
** Doc++ rules  
***********************************************************************/


/* This can't be called doc++_target b/c Imake doesn't like "+" */
#ifndef html_target
#define html_target(files)					@@\
XCOMM Begin translation of func(html_target) @@\
html: files							@@\
	/bin/rm -rf html					@@\
	DocCompiler -H -d html -u -g -l -j -p       \           @@\
		-m -f -B ../html/condor_banner.html \		@@\
		files @@\
XCOMM End translation of func(html_target)
#endif /* html_target */


/***********************************************************************
** misc rules
**
** Everything else.
***********************************************************************/

/*

** These macros are used to convert a string into a Makefile variable
** reference, by "dollar-paren-ifying" it.  We need to do this with
** two macros like this to get around weirdness caused by the
** pre-processor not doing the proper substitutions all at once.  See
** the comment in src/condor_c++_util/condor_version.C for more
** details.  -Derek Wright <wright@cs.wisc.edu> 1/25/00
*/ 
#define x_dollar_paren(a) $(a)
#define dollar_paren(a) x_dollar_paren(a)


/*
** These special object files are created by extracting a
** standard routine from a system library and changing the
** name by conversion to uppercase.
*/
#ifndef uppercase_target
#define uppercase_target(libname,objname,newname,old_string,new_string)	@@\
XCOMM Begin translation of func(uppercase_target) @@\
newname: libname ToUpper						@@\
	cd $(TMP_DIR); AR_EXTRACT(libname,objname);			@@\
	./ToUpper $(TMP_DIR)/objname newname old_string new_string 	@@\
	rm -f $(TMP_DIR)/objname	@@\
XCOMM End translation of func(uppercase_target)
#endif /* uppercase_target */


#ifndef obj_extract
#define obj_extract(libname,objname)			@@\
XCOMM Begin translation of func(obj_extract) @@\
objname: libname					@@\
	AR_EXTRACT(libname,objname);			@@\
clean:: 						@@\
	rm -f objname				@@\
XCOMM End translation of func(obj_extract)
#endif /* obj_extract */


/*
** Build a file using an awk program
*/
#ifndef awk_target
#define awk_target(targ,input,prog)			@@\
XCOMM Begin translation of func(awk_target) @@\
targ:	input prog					@@\
	awk -f prog input > targ			@@\
clean::							@@\
	rm -f targ		@@\
XCOMM End translation of func(awk_target)
#endif /* awk_target */

/*
** Import ".o" files from another directory as symbolic links.  Uses
** Make macro "IMPORT_LINKS" which must be initialized to the
** "import_links" shell script in this directory.
*/
#ifndef import_objs
#define import_objs(dir,obj)			@@\
XCOMM Begin translation of func(import_objs) @@\
obj:						@@\
	$(IMPORT_LINKS) dir obj			@@\
clean::						@@\
	rm -f obj	@@\
XCOMM End translation of func(import_objs)
#endif /* import_objs */


/*
** Just make a simple directory.
*/
#ifndef simple_dir_target
#define simple_dir_target(dirname)			@@\
XCOMM Begin translation of func(simple_dir_target) @@\
dirname:						@@\
	mkdir dirname					@@\
XCOMM End translation of func(simple_dir_target)
#endif  /* simple_dir_target */


/*
** Build an object directory with symbolic links back into the
** source directory.  Making it appear as though all the source
** files are in the directory where we want to build the objects
** will simplify the Makefiles.
** The really-clean rule is for blowing away a whole build workspace
** and starting over from scratch.  However, since that's totally
** overkill and dangerous for a source workspace, if we see a "CVS"
** directory, we print a message and exit.  Notice that we use "@if"
** to tell make to pass this directly to the shell.  That way, it
** doesn't echo this test for every directory, but instead just prints
** the error and bails out if it finds the directory.
*/

#ifndef object_dir_target
#define object_dir_target(dir_name)					@@\
XCOMM Begin translation of func(object_dir_target) @@\
dir_name:								@@\
	perl $(SRC_TREE)/condor_scripts/make_dir_tree dir_name $(SRC_TREE) @@\
really-clean::								@@\
	@if [ -d CVS ]; then echo "You definitely do NOT want to do this in your source repository." ; echo "Try doing it in a build directory, instead."; exit 1; fi @@\
	rm -rf dir_name		@@\
XCOMM End translation of func(object_dir_target)
#endif /* object_dir_target */


/*
** Build a skeleton object tree for a particular platform.
*/
#ifndef platform_target
#define platform_target(platform)			@@\
XCOMM Begin translation of func(platform_target) @@\
platform.init: platform ALWAYS				@@\
	cp GENERIC/CheckPlatformType.c platform		@@\
	cp Imakefile.platform_skel platform/Imakefile	@@\
	cd platform; ../condor_imake 		@@\
	cd platform; $(MAKE) directories; $(MAKE) depend	@@\
platform: 						@@\
	mkdir platform				@@\
XCOMM End translation of func(platform_target)
#endif  /* platform_target */


/*
** Check to make sure we are running on the correct kind of machine
** and operating system to make object files for this platform.
*/
#ifndef check_platform_target
#define check_platform_target				@@\
XCOMM Begin translation of func(check_platform_target) @@\
CheckPlatformType:					@@\
	rm -f CheckPlatformType				@@\
	cc $(CFLAGS) -o CheckPlatformType ../GENERIC/CheckPlatformType.c	@@\
	./CheckPlatformType				@@\
	rm -f CheckPlatformType			@@\
XCOMM End translation of func(check_platform_target)
#endif  /* check_platform_target */


/*
** Build Makefile dependencies for an object tree.
**
** We could just make one rule that takes a list of the source
** files. Because we have a lot of Imakefiles, and it's a pain to 
** list the source files, I have made a few different methods:
** 1) A target that takes a list of source files.
** 2) A target that takes a list of C++ objects and derives the
**    the list of C++ files. Note that you use it like:
**           depend_target_cplus_objects(OBJ)
**    That is, you don't have $OBJ, just OBJ.
** 3) A target that takes a list of C objects and derives the
**    list of C files. It is used like number #2.
**
** Also note that you can only use one of these in an Imakefile. 
** If you can't use #2 xor #3 for convenience, you have to list
** list out the sources to use for #1. 
*/

#ifndef depend_source_target
#define depend_source_target(source_list)  @@\
XCOMM Begin translation of func(depend_source_target) @@\
sinclude dependencies                      @@\
                                           @@\
depend:	ALWAYS                             @@\
	$(CPlusPlus) $(C_PLUS_FLAGS) -MM source_list > dependencies @@\
XCOMM End translation of func(depend_source_target)
#endif /* depend_source_target */


#ifndef depend_cplus_objects_target
#define depend_cplus_objects_target(obj_list)   @@\
XCOMM Begin translation of func(depend_cplus_objects_target) @@\
sinclude dependencies                           @@\
DEPEND_CPLUS_SRC := $(obj_list:.o=.C)       @@\
                                                @@\
depend:	ALWAYS				                    @@\
	$(CPlusPlus) $(C_PLUS_FLAGS) -MM $(DEPEND_CPLUS_SRC) > dependencies @@\
XCOMM End translation of func(depend_cplus_objects_target)
#endif /* depend_cplus_objects_target */


#ifndef depend_c_objects_target
#define depend_c_objects_target(obj_list)  @@\
XCOMM Begin translation of func(depend_c_objects_target) @@\
sinclude dependencies                      @@\
DEPEND_C_SRC := $(obj_list:.o=.c)      @@\
                                           @@\
depend:	ALWAYS				               @@\
	$(CPlusPlus) $(CFLAGS) -MM $(DEPEND_C_SRC) > dependencies	@@\
XCOMM End translation of func(depend_c_objects_target)
#endif /* depend_c_objects_target */

/* 
 * This isn't pretty, if we have externals we depend on the
 * man-current trigger, otherwise (i.e. --with-proper) we depend on
 * having the $(MAN_DIR) and a new target will create it for
 * us. Ideally, HAS_EXTERNALS should never be used. -matt 083107
 */
#if HAS_EXTERNALS
manpage_dependency=$(EXT_TRIGGER)/man-current
#else
manpage_dependency=man-current
#endif

#ifndef man_full_target
#define man_full_target(name,type)				@@\
XCOMM BEGIN translation of func(man_full_target)		@@\
manpages:: sufdir(type)/man/man1/name				@@\
sufdir(type)/man/man1/name: $(manpage_dependency)		@@\
	/bin/rm -f sufdir(type)/man/man1/name			@@\
	cp $(MAN_DIR)/man1/name sufdir(type)/man/man1/name	@@\
	chmod 0644 sufdir(type)/man/man1/name			@@\
XCOMM End translation of func(man_full_target)
#endif /* ifndef man_full_target */


#ifndef man_target
#if HAS_STATIC
#define man_target(name)				@@\
XCOMM BEGIN translation of func(man_target)		@@\
man_full_target(name,strip)				@@\
man_full_target(name,release)				@@\
man_full_target(name,static)				@@\
XCOMM End translation of func(man_target)
#else /* HAS_STATIC */
#define man_target(name)				@@\
XCOMM BEGIN translation of func(man_target)		@@\
man_full_target(name,strip)				@@\
man_full_target(name,release)				@@\
XCOMM End translation of func(man_target)
#endif /* HAS_STATIC */
#endif /* ifndef man_target */


/*
** Externals build rule
*/

#ifndef ext_target
#define ext_target(package_id,ext_dep)				@@\
XCOMM Begin translation of func(ext_target)			@@\
ext_nodep_target(package_id,ext_dep)				@@\
externals:: $(EXT_TRIGGER)/$(package_id)			@@\
XCOMM End translation of func(ext_target)
#endif

#ifndef ext_nodep_target
#define ext_nodep_target(package_id,ext_dep)	@@\
XCOMM Begin translation of func(ext_nodep_target) @@\
$(EXT_TRIGGER)/$(package_id): ext_dep			@@\
        $(EXT_SRC)/build_external --extern_src=$(EXT_SRC) --extern_build=$(EXT_BUILD) --package_name=$(package_id) --extern_config=$(EXT_CONFIG_SH) @@\
XCOMM End translation of func(ext_nodep_target)
#endif

