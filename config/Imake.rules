/*
** Set up some shared, common rules and defininitions
*/
.SUFFIXES: .C

.C.o:
	$(CPlusPlus) $(C_PLUS_FLAGS) -c $<

.f.o:
	$(Fortran) $(FFLAGS) -c $<
	
#define SET_GID_MODE		02775
#define EXECUTABLE_MODE		0755
#define OBJECT_MODE		0644
#define TEXT_MODE		OBJECT_MODE

#if defined(Demangler)
DEMANGLE = 2>&1 | Demangler
#endif


/*
** Set up to make all the objects in a particular directory.
*/
#ifndef object_target
#define object_target(obj_name)					@@\
##obj_name##: condor_##obj_name					@@\
	cd condor_##obj_name; make $(SMP_FLAGS)			@@\
release:: condor_##obj_name					@@\
	cd condor_##obj_name; make release			@@\
stripped:: condor_##obj_name					@@\
	cd condor_##obj_name; make stripped			@@\
static:: condor_##obj_name					@@\
	cd condor_##obj_name; make static			@@\
depend:: condor_##obj_name					@@\
	cd condor_##obj_name; make depend			@@\
clean:: condor_##obj_name					@@\
	cd condor_##obj_name; make clean			@@\
docs:: condor_##obj_name					@@\
	cd condor_##obj_name; make html				@@\
makefiles:: condor_##obj_name condor_##obj_name##/Makefile	@@\
condor_##obj_name##/Makefile:					@@\
	cd condor_##obj_name ; ../condor_imake 	@@\
object_dir_target(condor_##obj_name)		
#endif /* object_target */

/*
** List everything which should be built in this object tree.
*/
#define all_target(targetlist)				@@\
all:: targetlist

/*
** Just build a given thing from a given directory.
*/
#define single_target(dir, target)			@@\
##dir##/##target##: dir					@@\
	cd dir; make target


/***********************************************************************
** building targets
**
** These rules are used for building various aspects of Condor.
** Primarily, binaries and libraries.  Binaries be dymanically
** linked, include debugging info, and not be stripped.
***********************************************************************/

/*
** Build a library from .o files.
*/
#ifndef library_target
#define library_target( libname, objlist )		@@\
libname: objlist					@@\
	rm -f libname					@@\
	AR_REPLACE( libname, objlist )			@@\
clean::							@@\
	rm -f libname objlist
#endif /* library_target */


/*
** Build a C program from .o files and libraries.
*/
#ifndef program_target
#define	program_target( program, objlist, libs )		@@\
program: objlist libs						@@\
	$(C_LINK) $(CFLAGS) -o program objlist libs $(ALL_LDFLAGS)	@@\
clean::								@@\
	rm -f program objlist
#endif  program_target

/*
** Build a C program from .o files and libraries supplying the compile time
** and link time flags. For building utilitoes with special flags.
*/
#ifndef program_target_complex
#define	program_target_complex( program, objlist, comflags, linkflags, libs )		@@\
program: objlist libs						@@\
	$(C_LINK) comflags -o program objlist libs linkflags	@@\
clean::								@@\
	rm -f program objlist
#endif  program_target_complex


/*
** Build a C++ program from .o files and libraries.
*/
#ifndef c_plus_target
#define	c_plus_target( program, objlist, libs )			@@\
program: objlist libs						@@\
	$(CC_LINK) $(C_PLUS_FLAGS) -o program objlist libs \
		$(ALL_LDFLAGS) $(DEMANGLE)			@@\
clean::								@@\
	rm -f program objlist
#endif  c_plus_target

/*
** Build a C++ program from .o files and libraries supplying the compile and
** link flags. For building utility programs with special flags.
*/
#ifndef c_plus_target_complex
#define	c_plus_target_complex( program, objlist, comflags, linkflags, libs )	@@\
program: objlist libs						@@\
	$(CC_LINK) comflags -o program objlist libs \
		linkflags $(DEMANGLE)			@@\
clean::								@@\
	rm -f program objlist
#endif  c_plus_target_complex

/*
** Build a template instantiation object
*/
#ifndef template_inst
#define template_inst( srcfile, objfile )               @@\
objfile: srcfile                                        @@\
	 $(CPlusPlus) $(INST_C_PLUS_FLAGS) -c srcfile -o objfile
#endif /* template_inst_obj */


/***********************************************************************
** release targets
**
** These rules are used for copying files that have already been built
** into the release_dir, which is unstripped, for use at our pool.
** All directories need to support a "release" rule.
***********************************************************************/

/*
** Copy the given file to the specified directory, with the given mode.
*/
#ifndef release_target
#if RELEASE_IS_STATIC
#define release_target( file, dir, mode )		@@\
$(RELEASE_DIR)/##dir##/##file: file##.static		@@\
	/bin/rm -f $(RELEASE_DIR)/##dir##/##file	@@\
	cp file##.static $(RELEASE_DIR)/##dir##/##file	@@\
	chmod mode $(RELEASE_DIR)/##dir##/##file	@@\
release:: $(RELEASE_DIR)/##dir##/##file
#else /* ! RELEASE_IS_STATIC */
#define release_target( file, dir, mode )		@@\
$(RELEASE_DIR)/##dir##/##file: file			@@\
	/bin/rm -f $(RELEASE_DIR)/##dir##/##file	@@\
	cp file $(RELEASE_DIR)/##dir			@@\
	chmod mode $(RELEASE_DIR)/##dir##/##file	@@\
release:: $(RELEASE_DIR)/##dir##/##file
#endif   /* ! RELEASE_IS_STATIC */
#endif /* release_target */

/*
** Copy the given library to the specified directory, and run ranlib.
*/
#ifndef release_library
#define release_library( lib, dir ) 			@@\
$(RELEASE_DIR)/##dir##/##lib: lib					@@\
	COPY_LIBRARY( lib, $(RELEASE_DIR)/##dir##/##lib )		@@\
	RANLIB_TOUCH( $(RELEASE_DIR)/##dir##/##lib )			@@\
release:: $(RELEASE_DIR)/##dir##/##lib
#endif  release_library


/*
** Target is released by creating a symbolic link to another.
*/
#ifndef release_symlink_target
#define release_symlink_target( src, dir, dest )	@@\
release:: $(RELEASE_DIR)/##dir##/##dest			@@\
							@@\
$(RELEASE_DIR)/##dir##/##dest##: 			@@\
	/bin/rm -f $(RELEASE_DIR)/##dir##/##dest	@@\
	ln -s src $(RELEASE_DIR)/##dir##/##dest			
#endif /* release_symlink_target */

/*
** Just create a symlink. We need this for the test suite 
*/
#ifndef release_plain_symlink_target
#define release_plain_symlink_target( src, dest )		@@\
release:: dest					@@\
dest: 						@@\
	/bin/rm -f dest				@@\
	ln -s src dest				@@\
clean::						@@\
	/bin/rm -f dest
#endif /* release_plain_symlink_target */

/*
** Target is released by creating a hard link to another.
*/
#ifndef release_link_target
#define release_link_target( src, dir, dest )		@@\
release:: $(RELEASE_DIR)/##dir##/##dest##		@@\
							@@\
$(RELEASE_DIR)/##dir##/##dest##: src			@@\
	/bin/rm -f $(RELEASE_DIR)/##dir##/##dest	@@\
	ln src $(RELEASE_DIR)/##dir##/##dest		
#endif /* release_link_target */


/*
** Target is released by copying
*/
#ifndef release_copy_target
#define release_copy_target( src, dir, dest, mode )	@@\
release:: $(RELEASE_DIR)/##dir##/##dest##		@@\
							@@\
$(RELEASE_DIR)/##dir##/##dest##: src			@@\
	/bin/rm -f $(RELEASE_DIR)/##dir##/##dest	@@\
	cp src $(RELEASE_DIR)/##dir##/##dest		@@\
	chmod mode $(RELEASE_DIR)/##dir##/##dest
#endif /* release_copy_target */


/***********************************************************************
** strip targets
**
** These rules are used for copying files that have already been built
** into the strip_dir, then stripping them if they're binaries, for
** distribution to the world.  All directories need to support a
** "stripped" rule. 
***********************************************************************/

/*
** Copy a given file to the specified directory, with the given mode,
** and strip the binary.
*/
#ifndef strip_target
#define strip_target( file, dir, mode )			@@\
$(STRIP_DIR)/##dir##/##file##: file			@@\
	/bin/rm -f $(STRIP_DIR)/##dir##/##file		@@\
	cp file $(STRIP_DIR)/##dir			@@\
	$(STRIP) $(STRIP_DIR)/##dir##/##file		@@\
	chmod mode $(STRIP_DIR)/##dir##/##file		@@\
stripped:: $(STRIP_DIR)/##dir##/##file
#endif  strip_target


/*
** Copy the given library to the specified directory, and run ranlib.
*/
#ifndef strip_library
#define strip_library( lib, dir )			@@\
$(STRIP_DIR)/##dir##/##lib: lib				@@\
	COPY_LIBRARY( lib, $(STRIP_DIR)/##dir##/##lib )	@@\
	RANLIB_TOUCH( $(STRIP_DIR)/##dir##/##lib )	@@\
	chmod OBJECT_MODE $(STRIP_DIR)/##dir##/##lib	@@\
stripped:: $(STRIP_DIR)/##dir##/##lib
#endif  strip_library


/* 
** Stripped target is released just by copying
*/
#ifndef strip_copy_target
#define strip_copy_target( src, dir, file, mode )	@@\
$(STRIP_DIR)/##dir##/##file: src			@@\
	/bin/rm -f $(STRIP_DIR)/##dir##/##file		@@\
	cp src $(STRIP_DIR)/##dir##/##file		@@\
	chmod mode $(STRIP_DIR)/##dir##/##file		@@\
stripped:: $(STRIP_DIR)/##dir##/##file
#endif /* strip_copy_target */


/*
** Stripped target is released by creating a hard link to another. 
*/
#ifndef strip_link_target
#define strip_link_target( src, dir, dest )		@@\
stripped:: $(STRIP_DIR)/##dir##/##dest##		@@\
							@@\
$(STRIP_DIR)/##dir##/##dest##: src			@@\
	/bin/rm -f $(STRIP_DIR)/##dir##/##dest		@@\
	ln src $(STRIP_DIR)/##dir##/##dest		
#endif /* strip_link_target */


/*
** Stripped target is released by creating a symbolic link to another.
*/
#ifndef strip_symlink_target
#define strip_symlink_target( src, dir, dest )	@@\
stripped:: $(STRIP_DIR)/##dir##/##dest##		@@\
							@@\
$(STRIP_DIR)/##dir##/##dest##: 			@@\
	/bin/rm -f $(STRIP_DIR)/##dir##/##dest		@@\
	ln -s src $(STRIP_DIR)/##dir##/##dest
#endif /* strip_symlink_target */



/***********************************************************************
** static targets
**
** These rules are used for creating the statically linked, stripped
** binary distribution for distribution to the world.  Any binary
** will be statically linked, then stripped, then copied into the
** given directory.  Other files should be put in the appropriate
** places for a full binary distribution (e.g. scripts, example files,
** libraries, etc).  All directories need to support a "static" rule. 
***********************************************************************/

/*
** Target to build a statically linked, stripped binary, placed in the
** specified directory.
*/
#ifndef	static_target
#define	static_target( program, objlist, libs, dir )		@@\
dir##/##program: program##.static				@@\
	/bin/rm -f dir##/##program				@@\
	cp program##.static dir##/##program			@@\
	chmod EXECUTABLE_MODE dir##/##program			@@\
	$(STRIP) dir##/##program				@@\
program##.static: objlist libs					@@\
	$(CC_LINK) $(STATIC)  $(C_PLUS_FLAGS) -o program##.static objlist libs $(ALL_LDFLAGS) $(DEMANGLE) @@\
clean:: 							@@\
	rm -f program##.static objlist				@@\
static:: dir##/##program
#endif  /* static_target */


/*
** Copy the given library to the specified directory, and run ranlib.
*/
#ifndef static_library
#define static_library( lib, dir )			@@\
$(STATIC_DIR)/##dir##/##lib: lib			@@\
	COPY_LIBRARY( lib, $(STATIC_DIR)/##dir##/##lib ) @@\
	RANLIB_TOUCH( $(STATIC_DIR)/##dir##/##lib )	@@\
	chmod OBJECT_MODE $(STATIC_DIR)/##dir##/##lib	@@\
static:: $(STATIC_DIR)/##dir##/##lib
#endif  static_library


/* 
** Static target is released just by copying
*/
#ifndef static_copy_target
#define static_copy_target( src, dir, file, mode )	@@\
$(STATIC_DIR)/##dir##/##file: src			@@\
	/bin/rm -f $(STATIC_DIR)/##dir##/##file		@@\
	cp src $(STATIC_DIR)/##dir##/##file		@@\
	chmod mode $(STATIC_DIR)/##dir##/##file		@@\
static:: $(STATIC_DIR)/##dir##/##file
#endif static_copy_target


/*
** Static target is released by creating a hard link to another. 
*/
#ifndef static_link_target
#define static_link_target( src, dir, dest )		@@\
static:: $(STATIC_DIR)/##dir##/##dest##			@@\
							@@\
$(STATIC_DIR)/##dir##/##dest##: src			@@\
	/bin/rm -f $(STATIC_DIR)/##dir##/##dest		@@\
	ln src $(STATIC_DIR)/##dir##/##dest		
#endif /* static_link_target */


/*
** Static target is released by creating a symbolic link to another.
*/
#ifndef static_symlink_target
#define static_symlink_target( src, dir, dest )	@@\
static:: $(STATIC_DIR)/##dir##/##dest##			@@\
							@@\
$(STATIC_DIR)/##dir##/##dest##: 			@@\
	/bin/rm -f $(STATIC_DIR)/##dir##/##dest		@@\
	ln -s src $(STATIC_DIR)/##dir##/##dest
#endif /* static_symlink_target */


/***********************************************************************
** Misc link-related targets
**
** These rules are used for creating hard and soft links for various
** make targets.
**
***********************************************************************/


/*
** The all* targets make the links when you do a "make all".  They
** only take two args, a src and a dest, since they assume you want
** the links in the current directory.
*/
#ifndef all_link_target
#define all_link_target( src, dest )		@@\
all:: dest					@@\
dest: src					@@\
	/bin/rm -f dest				@@\
	ln src dest				@@\
clean::						@@\
	/bin/rm -f dest
#endif /* all_link_target */

#ifndef all_symlink_target
#define all_symlink_target( src, dest )		@@\
all:: dest					@@\
dest: src					@@\
	/bin/rm -f dest				@@\
	ln -s src dest				@@\
clean::						@@\
	/bin/rm -f dest
#endif /* all_symlink_target */



/***********************************************************************
** tarball targets
**
** These rules are used for creating the contrib and release tarballs.
**
** The "both_tarball" is made with the first list of files from the
** regular, main directory, and the second list of contrib files that
** are copied in from the appropriate contrib directory, included in
** the tarball, then removed.
**
***********************************************************************/
#ifndef contrib_tarball
#define contrib_tarball( name, files )		@@\
	full_tarball( name, files, contrib )	@@\
	move_contrib_tarballs( name )
#endif /* contrib_tarball */

#ifndef move_contrib_tarballs
#if HAS_STATIC
#define move_contrib_tarballs( name )			@@\
##name##:: strip_contrib/##name static_contrib/##name	@@\
	mv strip_contrib/##name strip_dir/##name	@@\
	mv static_contrib/##name static_dir/##name
#else /* ! HAS_STATIC */
#define move_contrib_tarballs( name )			@@\
##name##:: strip_contrib/##name				@@\
	mv strip_contrib/##name strip_dir/##name
#endif /* HAS_STATIC */
#endif /* move_contrib_tarballs */

#ifndef release_tarball
#define release_tarball( name, files )	@@\
	full_tarball( name, files, dir )
#endif /* release_tarball */

#ifndef full_tarball
#define full_tarball( name, files, type )		@@\
	strip_full_tarball(  name, files, type )	@@\
	static_full_tarball( name, files, type )
#endif /* full_tarball */

#ifndef strip_full_tarball
#define strip_full_tarball( name, files, type )		@@\
##name##:: strip_##type##/##name			@@\
							@@\
afs_##name##:: strip_##type##/##name			@@\
	cp strip_##type##/##name $(PUBLIC_D_TARGET)	@@\
							@@\
strip_##type##/##name##: stripped			@@\
	/bin/rm -f strip_##type##/##name		@@\
	cd strip_##type##; tar -cvf name --owner=root --group=root files
#endif /* strip_full_tarball */

#ifndef static_full_tarball
#if HAS_STATIC
#define static_full_tarball( name, files, type )	@@\
##name##:: static_##type##/##name			@@\
							@@\
afs_##name##:: static_##type##/##name			@@\
	cp static_##type##/##name $(PUBLIC_S_TARGET)	@@\
							@@\
static_##type##/##name##: static			@@\
	/bin/rm -f static_##type##/##name		@@\
	cd static_##type##; tar -cvf name --owner=root --group=root files
#else 
#define static_full_tarball( name, files, type ) /* NULL MACRO */
#endif /* HAS_STATIC */
#endif /* static_full_tarball */


#ifndef both_tarball
#define both_tarball( name, files, contribfiles )		@@\
	strip_both_tarball(  name, files, contribfiles )	@@\
	static_both_tarball( name, files, contribfiles )
#endif /* both_tarball */

#ifndef strip_both_tarball
#define strip_both_tarball( name, files, contribfiles )		@@\
##name##:: strip_dir/##name					@@\
								@@\
afs_##name##:: strip_dir/##name					@@\
	cp strip_dir/##name $(PUBLIC_D_TARGET)			@@\
								@@\
strip_dir/##name##: stripped					@@\
	perl condor_scripts/make_both_tarball strip##, name##, files##, contribfiles
#endif /* strip_both_tarball */

#ifndef static_both_tarball
#if HAS_STATIC
#define static_both_tarball( name, files, contribfiles )	@@\
##name##:: static_dir/##name					@@\
								@@\
afs_##name##:: static_dir/##name				@@\
	cp static_dir/##name $(PUBLIC_S_TARGET)			@@\
								@@\
static_dir/##name##: static					@@\
	perl condor_scripts/make_both_tarball static##, name##, files##, contribfiles
#else 
#define static_both_tarball( name, files, contribfiles ) /* NULL MACRO */
#endif /* HAS_STATIC */
#endif /* static_both_tarball */


/***********************************************************************
** PureSoftware targets
**
** These rules are used for creating special debugging binaries built
** for either purify, or purecoverage.
***********************************************************************/

#if IS_SUN4X

#define PureCollector concat3(-collector=,CrtLibPath,/ld)

#define	pure_c_plus_target( program, objlist, libs )	@@\
##program: objlist libs					@@\
	purify -g++=yes PureCollector $(CC_LINK) $(C_PLUS_FLAGS) -o program objlist libs $(TEST_LDFLAGS)	@@\
clean::							@@\
	rm -f program objlist

#define	purecov_c_plus_target( program, objlist, libs )	@@\
##program: objlist libs					@@\
	purecov -g++=yes PureCollector $(CC_LINK) $(C_PLUS_FLAGS) -o program objlist libs $(TEST_LDFLAGS)						@@\
clean:: 						@@\
	rm -f program objlist


#define	quantify_c_plus_target( program, objlist, libs )	@@\
##program: objlist libs						@@\
	quantify -g++=yes PureCollector $(CC_LINK) $(C_PLUS_FLAGS) -o program objlist libs $(TEST_LDFLAGS)	                                 @@\
clean::		 						@@\
	rm -f program objlist


#define	pure_target( dir, program )				@@\
$(PURE_DIR)/##program: $(PURE_DIR) dir##/##program		@@\
	cp dir##/##program $(PURE_DIR)/##program		@@\
dir##/##program: dir						@@\
	cd dir; make program					@@\
pure:: $(PURE_DIR)/##program

#else 

#define	pure_target( dir, program )			/* NULL MACRO */
#define	pure_c_plus_target( program, objlist, libs )	/* NULL MACRO */
#define	purecov_c_plus_target( program, objlist, libs )	/* NULL MACRO */
#define	quantify_c_plus_target( program, objlist, libs ) /* NULL MACRO */

#endif	/* IS_SUN4M_SOLARIS251 */


/***********************************************************************
** condor_compile rules
**
** Rules to link programs with the Condor libraries using
** condor_compile.  These are used primarily in the test suites. 
***********************************************************************/

CONDOR_COMPILE = ../../condor_scripts/condor_compile
CONDOR_ARCH_LINK = perl ../../condor_scripts/condor_arch_link

/*
** Link all three types of binaries
*/
#define LINK( compiler, remotetarg, vanillatarg, obj )	@@\
RLINK( compiler, remotetarg, obj );			@@\
VLINK( compiler, vanillatarg, obj );

/*
** Link a program for running remotely
*/
#define RLINK( compiler, remotetarg, obj )	@@\
remotetarg: obj					@@\
	$(CONDOR_COMPILE) $(CONDOR_COMPILE_FLAGS) compiler -o remotetarg obj $(TEST_LDFLAGS) @@\
	$(CONDOR_ARCH_LINK) remotetarg		@@\
clean::						@@\
	rm -f remotetarg obj			@@\
all:: remotetarg


/*
** Link a program to run normally (no condor at all)
*/
#define VLINK( compiler, vanillatarg, obj )			@@\
vanillatarg: obj fake_ckpt.o					@@\
	compiler -o vanillatarg obj fake_ckpt.o	$(TEST_LDFLAGS)	@@\
								@@\
clean::								@@\
	rm -f vanillatarg obj					@@\
all:: vanillatarg


/***********************************************************************
** test suite rules
**
** Rules to build, submit, and verify the test suite
***********************************************************************/


/*
** Make directory and Makefile for a compiler in the test suite.
*/

#define C_COMPILER_TARGET(compiledir, compiler, flags_macro_name) @@\
all:: compiledir compiledir##/Makefile				@@\
	cd compiledir; $(MAKE)					@@\
								@@\
compiledir##: 							@@\
	mkdir compiledir					@@\
								@@\
compiledir##/Imakefile:	CImakefile				@@\
	cd compiledir; /bin/rm -f Imakefile			@@\
	cd compiledir; ln -s ../CImakefile Imakefile		@@\
								@@\
compiledir##/Makefile: compiledir compiledir##/Imakefile	@@\
	cd compiledir; ../../condor_imake -I../../../config \	@@\
	   -DC_COMPILER=##compiler \				@@\
	   -DFLAGS_MACRO_NAME=##flags_macro_name		@@\
								@@\
clean::								@@\
	rm -rf compiledir						


#define CPP_COMPILER_TARGET(compiledir, compiler, flags_macro_name)	@@\
all:: compiledir compiledir##/Makefile				@@\
	cd compiledir; $(MAKE)					@@\
								@@\
compiledir##: 							@@\
	mkdir compiledir					@@\
								@@\
compiledir##/Imakefile: CPPImakefile				@@\
	cd compiledir; /bin/rm -f Imakefile			@@\
	cd compiledir; ln -s ../CPPImakefile Imakefile		@@\
								@@\
compiledir##/Makefile: compiledir compiledir##/Imakefile	@@\
	cd compiledir; ../../condor_imake -I../../../config \	@@\
	   -DCPP_COMPILER=##compiler \				@@\
	   -DFLAGS_MACRO_NAME=##flags_macro_name		@@\
								@@\
clean::								@@\
	rm -rf compiledir						


#define F_COMPILER_TARGET(compiledir, compiler, flags_macro_name, has_recursion) @@\
all:: compiledir compiledir##/Makefile				@@\
	cd compiledir; $(MAKE)					@@\
								@@\
compiledir##:							@@\
	mkdir compiledir					@@\
								@@\
compiledir##/Imakefile: FImakefile				@@\
	cd compiledir; /bin/rm -f Imakefile			@@\
	cd compiledir; ln -s ../FImakefile Imakefile		@@\
								@@\
compiledir##/Makefile: compiledir compiledir##/Imakefile	@@\
	cd compiledir; ../../condor_imake -I../../../config \	@@\
		-DFORTRAN_HAS_RECURSION=##has_recursion \	@@\
		-DF_COMPILER=##compiler	\			@@\
		-DFLAGS_MACRO_NAME=##flags_macro_name		@@\
								@@\
clean::								@@\
	rm -rf compiledir					


/*
** Rule for building and linking a given test program
*/
#define BUILD( cmplr, name, ext )		@@\
BUILD_FILES( name, ext )			@@\
RLINK( cmplr, name##.remote, name##.o )		@@\
VLINK( cmplr, name##.vanilla, name##.o )

#define RBUILD( cmplr, name, ext )		@@\
BUILD_FILES( name, ext )			@@\
RLINK( cmplr, name##.remote, name##.o )

#define BUILD_FILES( name, ext )		@@\
all:: name##.##ext name##.cmd name##.run	@@\
name##.##ext##:					@@\
	ln -s ../##name##.##ext .		@@\
name##.cmd:					@@\
	ln -s ../##name##.cmd .			@@\
name##.run:					@@\
	ln -s ../##name##.run .			@@\
clean::						@@\
	rm -f name##.##ext name##.cmd name##.run

/***********************************************************************
** Doc++ rules  
***********************************************************************/

/* This can't be called doc++_target b/c Imake doesn't like "+" */
#ifndef html_target
#define html_target( files )					@@\
html: files							@@\
	/bin/rm -rf html					@@\
	/unsup/doc++/bin/doc++ -H -d html -u -g -l -j -p \	@@\
		-m -f -B ../html/condor_banner.html \		@@\
		files
#endif /* html_target */


/***********************************************************************
** misc rules
**
** Everything else.
***********************************************************************/

/*

** These macros are used to convert a string into a Makefile variable
** reference, by "dollar-paren-ifying" it.  We need to do this with
** two macros like this to get around weirdness caused by the
** pre-processor not doing the proper substitutions all at once.  See
** the comment in src/condor_c++_util/condor_version.C for more
** details.  -Derek Wright <wright@cs.wisc.edu> 1/25/00
*/ 
#define x_dollar_paren(a) $( ## a ## )
#define dollar_paren(a) x_dollar_paren(a)


/*
** These special object files are created by extracting a
** standard routine from a system library and changing the
** name by conversion to uppercase.
*/
#ifndef uppercase_target
#define uppercase_target( libname, objname, newname, old_string, new_string )	@@\
newname: libname ToUpper						@@\
	cd $(TMP_DIR); AR_EXTRACT( libname, objname );			@@\
	./ToUpper $(TMP_DIR)/##objname newname old_string new_string 	@@\
	rm -f $(TMP_DIR)/##objname
#endif


#ifndef obj_extract
#define obj_extract( libname, objname )			@@\
objname: libname					@@\
	AR_EXTRACT( libname, objname );			@@\
clean:: 						@@\
	rm -f objname
#endif


/*
** Build a file using an awk program
*/
#ifndef awk_target
#define awk_target( targ, input, prog )			@@\
targ:	input prog					@@\
	awk -f prog input > targ			@@\
clean::							@@\
	rm -f targ
#endif


/*
** Import ".o" files from another directory as symbolic links.  Uses
** Make macro "IMPORT_LINKS" which must be initialized to the
** "import_links" shell script in this directory.
*/
#ifndef import
#define import( dir, obj )			@@\
obj:						@@\
	$(IMPORT_LINKS) dir obj			@@\
clean::						@@\
	rm -f obj
#endif /* import */


/*
** Just make a simple directory.
*/
#ifndef simple_dir_target
#define simple_dir_target(dirname)			@@\
##dirname##:						@@\
	mkdir dirname
#endif  simple_dir_target


/*
** Build an object directory with symbolic links back into the
** source directory.  Making it appear as though all the source
** files are in the directory where we want to build the objects
** will simplify the Makefiles.
*/
#ifndef object_dir_target
#define object_dir_target(dir_name)					@@\
##dir_name##:								@@\
	perl $(SRC_TREE)/condor_scripts/make_dir_tree dir_name $(SRC_TREE) @@\
really-clean::								@@\
	rm -rf dir_name
#endif /* object_dir_target */


/*
** Build a skeleton object tree for a particular platform.
*/
#ifndef platform_target
#define platform_target(platform)			@@\
platform.init: platform ALWAYS				@@\
	cp GENERIC/CheckPlatformType.c platform		@@\
	cp Imakefile.platform_skel platform/Imakefile	@@\
	cd platform ; ../condor_imake 		@@\
	cd platform ; make directories; make depend	@@\
platform: 						@@\
	mkdir platform
#endif  platform_target

/*
** Check to make sure we are running on the correct kind of machine
** and operating system to make object files for this platform.
*/
#ifndef check_platform_target
#define check_platform_target				@@\
CheckPlatformType:					@@\
	rm -f CheckPlatformType				@@\
	cc $(CFLAGS) -o CheckPlatformType ../GENERIC/CheckPlatformType.c	@@\
	./CheckPlatformType				@@\
	rm -f CheckPlatformType
#endif  check_platform_target


/*
** Build Makefile dependencies for an object tree.
**
** We could just make one rule that takes a list of the source
** files. Because we have a lot of Imakefiles, and it's a pain to 
** list the source files, I have made a few different methods:
** 1) A target that takes a list of source files.
** 2) A target that takes a list of C++ objects and derives the
**    the list of C++ files. Note that you use it like:
**           depend_target_cplus_objects(OBJ)
**    That is, you don't have $OBJ, just OBJ.
** 3) A target that takes a list of C objects and derives the
**    list of C files. It is used like number #2.
**
** Also note that you can only use one of these in an Imakefile. 
** If you can't use #2 xor #3 for convenience, you have to list
** list out the sources to use for #1. 
*/

#ifndef depend_source_target
#define depend_source_target(source_list)  @@\
sinclude dependencies                      @@\
                                           @@\
depend:	ALWAYS                             @@\
	$(CPlusPlus) $(C_PLUS_FLAGS) -MM source_list > dependencies
#endif

#ifndef depend_cplus_objects_target
#define depend_cplus_objects_target(obj_list)   @@\
sinclude dependencies                           @@\
DEPEND_CPLUS_SRC := $(##obj_list##:.o=.C)       @@\
                                                @@\
depend:	ALWAYS				                    @@\
	$(CPlusPlus) $(C_PLUS_FLAGS) -MM $(DEPEND_CPLUS_SRC) > dependencies
#endif

#ifndef depend_c_objects_target
#define depend_c_objects_target(obj_list)  @@\
sinclude dependencies                      @@\
DEPEND_C_SRC := $(##obj_list##:.o=.c)      @@\
                                           @@\
depend:	ALWAYS				               @@\
	$(CPlusPlus) $(CFLAGS) -MM $(DEPEND_C_SRC) > dependencies
#endif

/* The old definition of depend
depend: ALWAYS						@@\
	$(MKDEPEND) $(CFLAGS) src_list
*/

/*
** Build a tags file for a source directory.
*/
#ifndef tags_target
#define tags_target( c_files, libdirs )			@@\
tags: ALWAYS						@@\
	condor_ctags c_files -l libdirs			@@\
clean::							@@\
	rm -f tags
#endif 

